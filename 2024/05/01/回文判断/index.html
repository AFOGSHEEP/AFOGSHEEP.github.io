<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/32x32-avatar.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/32x32-avatar.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":"ture","sidebar":"ture","scrollpercent":"ture"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="是时候用一个简短的例子来结束短暂的STL学习了。 回文 回文是向前或向后阅读时相同的单词或短语，例如“racecar”或“Malayalam”。阅读回文时，习惯上会忽略空格、标点符号和大写字母，因此“Mr. Owl ate my metal worm”和“Go hang a salami! I&#39;m a lasagna hog。”这两句话将被视为回文。">
<meta property="og:type" content="article">
<meta property="og:title" content="STL运用示例：回文判断">
<meta property="og:url" content="http://example.com/2024/05/01/%E5%9B%9E%E6%96%87%E5%88%A4%E6%96%AD/index.html">
<meta property="og:site_name" content="杜鹃声">
<meta property="og:description" content="是时候用一个简短的例子来结束短暂的STL学习了。 回文 回文是向前或向后阅读时相同的单词或短语，例如“racecar”或“Malayalam”。阅读回文时，习惯上会忽略空格、标点符号和大写字母，因此“Mr. Owl ate my metal worm”和“Go hang a salami! I&#39;m a lasagna hog。”这两句话将被视为回文。">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2024-05-01T09:24:34.000Z">
<meta property="article:modified_time" content="2024-07-30T10:39:48.000Z">
<meta property="article:author" content="AAAFORGE">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="学习笔记">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2024/05/01/%E5%9B%9E%E6%96%87%E5%88%A4%E6%96%AD/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>STL运用示例：回文判断 | 杜鹃声</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">杜鹃声</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">斜阳暮</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2024/05/01/%E5%9B%9E%E6%96%87%E5%88%A4%E6%96%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1312386.jpeg">
      <meta itemprop="name" content="AAAFORGE">
      <meta itemprop="description" content="此情可待成追忆，只是当时已惘然">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杜鹃声">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          STL运用示例：回文判断
        </h1>

        <div class="post-meta">
        
          
            <i class="fa fa-thumb-tack"></i>
            <font color=7D26CD>置顶</font>
            <span class="post-meta-divider">|</span>
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-01 17:24:34" itemprop="dateCreated datePublished" datetime="2024-05-01T17:24:34+08:00">2024-05-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-07-30 18:39:48" itemprop="dateModified" datetime="2024-07-30T18:39:48+08:00">2024-07-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>是时候用一个简短的例子来结束短暂的STL学习了。</p>
<h2 id="回文">回文</h2>
<p>回文是向前或向后阅读时相同的单词或短语，例如“racecar”或“Malayalam”。阅读回文时，习惯上会忽略空格、标点符号和大写字母，因此“Mr.
Owl ate my metal worm”和“Go hang a salami! I'm a lasagna
hog。”这两句话将被视为回文。 <span id="more"></span></p>
<h2 id="判断实现">判断实现</h2>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsPalindrome</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; input.<span class="built_in">size</span>() / <span class="number">2</span>; ++k)</span><br><span class="line">            <span class="keyword">if</span>(input[k] != input[input.<span class="built_in">length</span>() - <span class="number">1</span> – k])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>这种方法只需遍历字符串的前半部分，检查每个字符是否等于字符串另一半上的相应字符。作为一种可能是头一个出现在脑海里的方法，他并没有错，但是太不优雅了。让我们用STL的方法试试。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsPalindrome</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">    string reversed = input;</span><br><span class="line">	 <span class="built_in">reverse</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> reversed == input;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>这种方法看起来好多了，但需要我们创建字符串的副本，因此效率低于我们的原始实现。我们可以使用迭代器以某种方式模拟初始
for 循环的功能吗？答案是肯定的，多亏了reverse_iterators。每个 STL
容器类都导出一个类型reverse_iterator，该类型类似于迭代器，只是它向后遍历容器。正如
begin 和 end 函数定义容器上的迭代器范围一样，rbegin 和 rend
函数定义跨容器的reverse_iterator范围。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isPalindrome</span><span class="params">(string input)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">equal</span>(input.<span class="built_in">begin</span>(),input.<span class="built_in">begin</span>()+ input.<span class="built_in">length</span>()/<span class="number">2</span>,input.<span class="built_in">rbegin</span>()); </span><br><span class="line">    <span class="comment">// rbegin()从end开始向前遍历</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上的这个代码一行即可实现判断的功能。</p>
<p>但这还不能正确处理大写、空格或标点符号。如何改进呢？让我们首先从字符串中剥离除字母字符之外的所有内容。对于此任务，我们可以使用
STL remove_if
算法，该算法接受迭代器范围和谓词作为输入，然后通过删除谓词返回 true
的所有元素来修改范围。与它的伙伴算法 remove 一样，remove_if
实际上并没有从序列中删除元素，因此我们需要在之后擦除剩余的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsNotAlpha</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123; <span class="comment">//&lt;cctype&gt;</span></span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isalpha</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsPalindrome</span><span class="params">(string input)</span></span>&#123;</span><br><span class="line">        input.<span class="built_in">erase</span>(<span class="built_in">remove_if</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(), IsNotAlpha),input.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">transform</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(), input.<span class="built_in">begin</span>(), ::toupper);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">equal</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">begin</span>() + input.<span class="built_in">size</span>() / <span class="number">2</span>,input.<span class="built_in">rbegin</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>在三行代码中，我们去除了字符串中所有不是字母的字符，将剩下的字符转换为大写，并返回字符串是否向前和向后相同。</p>
<p>的技术的力量。在结束这个例子之前，让我们考虑回文上的一个变体，我们检查短语中的单词是否向前和向后相同。例如，“Did
mom pop? Mom did!”是回文，无论是字母还是文字，而”This is
this“是一个短语，它不是回文，而是回文。与常规回文一样，我们将忽略空格和标点符号，因此“It's
an its”算作单词回文，即使它使用了两种不同形式的单词
its/it's。我们上面使用的算法适用于整个string，我们可以修改它以逐字工作吗？</p>
<p>我们仍然要忽略空格、标点符号和大写字母，但现在需要将单词而不是字母视为有意义的单位。有许多可能的算法可以检查此属性，但有一种解决方案特别好。思路如下：</p>
<p>1.清理输入：去掉除字母和空格以外的所有内容，然后将结果转换为大写。</p>
<p>2.将输入分解为单词列表。</p>
<p>3.向前和向后返回列表是否相同</p>
<p>这是一个完整的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsNotAlphaOrSpace</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isalpha</span>(ch) &amp;&amp; !<span class="built_in">isspace</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsWordPalindrome</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">        input.<span class="built_in">erase</span>(<span class="built_in">remove_if</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(), IsNotAlphaOrSpace),</span><br><span class="line">                    input.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">transform</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(), input.<span class="built_in">begin</span>(), ::toupper);</span><br><span class="line">        <span class="function">stringstream <span class="title">tokenizer</span><span class="params">(input)</span></span>;</span><br><span class="line">        vector&lt;string&gt; tokens;</span><br><span class="line">        tokens.<span class="built_in">insert</span>(tokens.<span class="built_in">begin</span>(),</span><br><span class="line">                      <span class="built_in">istream_iterator</span>&lt;string&gt;(tokenizer),</span><br><span class="line">                      <span class="built_in">istream_iterator</span>&lt;string&gt;());</span><br><span class="line">        <span class="comment">// 手动检查单词列表是否为回文,书里的equal()可能出现问题，具体https://blog.csdn.net/qq_52828510/article/details/121213451?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171454848816800184139758%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=171454848816800184139758&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-121213451-null-null.142</span></span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> end = input.<span class="built_in">length</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (input[start] != input[end]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string input;</span><br><span class="line">    <span class="built_in">getline</span>(cin,input);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsWordPalindrome</span>(input))&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;no&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="remove的使用介绍">remove的使用介绍</h2>
<p>代码中，<code>input.erase(...)</code>
这一部分是用来清除字符串中不需要的字符。具体来说，它结合了
<code>remove_if</code> 函数和 <code>erase</code>
方法来实现这个功能。这里是它的工作原理详解：</p>
<ol type="1">
<li><strong><code>remove_if</code> 函数</strong>：
<ul>
<li><code>remove_if</code> 是 C++ STL (Standard Template Library)
中的一个函数，用于从一个容器中移除满足特定条件的元素。</li>
<li>这个函数接受三个参数：容器的开始迭代器、结束迭代器和一个谓词函数（即一个返回布尔值、决定元素是否应被移除的函数）。</li>
<li>在您的代码中，谓词函数是
<code>IsNotAlphaOrSpace</code>，它检查一个字符是否既不是字母也不是空格。如果字符不是字母也不是空格，谓词返回
<code>true</code>，表示该字符应被移除。</li>
<li><code>remove_if</code>
实际上并不直接删除元素，而是通过重排容器中的元素，将所有不应被移除的元素移到容器的开始部分，返回一个新的迭代器，指向重排后的最后一个有效元素的下一个位置。</li>
</ul></li>
<li><strong><code>erase</code> 方法</strong>：
<ul>
<li>一旦 <code>remove_if</code> 完成了元素的重排，<code>erase</code>
方法被用来实际从容器中删除那些不需要的元素。</li>
<li><code>erase</code> 接受两个迭代器：开始和结束。在这里，它从
<code>remove_if</code> 返回的迭代器开始，到字符串的末尾。</li>
<li>这意味着所有从 <code>remove_if</code>
返回的迭代器到容器末尾的元素（即被标记为移除的元素）都将被从字符串中删除。</li>
</ul></li>
</ol>
<p>这样的组合使用<code>remove_if</code> 和 <code>erase</code>
被称为“擦除-删除”惯用法（Erase-Remove
Idiom），是一种高效清理容器的方式。</p>
<h2 id="练习">练习</h2>
<p><strong>1. 为什么STL算法比手写循环更受推荐？</strong></p>
<ul>
<li><strong>性能优化</strong>：STL算法经过严格优化，能够比手写循环提供更好的性能。</li>
<li><strong>可读性和维护性</strong>：使用STL算法可以使代码更加清晰和易于维护。</li>
<li><strong>减少错误</strong>：STL算法减少了编程中常见的错误，如边界错误和指针错误。</li>
</ul>
<p><strong>2. STL算法中的_if后缀和_n后缀分别表示什么意思？</strong></p>
<ul>
<li>**_if后缀**：表示算法版本接受一个谓词（条件函数），用于指定操作的条件。</li>
<li>**_n后缀**：指算法接受一个额外的数量参数，用于指定操作的元素数量或范围。</li>
</ul>
<p><strong>3. STL迭代器有哪五种类别？</strong></p>
<ul>
<li><strong>输入迭代器</strong>：仅支持读取序列中的元素。</li>
<li><strong>输出迭代器</strong>：仅支持写入序列中的元素。</li>
<li><strong>前向迭代器</strong>：支持读写操作，并能多次遍历序列。</li>
<li><strong>双向迭代器</strong>：除了前向迭代器的功能外，还可以向后遍历。</li>
<li><strong>随机访问迭代器</strong>：支持直接访问任何元素，提供最灵活的访问方式。</li>
</ul>
<p><strong>4.
输入迭代器是否可以在需要前向迭代器的场合使用？反之亦然可以吗？</strong></p>
<ul>
<li><strong>输入迭代器用于前向迭代器</strong>：通常不可以，因为输入迭代器不支持多次遍历或双向移动。</li>
<li><strong>前向迭代器用于输入迭代器</strong>：可以，前向迭代器功能更全。</li>
</ul>
<p><strong>5.
为什么我们需要back_insert_iterator这类迭代器适配器？</strong></p>
<p>如果没有这些迭代器适配器，许多STL算法在处理需要动态添加元素到容器的情况时将无法工作，例如在使用<code>copy</code>算法时直接将元素添加到容器尾部。</p>
<p><strong>6.
如何修改代码以计算文件中25到75之间的值的平均数？</strong></p>
<p>首先使用<code>std::find_if</code>定位值在25到75之间的范围的迭代器，然后使用<code>std::accumulate</code>和<code>std::distance</code>计算这个范围的平均值。如果范围内没有元素，输出相应的消息。</p>
<p><strong>7.编写一个名为 <code>RemoveShortWords</code>
的函数，它接受一个 <code>vector&lt;string&gt;</code>
并移除其中所有长度为3或更短的字符串。</strong></p>
<p>（如果你正确地利用了算法，这个函数可以在两行代码内完成。）</p>
<p>这个问题可以通过结合使用 STL 的 <code>std::remove_if</code> 和
<code>erase</code> 方法解决。这里使用 <code>std::remove_if</code>
来标记所有应当被移除的元素，然后用 <code>erase</code>
实际移除这些元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RemoveShortWords</span><span class="params">(std::vector&lt;std::string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> newEnd = std::<span class="built_in">remove_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">                                 [](<span class="type">const</span> std::string&amp; s) &#123; <span class="keyword">return</span> s.<span class="built_in">length</span>() &lt;= <span class="number">3</span>; &#125;);</span><br><span class="line">    words.<span class="built_in">erase</span>(newEnd, words.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注释</strong>: - <code>remove_if</code> 将遍历
<code>words</code> 向量，并应用 lambda 函数到每个字符串。 - Lambda
函数检查字符串长度是否小于等于3，返回 <code>true</code>
表示该字符串应被移除。 - <code>remove_if</code>
将不应被移除的字符串移动到向量的前部，并返回一个新的结束迭代器。 -
<code>erase</code>
使用这个新的结束迭代器，将所有被标记为移除的字符串从向量中删除。</p>
<p><strong>8.计算 n 维空间中点到原点的距离</strong></p>
<p><strong>问题</strong>: 在 n 维空间中，一个点 (x1, x2, x3, ..., xn)
到原点的距离是 sqrt(x1^2 + x2^2 + x3^2 + ... + xn^2)。编写一个函数
<code>DistanceToOrigin</code>，它接受一个代表空间中点的
<code>vector&lt;double&gt;</code>，并返回该点到原点的距离。不要使用任何循环，让算法为你完成繁重的工作。（提示：使用
<code>inner_product</code> 算法来计算平方根下的表达式。）</p>
<p>我们可以使用 <code>std::inner_product</code>
算法来计算向量元素的平方和，然后取平方根得到欧几里得距离。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">// For std::inner_product</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">DistanceToOrigin</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt;&amp; point)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">sqrt</span>(std::<span class="built_in">inner_product</span>(point.<span class="built_in">begin</span>(), point.<span class="built_in">end</span>(), point.<span class="built_in">begin</span>(), <span class="number">0.0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注释</strong>: - <code>std::inner_product</code>
计算两个序列的点积。这里我们使用同一个向量 <code>point</code>
两次，即计算每个维度的平方。 - 初始值 <code>0.0</code>
表示累加的起始值。 -
最终结果是所有维度平方和的平方根，即从原点到点的距离。</p>
<ol start="9" type="1">
<li><strong>实现一个具有偏好的排序函数 BiasedSort</strong></li>
</ol>
<p><strong>问题</strong>: 编写一个名为 <code>BiasedSort</code>
的函数，它接受一个引用类型的 <code>vector&lt;string&gt;</code>
并按字典顺序对其进行排序，但如果向量中包含字符串 “Me
First”，则该字符串始终位于排序列表的最前面。</p>
<p><strong>解决方案</strong>：</p>
<p>为了解决这个问题，我们可以首先检查是否存在 "Me First"
字符串，如果存在，则先将其移至向量的开始位置，然后对剩余的元素进行排序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BiasedSort</span><span class="params">(std::vector&lt;std::string&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="string">&quot;Me First&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::<span class="built_in">iter_swap</span>(vec.<span class="built_in">begin</span>(), it);</span><br><span class="line">        std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>() + <span class="number">1</span>, vec.<span class="built_in">end</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注释</strong>: - 使用 <code>std::find</code> 查找 "Me
First"，如果找到，则与第一个元素交换位置。 - 使用 <code>std::sort</code>
对除 "Me First" 外的所有元素进行排序。</p>
<ol start="10" type="1">
<li><strong>编写一个函数 CriticsPick</strong></li>
</ol>
<p><strong>问题</strong>: 编写一个函数
<code>CriticsPick</code>，该函数接受一个
<code>map&lt;string, double&gt;</code>，其中包含电影及其评分（0.0 到
10.0之间），并返回一个
<code>set&lt;string&gt;</code>，其中包含地图中评分最高的前十部电影的名称。如果
map 中的元素少于十个，则结果 set 应包含 map 中的每个字符串。</p>
<p><strong>解决方案</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::set&lt;std::string&gt; <span class="title">CriticsPick</span><span class="params">(<span class="type">const</span> std::map&lt;std::string, <span class="type">double</span>&gt;&amp; movies)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::pair&lt;std::string, <span class="type">double</span>&gt;&gt; <span class="built_in">sortedMovies</span>(movies.<span class="built_in">begin</span>(), movies.<span class="built_in">end</span>());</span><br><span class="line">    std::<span class="built_in">sort</span>(sortedMovies.<span class="built_in">begin</span>(), sortedMovies.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="keyword">auto</span>&amp; a, <span class="type">const</span> <span class="keyword">auto</span>&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.second &gt; b.second;  <span class="comment">// 降序排序</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    std::set&lt;std::string&gt; topMovies;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; std::<span class="built_in">min</span>(<span class="number">10</span>, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(sortedMovies.<span class="built_in">size</span>())); ++i) &#123;</span><br><span class="line">        topMovies.<span class="built_in">insert</span>(sortedMovies[i].first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> topMovies;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注释</strong>: - 将 map 转换为 vector，以便使用排序算法。 -
按评分降序排序电影。 -
选取排序后的前10部电影（或者小于10部，如果元素不足的话）。</p>
<ol start="11" type="1">
<li><strong>实现 count 算法</strong></li>
</ol>
<p><strong>问题</strong>: 为 <code>vector&lt;int&gt;</code> 实现 count
算法。你的函数应该有如下原型：<code>int count(vector&lt;int&gt;::iterator start, vector&lt;int&gt;::iterator stop, int element)</code>，并应该返回区间
[start, stop) 中等于 element 的元素数量。</p>
<p><strong>解决方案</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;::iterator start, std::vector&lt;<span class="type">int</span>&gt;::iterator stop, <span class="type">int</span> element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">count</span>(start, stop, element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注释</strong>: - 直接使用 STL 中的 <code>std::count</code>
函数，传递给定的迭代器和元素。</p>
<ol start="12" type="1">
<li><strong>使用 generate_n 和 rand
函数填充随机数向量，并计算平均值</strong></li>
</ol>
<p><strong>问题</strong>: 使用 <code>generate_n</code>
算法、<code>rand</code> 函数和 <code>back_insert_iterator</code>
来填充一个向量，指定数量的随机值。然后使用 <code>accumulate</code>
计算该范围的平均值。</p>
<p><strong>解决方案</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span>  <span class="comment">// For rand()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PopulateAndAverage</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line">    std::<span class="built_in">generate_n</span>(std::<span class="built_in">back_inserter</span>(numbers), count, []() &#123; <span class="keyword">return</span> <span class="built_in">rand</span>() % <span class="number">100</span>; &#125;);</span><br><span class="line">    <span class="type">double</span> average = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(std::<span class="built_in">accumulate</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">0</span>)) / numbers.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Average: &quot;</span> &lt;&lt; average &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注释</strong>: - 使用 <code>generate_n</code> 和
<code>back_inserter</code> 向量填充随机数。<code>back_inserter</code>
创建一个后插迭代器，自动处理向量的大小调整。 - 随机数范围设置为 0 到
99。 - 使用 <code>accumulate</code>
计算总和，然后除以元素数量得到平均值。</p>
<ol start="13" type="1">
<li><strong>计算一组数据的中位数</strong></li>
</ol>
<p><strong>问题</strong>:
中位数是指在一组数据中，有一半的数据比它大，另一半数据比它小。对于拥有奇数个元素的数据集，这是排序后的中间元素；对于偶数个元素的数据集，它是两个中间元素的平均值。使用
<code>nth_element</code> 算法编写一个计算数据集中位数的函数。</p>
<p><strong>解决方案</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Median</span><span class="params">(std::vector&lt;<span class="type">double</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> n = data.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line">    std::<span class="built_in">nth_element</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">begin</span>() + n, data.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> data[n];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> max_it = std::<span class="built_in">max_element</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">begin</span>() + n);</span><br><span class="line">        <span class="keyword">return</span> (*max_it + data[n]) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注释</strong>: - 使用 <code>nth_element</code>
定位中间元素，该算法可以更快地找到第 n 个位置的元素，而不需要完全排序。
-
对于偶数元素的数据集，找到前半部分的最大值，与中间位置的下一个元素求平均。</p>
<ol start="14" type="1">
<li><strong>使用 copy、istreambuf_iterator 和 ostreambuf_iterator
打开文件并打印其内容</strong></li>
</ol>
<p><strong>问题</strong>: 展示如何使用
<code>copy</code>、<code>istreambuf_iterator</code> 和
<code>ostreambuf_iterator</code> 打开一个文件并将其内容打印到 cout。</p>
<p><strong>解决方案</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintFileContents</span><span class="params">(<span class="type">const</span> std::string&amp; filename)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(filename)</span></span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(std::<span class="built_in">istreambuf_iterator</span>&lt;<span class="type">char</span>&gt;(file),</span><br><span class="line">              std::<span class="built_in">istreambuf_iterator</span>&lt;<span class="type">char</span>&gt;(),</span><br><span class="line">              std::<span class="built_in">ostreambuf_iterator</span>&lt;<span class="type">char</span>&gt;(std::cout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注释</strong>: - 使用 <code>istreambuf_iterator</code>
从文件读取字符。 - 使用 <code>ostreambuf_iterator</code>
将字符输出到标准输出。 - <code>copy</code>
算法在这两个迭代器之间传输内容，直接从文件流复制到输出流，无需额外缓存。</p>
<ol start="15" type="1">
<li><strong>使用 copy 和迭代器适配器将 STL
容器的内容写入文件</strong></li>
</ol>
<p><strong>问题</strong>: 展示如何使用 <code>copy</code>
和迭代器适配器将 STL
容器的内容写入文件，其中每个元素存储在自己的一行上。</p>
<p><strong>解决方案</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteToFile</span><span class="params">(<span class="type">const</span> std::vector&lt;T&gt;&amp; data, <span class="type">const</span> std::string&amp; filename)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ofstream <span class="title">file</span><span class="params">(filename)</span></span>;</span><br><span class="line">    <span class="function">std::ostream_iterator&lt;T&gt; <span class="title">out_it</span><span class="params">(file, <span class="string">&quot;\n&quot;</span>)</span></span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), out_it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注释</strong>: - 使用 <code>ostream_iterator</code>
定义输出到文件的迭代器，并设置每个元素后跟一个换行符。 -
<code>copy</code>
算法用于从容器复制元素到文件流，每写入一个元素后自动插入一个换行符。</p>
<ol start="16" type="1">
<li><strong>打印两个已排序向量的共同元素</strong></li>
</ol>
<p><strong>问题</strong>: 假设你有两个元素已经存储在排序顺序中的
<code>vector&lt;int&gt;</code>。展示如何使用一行代码通过
<code>set_intersection</code>
算法和适当的迭代器适配器打印出这两个向量的共有元素。</p>
<p><strong>解决方案</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintCommonElements</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; v1, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; v2)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">set_intersection</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(),</span><br><span class="line">                          std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注释</strong>: - 使用 <code>set_intersection</code>
算法找出两个排序向量的共同元素。 - <code>ostream_iterator</code>
用于将找到的共同元素直接打印到标准输出，每个元素后面跟一个空格。</p>
<p>这些示例展示了如何有效地利用 STL
算法和迭代器来简化常见的编程任务，同时保持代码的简洁和高效。通过这种方式，可以显著提升代码的可读性和维护性，同时利用现代
C++ 提供的强大功能来处理复杂的数据结构和算法操作。</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/C/" rel="tag"># C++</a>
              <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag"># 学习笔记</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/04/25/XYCTF%20WP/" rel="prev" title="XYCTF_WP">
      <i class="fa fa-chevron-left"></i> XYCTF_WP
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/05/07/2024-5-7-%E6%8A%BD%E8%B1%A1%E5%85%A5%E9%97%A8/" rel="next" title="抽象记忆点">
      抽象记忆点 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9E%E6%96%87"><span class="nav-number">1.</span> <span class="nav-text">回文</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%A4%E6%96%AD%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.</span> <span class="nav-text">判断实现</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#remove%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.</span> <span class="nav-text">remove的使用介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0"><span class="nav-number">4.</span> <span class="nav-text">练习</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="AAAFORGE"
      src="/images/1312386.jpeg">
  <p class="site-author-name" itemprop="name">AAAFORGE</p>
  <div class="site-description" itemprop="description">此情可待成追忆，只是当时已惘然</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">12</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AAAFORGE</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">本博客全站共45.5k字</span>
</div>
        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'neutral',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
