<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-mac-osx.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"afogsheep.github.io","root":"/","scheme":"Pisces","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="C++预备 一个半循环 思考以下的循环方式和 while(! input.fail()) 的区别： 1234567891011int rowNumber &#x3D; 0;        while(true) &#123;            int intValue;            double doubleValue;            input &gt;&gt; intValue &amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="杜鹃声">
<meta property="og:url" content="https://afogsheep.github.io/2024/04/10/C++%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="杜鹃声">
<meta property="og:description" content="C++预备 一个半循环 思考以下的循环方式和 while(! input.fail()) 的区别： 1234567891011int rowNumber &#x3D; 0;        while(true) &#123;            int intValue;            double doubleValue;            input &gt;&gt; intValue &amp;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="c:\Users\24208\AppData\Roaming\Typora\typora-user-images\image-20240320165928508.png">
<meta property="og:image" content="g:\Cpp_Learn\assets\image-20240408110931050.png">
<meta property="og:image" content="g:\Cpp_Learn\assets\image-20240408111044967.png">
<meta property="og:image" content="g:\Cpp_Learn\assets\image-20240408111222882.png">
<meta property="article:published_time" content="2024-04-10T10:48:33.968Z">
<meta property="article:modified_time" content="2024-04-10T10:48:03.144Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="c:\Users\24208\AppData\Roaming\Typora\typora-user-images\image-20240320165928508.png">

<link rel="canonical" href="https://afogsheep.github.io/2024/04/10/C++%E5%AD%A6%E4%B9%A0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title> | 杜鹃声</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">杜鹃声</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">此情可待成追忆，只是当时已惘然</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://afogsheep.github.io/2024/04/10/C++%E5%AD%A6%E4%B9%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="We losers do nothing so winners keeping winning <br> </br> 仍在施工中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杜鹃声">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-10 18:48:33 / 修改时间：18:48:03" itemprop="dateCreated datePublished" datetime="2024-04-10T18:48:33+08:00">2024-04-10</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="C-预备"><a href="#C-预备" class="headerlink" title="C++预备"></a>C++预备</h1><h2 id="一个半循环"><a href="#一个半循环" class="headerlink" title=" 一个半循环 "></a><span style="font-size:1.2em;"> <strong>一个半循环</strong> </span></h2><p>思考以下的循环方式和 <strong>while(! input.fail())</strong> 的区别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rowNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> intValue;</span><br><span class="line">            <span class="type">double</span> doubleValue;</span><br><span class="line">            input &gt;&gt; intValue &gt;&gt; doubleValue;</span><br><span class="line">            <span class="keyword">if</span>(input.<span class="built_in">fail</span>()) <span class="keyword">break</span>;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(COLUMN_WIDTH) &lt;&lt; (rowNumber + <span class="number">1</span>) &lt;&lt; <span class="string">&quot; | &quot;</span>;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(COLUMN_WIDTH) &lt;&lt; intValue &lt;&lt; <span class="string">&quot; | &quot;</span>;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(COLUMN_WIDTH) &lt;&lt; doubleValue &lt;&lt; endl;</span><br><span class="line"> rowNumber++;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这种循环优点在于错误发生时能及时停止循环，若是后者，则总是会多执行一次循环。使用一个半循环而不是简单的 while 循环是有益的。</p>
<p>事实上，以上的代码可以简化成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int intValue;</span><br><span class="line">   double doubleValue;</span><br><span class="line">   while(input &gt;&gt; intValue &gt;&gt; doubleValue) &#123;</span><br><span class="line">       /* ... process values here ... */</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>直接将操作符运算放进 while 循环的判定条件中，能有效的减少代码的冗余。</p>
<h2 id="c-程序是如何运行的？"><a href="#c-程序是如何运行的？" class="headerlink" title=" c++程序是如何运行的？ "></a><span style="font-size:1.2em;"> <strong>c++程序是如何运行的？</strong> </span></h2><p>c++程序的运行分为三个部分：</p>
<p>​	<span style="font-size:1.1em;"> 预处理（preprocessing）  编译(compile)  连接(link)</span></p>
<ul>
<li>预处理：在预处理步骤中，称为预处理器的特殊程序会扫描 C++ 源代码并对其应用各种转换。例如，解析 #include 指令以使各种库可用，特殊标记（如 __FILE_ _和 _ _LINE__将替换为源文件中的文件和行号，#define-d 常量和宏替换为其适当的值</li>
<li>编译：在编译步骤中，编译器将 C++源文件读入、优化并转换为目标文件。这些目标文件是特定于机器的，但通常包含执行 C++ 文件中指定的指令的机器代码，以及一些额外的信息。在这个阶段，编译器将报告犯的任何语法错误，例如省略分号、引用未定义的变量或将错误类型的参数传递到函数中</li>
<li>连接：最后，在链接阶段，一个名为链接器的程序将构建最终可执行文件所需的所有目标文件收集在一起，将它们与特定于操作系统的信息捆绑在一起，最后生成一个多文件程序、抽象和可以运行和分发的预处理器可执行文件。在此阶段，链接器可能会报告一些最终错误，这些错误会阻止它生成有效的 C++ 程序。</li>
</ul>
<h2 id="包含保护（include-guard）"><a href="#包含保护（include-guard）" class="headerlink" title=" 包含保护（include guard）"></a><strong><span style="font-size:1.2em;"> 包含保护（include guard）</span></strong></h2><p>运用以下代码来防止头文件被重复利用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef file_Included</span><br><span class="line">#define file_Included</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>头文件的后缀是 <strong>.h</strong></p>
<h2 id="define-是什么？"><a href="#define-是什么？" class="headerlink" title="#define 是什么？"></a><strong><span style="font-size:1.2em;">#define 是什么？</span></strong></h2><p>运用以下格式，在整个代码中完成替换</p>
<p> <span style="font-style:italic;">#define phrase replacement </span></p>
<p>注意，被替换的判断是从第一个空格开始，#define 指令的替换部分由换行符前面的短语后的所有文本组成。同时默认替换后的文本将会是字符串。这个过程是在编译过程中进行的。如果全局定义了一个函数，那么在调用时会将其先转化成 c++代码。</p>
<h2 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title=" inline, 内联函数 "></a><span style="font-size:1.2em;"> <strong>inline, 内联函数</strong> </span></h2><p>在计算机科学术语中，宏是内联的，因为编译器将“函数”的内容放在调用站点，而不是插入到函数代码的间接跳转。内联函数可能比非内联函数效率高得多.对一个函数使用 inline 关键字会建议编译器自动内联该函数，提高运行效率。inline 关键字只是对编译器的建议，如果编译器认为内联函数太难或成本太高，则可以忽略该关键字。但是，在编写短函数时，有时有助于将函数标记为内联以提高性能。</p>
<p>如以下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> one, <span class="type">int</span> two)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> one &gt; two ? one : two;</span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure>



<h2 id="向量小结"><a href="#向量小结" class="headerlink" title=" 向量小结 "></a><span style="font-size:1.2em;"> <strong>向量小结</strong> </span></h2><p>向量，作为一个允许我们使用单个变量存储元素序列的多功能工具，有着难以取代的非凡地位。向量可以储存所有类型的数据(不可以混储)，没有元素数量限制，增减元素都十分方便。仅仅需要在头文件中引入 <span style="color:#0000FF;"> include&lt;vector&gt; </span>。比如完成一个简单的从大到小排序的程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetInteger</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> myInt;</span><br><span class="line">    cin &gt;&gt; myInt;</span><br><span class="line">    <span class="keyword">return</span> myInt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">GetSmallestIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v,<span class="type">size_t</span> startIndex)</span></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> bestIndex = startIndex; <span class="comment">//size_t类型表示C中任何对象所能达到的最大长度，它是无符号整数。这里使用是因为index肯定是大于零的数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = startIndex; i &lt; v.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i] &lt; v[bestIndex])</span><br><span class="line">            bestIndex = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bestIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;  </span><br><span class="line">        <span class="type">size_t</span> smallestIndex = <span class="built_in">GetSmallestIndex</span>(v, i); </span><br><span class="line">        <span class="built_in">swap</span> (v[i], v[smallestIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; values; <span class="comment">//创建一个空向量</span></span><br><span class="line">    <span class="type">int</span> kNumValues = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span> ;i &lt; kNumValues; ++i)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;enter another value &quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span> val =<span class="built_in">GetInteger</span>();</span><br><span class="line">        values.<span class="built_in">push_back</span>(val);  <span class="comment">//给向量赋值</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SelectionSort</span>(values);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i&lt;values.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        cout &lt;&lt; values[i]&lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也能通过以下格式初始化向量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">myReals</span><span class="params">(<span class="number">20</span>, <span class="number">137.0</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">myStrings</span><span class="params">(<span class="number">5</span>, <span class="string">&quot;(none)&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>规定向量的元素上限以及填充内容。之后如果要改变向量元素上限可以使用&#96;.resize() 以下是示例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; myVector;			<span class="comment">// Defaults to empty vector</span></span><br><span class="line"><span class="built_in">PrintVector</span>(myVector);			<span class="comment">// Output: [nothing]</span></span><br><span class="line"></span><br><span class="line">myVector.<span class="built_in">resize</span>(<span class="number">10</span>);			<span class="comment">// Grow the vector, setting new elements to 0</span></span><br><span class="line"><span class="built_in">PrintVector</span>(myVector);			<span class="comment">// Output: 0 0 0 0 0 0 0 0 0 0</span></span><br><span class="line"></span><br><span class="line">myVector.<span class="built_in">resize</span>(<span class="number">5</span>);				<span class="comment">// Shrink the vector</span></span><br><span class="line"><span class="built_in">PrintVector</span>(myVector);			<span class="comment">// Output: 0 0 0 0 0</span></span><br><span class="line"></span><br><span class="line">myVector.<span class="built_in">resize</span>(<span class="number">7</span>, <span class="number">1</span>);			<span class="comment">// Grow the vector, setting new elements to 1</span></span><br><span class="line"><span class="built_in">PrintVector</span>(myVector);			<span class="comment">// Output: 0 0 0 0 0 1 1</span></span><br><span class="line"></span><br><span class="line">myVector.<span class="built_in">resize</span>(<span class="number">1</span>, <span class="number">7</span>);			<span class="comment">// The second parameter is effectively ignored.</span></span><br><span class="line"><span class="built_in">PrintVector</span>(myVector);			<span class="comment">// Output: 0</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><span style="font-size:1.2em;"> <strong>部分常见的向量操作</strong> </span></p>
<table>
<thead>
<tr>
<th>Constructor: vector ()</th>
<th>vector myVector; Constructs an empty vector</th>
</tr>
</thead>
<tbody><tr>
<td>Constructor: vector (size_type size)</td>
<td>vector myVector(10);                            Constructs a vector of the specified size where all elements  use their default values (for integral types, this is zero).</td>
</tr>
<tr>
<td>Constructor: vector (size_type size,                       const T&amp; default)</td>
<td>vector myVector(5, “blank”);                   Constructs a vector of the specified size where each  element is equal to the specified default value.</td>
</tr>
<tr>
<td>size_type size() const;</td>
<td>for(int i &#x3D; 0; i &lt; myVector.size(); ++i) { … } Returns the number of elements in the vector</td>
</tr>
<tr>
<td>bool empty() const;</td>
<td>while(! myVector.empty()) { … } Returns whether the vector is empty.</td>
</tr>
<tr>
<td>void clear();</td>
<td>myVector.clear(); <br /> Erases all the elements in the vector and sets the size to  zero.</td>
</tr>
<tr>
<td>T&amp; operator [] (size_type position); <br /> const T&amp; operator [] (size_type position) const;    <br /> T&amp; at(size_type position); const T&amp; at(size_type position) const;</td>
<td>myVector [0] &#x3D; 100; int x &#x3D; myVector [0]; myVector.at(0) &#x3D; 100; int x &#x3D; myVector.at(0); Returns a reference to the element at the specified position.  The bracket notation [] does not do any bounds checking  and has undefined behavior past the end of the data.  The at  member function will throw an exception if you try to  access data beyond the end.  We will cover exception  handling in a later chapter</td>
</tr>
<tr>
<td>void resize(size_type newSize); void resize(size_type newSize, T fill);</td>
<td>myVector.resize(10); myVector.resize(10, “default”); Resizes the vector so that it’s guaranteed to be the specified  size.  In the second version, the vector elements are  initialized to the value specified by the second parameter.  Elements are added to and removed from the end of the  vector, so you can’t use resize to add elements to or remove  elements from the start of the vector</td>
</tr>
<tr>
<td>void push_back();</td>
<td>myVector.push_back(100); Appends an element to the vector</td>
</tr>
<tr>
<td>T&amp; back(); const T&amp; back() const;</td>
<td>myVector.back() &#x3D; 5; int lastElem &#x3D; myVector.back(); Returns a reference to the last element in the vector.</td>
</tr>
</tbody></table>
<p>续表：</p>
<table>
<thead>
<tr>
<th>T&amp; front(); const T&amp; front() const;</th>
<th>myVector.front() &#x3D; 0; int firstElem &#x3D; myVector.front(); Returns a reference to the first element in the vector.</th>
</tr>
</thead>
<tbody><tr>
<td>void pop_back();</td>
<td>myVector.pop_back(); <br /> Removes the last element from the vector.</td>
</tr>
<tr>
<td>iterator begin(); const_iterator begin() const;</td>
<td>vector:: iterator itr &#x3D; myVector.begin(); <br /> Returns an iterator that points to the first element in the  vector</td>
</tr>
<tr>
<td>iterator end(); const_iterator end() const;</td>
<td>while(itr !&#x3D; myVector.end()); <br /> Returns an iterator to the element after the last.  The  iterator returned by end does not point to an element in the  vector.</td>
</tr>
<tr>
<td>iterator insert(iterator position,                 const T&amp; value); void insert(iterator start,             size_type numCopies,             const T&amp; value);</td>
<td>myVector.insert(myVector.begin() + 4, “Hello”); myVector.insert(myVector.begin(), 2, “Yo!”); <br /> The first version inserts the specified value into the vector,  and the second inserts numCopies copies of the value into  the vector.  Both calls invalidate all outstanding iterators for  the vector.</td>
</tr>
<tr>
<td>iterator erase(iterator position); iterator erase(iterator start,               iterator end);</td>
<td>myVector.erase(myVector.begin()); <br /> myVector.erase(startItr, endItr); <br /> The first version erases the element at the position pointed  to by position.  The second version erases all elements in the  range [startItr, endItr).  Note that this does not erase  the element pointed to by endItr.  All iterators after the  remove point are invalidated.  If using this member  function on a deque (see below), all iterators are  invalidated.</td>
</tr>
</tbody></table>
<h2 id="Deque"><a href="#Deque" class="headerlink" title=" Deque "></a><span style="font-size:1.2em;"> <strong>Deque</strong> </span></h2><p>称作 double_end_queue。也就是双端队列和 vector 相较有许多类似的操作，比如 resize，push.back 等。但是与 vector 最大的不同是，在 STL 实现的储存空间是不连续的大片“page”，而 vector 的是连续的空间.</p>
<p><img src="C:\Users\24208\AppData\Roaming\Typora\typora-user-images\image-20240320165928508.png" alt="image-20240320165928508"></p>
<p>优点：(1) 随机访问方便，即支持 [ ] 操作符和 vector.at()<br>      (2) 在内部方便的进行插入和删除操作<br>      (3) 可在两端进行 push、pop</p>
<p>缺点：占用内存多</p>
<h1 id="四个新的容器类"><a href="#四个新的容器类" class="headerlink" title="四个新的容器类"></a>四个新的容器类</h1><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>设想一个程序，它能计算出连续扔骰子，直到扔出的点数与第一次相同时所需的次数，以下是采用向量的实现方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//摇骰子</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DieRoll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">rand</span>() %<span class="number">6</span>) +<span class="number">1</span>; <span class="comment">//确保返回是一到六的整数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RunProcess</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; generate;  <span class="comment">//储存重复前摇出的数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> NextVaule = <span class="built_in">DieRoll</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> k =<span class="number">0</span> ; k &lt; generate.<span class="built_in">size</span>(); ++k)&#123;</span><br><span class="line">            <span class="keyword">if</span> (generate[k] == NextVaule)&#123; <span class="comment">//满足说明已经重复了</span></span><br><span class="line">                <span class="keyword">return</span> generate.<span class="built_in">size</span>() + <span class="number">1</span>; <span class="comment">//加一是为了返还摇动的总次数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    generate.<span class="built_in">push_back</span>(NextVaule);    <span class="comment">//不是就把数字保存进去</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> kNumIterations = <span class="number">10000</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span>&gt;(<span class="built_in">time</span>(<span class="literal">NULL</span>)));</span><br><span class="line">    <span class="type">float</span> total2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span> ; i&lt; kNumIterations ; ++i)&#123;</span><br><span class="line">        <span class="type">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> k = <span class="number">0</span>; k&lt; kNumIterations ;++k)&#123;</span><br><span class="line">            total += <span class="built_in">RunProcess</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    total2 += <span class="built_in">float</span>(total) / kNumIterations;</span><br><span class="line">    </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ultimate unswer is &quot;</span> &lt;&lt; total2 / kNumIterations &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们扔常见的六面骰子时，结果似乎很合理：</p>
<p><img src="G:\Cpp_Learn\assets\image-20240408110931050.png" alt="image-20240408110931050"></p>
<p>当重复次数增加这个数字的精度也会变大。但是如果我们扔的是个八面骰子呢？</p>
<p><img src="G:\Cpp_Learn\assets\image-20240408111044967.png" alt="image-20240408111044967"></p>
<p>到重复时所需要的数字并没增大许多。那要是我们正在玩博德之门3，需要连续过两个高难检定呢？</p>
<p><img src="G:\Cpp_Learn\assets\image-20240408111222882.png" alt="image-20240408111222882"></p>
<p>仅仅需要大概6次就可以重复？？虽然这是个概率论问题，但我们可以注意到我们所使用的容器——向量。答案在于 RunProcess 函数的实现。此函数的核心是一个 for 循环，用于检查向量中是否包含特定值。直观地说，向量保持元素的有序序列。对向量的主要操作通过在该序列中添加和删除元素、查找该序列中特定位置的元素等来维护该序列。对于此应用程序，我们希望存储一个无序的数字集合。我们不关心元素何时被添加到向量中或它们占据什么位置。相反，我们感兴趣的是向量中有哪些元素，特别是给定的元素是否在向量中。</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>当元素集合的内容比元素所在的容器内的实际序列更重要时，便可以采用set容器。跟向量相比，set提供了一个任意的，无序的特殊容器，并且对以下的操作有很好的支持：</p>
<ul>
<li><p>将元素添加到集合中</p>
</li>
<li><p>从集合中删去元素</p>
</li>
<li><p>确认集合中是否包含特定元素</p>
<p>回到引子中那个问题，尝试用set来替换使用过向量的部分：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">RunProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       set&lt;<span class="type">int</span>&gt; generated;</span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="type">int</span> nextValue = <span class="built_in">DieRoll</span>();</span><br><span class="line">           <span class="comment">/* Check if this value has been rolled before. */</span></span><br><span class="line">           <span class="keyword">if</span> (generated.<span class="built_in">count</span>(nextValue)) <span class="keyword">return</span> generated.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">           <span class="comment">/* Otherwise, add this value to the set. */</span></span><br><span class="line">generated.<span class="built_in">insert</span>(nextValue);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>运行后的结果还是大差不差。</p>
<h2 id="set的基本操作"><a href="#set的基本操作" class="headerlink" title="set的基本操作"></a>set的基本操作</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容器之间的操作大多具有相似性</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; myset;</span><br><span class="line">    <span class="comment">//插入元素</span></span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="number">124</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="number">125</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="number">14</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="number">1324</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//检查元素是否在集合中</span></span><br><span class="line">    <span class="keyword">if</span>(myset.<span class="built_in">count</span>(<span class="number">1</span>))&#123;cout&lt;&lt; <span class="string">&quot;there is it&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="keyword">if</span>(!myset.<span class="built_in">count</span>(<span class="number">1000</span>))&#123;cout &lt;&lt; <span class="string">&quot;there is not it&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="comment">//删除集合中元素</span></span><br><span class="line">    myset.<span class="built_in">erase</span>(<span class="number">125</span>);</span><br><span class="line">    <span class="comment">//也可以使用clear来清除元素，size来查看容器大小，等等类似操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="迭代器初探"><a href="#迭代器初探" class="headerlink" title="迭代器初探"></a>迭代器初探</h2><h3 id="为什么要使用迭代器？"><a href="#为什么要使用迭代器？" class="headerlink" title="为什么要使用迭代器？"></a>为什么要使用迭代器？</h3><p>在最开始的C语言学习中，我们就已经习惯了用for循环来遍历数组的操作。这当然是一个很简洁方便的方法，但假如我们要遍历的容器不是数组呢？甚至这个容器不存在自带的顺序呢？（就如刚才提到的set），这时候再使用for循环就显得力不从心了。但是对于用迭代器来说刚好。如下所示：</p>
<h3 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">9</span>,<span class="number">564</span>,<span class="number">94</span>,<span class="number">71</span>,<span class="number">62</span>,<span class="number">6933</span>,<span class="number">122</span>,<span class="number">47</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator itr = myVector.<span class="built_in">begin</span>();</span><br><span class="line">    itr != myVector.<span class="built_in">end</span>();++itr)&#123;</span><br><span class="line">        cout &lt;&lt; *itr &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>到这里还有一个问题，就是当遇见无序容器时，迭代器遍历的顺序是如何的？当使用向量或 deque 时，有一个自然的迭代顺序（从序列的开始到结束），但是当使用 STL 集时，排序的概念有点模糊。但是，<strong>集合的迭代顺序是明确指定的。通过迭代器遍历集合元素时，将按排序顺序访问元素，从最小的元素开始，到最大的元素结束</strong>。这在一定程度上解释了为什么 STL 集合只能存储使用 less-than 运算符可比较的元素：如果无法比较元素，则集合中没有明确定义的“最小”或“最大”元素。若要查看其实际操作，请考虑以下代码片段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 生成随机数 */</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt; randomNumbers;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++k)</span><br><span class="line">        randomNumbers.<span class="built_in">insert</span>(<span class="built_in">rand</span>());</span><br><span class="line">    <span class="comment">/* 顺序打印集合内容 */</span></span><br><span class="line">    <span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator itr = randomNumbers.<span class="built_in">begin</span>(); </span><br><span class="line">         itr != randomNumbers.<span class="built_in">end</span>(); ++itr)</span><br><span class="line">        cout &lt;&lt; *itr &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>正如刚才所做到的，使用迭代器有三个主要操作：</p>
<ul>
<li><strong>取消迭代器的引用</strong></li>
<li><strong>将迭代器从一个位置推进到另外一个位置</strong></li>
<li><strong>比较两个迭代器是否相等</strong></li>
</ul>
<p>迭代器的功能当然不止读取内容，也能写入内容，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator ite = myVector.<span class="built_in">begin</span>();</span><br><span class="line">    ite != myVector.<span class="built_in">end</span>(); ++ite)</span><br><span class="line">    myVector.<span class="built_in">insert</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>由于迭代器提供了一种间接读取和写入容器元素的方法，因此可以通过操作容器类中的迭代器来编写对任何容器类中的数据进行操作的函数。这些函数称为 STL 算法。</p>
<p>现在让我们尝试一下用迭代器对字符串类型的容器进行操作。假设我们想要打印某个字符串向量的所有元素的长度，我们很可能会这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (set&lt;string&gt;::iterator itr = mySet.<span class="built_in">begin</span>(); itr != mySet.<span class="built_in">end</span>(); ++itr)</span><br><span class="line">        cout &lt;&lt; *itr.<span class="built_in">length</span>() &lt;&lt; endl; <span class="comment">// Error: Incorrect syntax!</span></span><br></pre></td></tr></table></figure>

<p>原因是编译器把我们的代码理解成了<code>\*(itr.length())</code>而不是<code>(*itr).length()</code>。</p>
<p>为了解决此问题，所有 STL 迭代器都支持并调用了箭头运算符，该运算符允许您在当前正在迭代的元素上调用成员函数。例如，要打印出集合中所有字符串的长度<string>，正确的语法是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (set&lt;string&gt;::iterator itr = mySet.<span class="built_in">begin</span>(); itr != mySet.<span class="built_in">end</span>(); ++itr)</span><br><span class="line">       cout &lt;&lt; itr-&gt;<span class="built_in">length</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h3 id="迭代的范围定义"><a href="#迭代的范围定义" class="headerlink" title="迭代的范围定义"></a>迭代的范围定义</h3><p>容易注意到我们之前的循环控制是靠 <code>mySet.begin()</code>与 <code>mySet.end()</code>。前者指定迭代范围开始的第一俄国元素，后者定义迭代范围末尾的元素。单个迭代器指向容器类中的单个位置，并表示间接读取或写入该值的方法。一对迭代器定义两个位置，从而定义一系列元素。具体而言，给定两个迭代器 start 和 stop，这些迭代器定义从 start 开始到停止前一个位置结束的元素范围。使用数学符号，由开始和停止跨度定义的元素范围 [start， stop)。</p>
<p>由于集合本身把元素按顺序排列的性质，我们可以如下尝试一下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt;::iterator stop = mySet.<span class="built_in">upper_bound</span>(<span class="number">100</span>);</span><br><span class="line">   <span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator itr = mySet.<span class="built_in">lower_bound</span>(<span class="number">10</span>); itr != stop; ++itr)</span><br><span class="line">       cout &lt;&lt; *itr &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p><strong>upper_bound</strong> 和 <strong>lower_bound</strong> 的美妙之处在于，指定为函数参数的元素是否实际存在于集合中并不重要(假如要求的元素不存在就会直接返还到开头或者末尾)。例如，假设我们在包含 3 到 137 之间的所有奇数的集合上运行上述 for 循环。在本例中，集合中既不包含 10 也不包含 100。但是，代码仍将正常工作。lower_bound 函数向第一个元素返回一个迭代器，其大小至少与其参数一样大，并且在奇数集中将向元素 11 返回一个迭代器。类似地，upper_bound 向第一个元素返回一个迭代器，严格大于其参数，因此将向元素 101 返回一个迭代器。</p>
<h2 id="集合的常用函数"><a href="#集合的常用函数" class="headerlink" title="集合的常用函数"></a>集合的常用函数</h2><table>
<thead>
<tr>
<th>Constructor: set<T>()</th>
<th>set<int> mySet; 构造一个空集合。</th>
</tr>
</thead>
<tbody><tr>
<td>Constructor: set<T>(const set<T>&amp; other)</td>
<td>set<int> myOtherSet &#x3D; mySet; 构造一个另一个集合的副本。</td>
</tr>
<tr>
<td>Constructor: set<T>(InputIterator start, InputIterator stop)</td>
<td>set<int> mySet(myVec.begin(), myVec.end()); 构造一个包含特定范围（[start, stop)）内元素的副本的集合。任何重复的元素都将被丢弃，并且元素将被排序。注意，这个函数接受来自任何来源的迭代器。</td>
</tr>
<tr>
<td>size_type size() const</td>
<td>int numEntries &#x3D; mySet.size(); 返回集合中包含的元素数量</td>
</tr>
<tr>
<td>bool empty() const</td>
<td>if(mySet.empty()) { … } 返回集合是否为空。</td>
</tr>
<tr>
<td>void clear()</td>
<td>mySet.clear(); 从集合中移除所有元素。</td>
</tr>
<tr>
<td>iterator begin() const_iterator begin() const</td>
<td>set<int>::iterator itr &#x3D; mySet.begin(); 返回一个迭代器指向集合的开始。在就地修改元素时要小心。</td>
</tr>
<tr>
<td>iterator end() const_iterator end() const</td>
<td>while(itr !&#x3D; mySet.end()) { … } 返还迭代器到最后一个元素后面</td>
</tr>
<tr>
<td>insert(const T&amp; value)</td>
<td>第一个版本将指定的值插入集合中。返回类型是一个包含指向元素的迭代器和一个bool值的对，bool值指示元素是否成功插入（真）或者是否已经存在（假）。</td>
</tr>
<tr>
<td>void insert(InputIterator begin, InputIterator end)</td>
<td>第二个版本将指定范围的元素插入集合中，忽略重复项。</td>
</tr>
<tr>
<td>const_iterator find(const T&amp; element) const</td>
<td>如果指定元素存在，则返回指向该元素的迭代器；否则，返回end。</td>
</tr>
<tr>
<td>size_type count(const T&amp; item) const</td>
<td>如果指定元素包含在集合中，则返回1；否则，返回0。</td>
</tr>
<tr>
<td>size_type erase(const T&amp; element) void erase(iterator itr); void erase(iterator start, iterator stop);</td>
<td>从集合中移除一个元素。在第一个版本中，如果找到指定元素，则将其移除，并且如果元素被移除则函数返回1，如果元素不在集合中则返回0。第二个版本移除itr指向的元素。最后一个版本擦除[start, stop)范围内的元素。</td>
</tr>
<tr>
<td>iterator lower_bound(const T&amp; value)</td>
<td>返回指向第一个大于或等于指定值的元素的迭代器。这个函数对于获取一系列元素的迭代器特别有用，尤其是与upper_bound一起使用时。</td>
</tr>
<tr>
<td>iterator upper_bound(const T&amp; value)</td>
<td>返回指向第一个大于指定值的元素的迭代器。因为这个元素必须严格大于指定值，你可以迭代一个范围，直到迭代器等于upper_bound，以获得所有小于或等于参数的元素。</td>
</tr>
</tbody></table>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/03/04/hello-world/" rel="prev" title="Hello_My_Blog">
      <i class="fa fa-chevron-left"></i> Hello_My_Blog
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#C-%E9%A2%84%E5%A4%87"><span class="nav-number">1.</span> <span class="nav-text">C++预备</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E4%B8%AA%E5%8D%8A%E5%BE%AA%E7%8E%AF"><span class="nav-number">1.1.</span> <span class="nav-text"> 一个半循环 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#c-%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E8%BF%90%E8%A1%8C%E7%9A%84%EF%BC%9F"><span class="nav-number">1.2.</span> <span class="nav-text"> c++程序是如何运行的？ </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8C%85%E5%90%AB%E4%BF%9D%E6%8A%A4%EF%BC%88include-guard%EF%BC%89"><span class="nav-number">1.3.</span> <span class="nav-text"> 包含保护（include guard）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#define-%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="nav-number">1.4.</span> <span class="nav-text">#define 是什么？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#inline-%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-number">1.5.</span> <span class="nav-text"> inline, 内联函数 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%90%91%E9%87%8F%E5%B0%8F%E7%BB%93"><span class="nav-number">1.6.</span> <span class="nav-text"> 向量小结 </span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Deque"><span class="nav-number">1.7.</span> <span class="nav-text"> Deque </span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%9B%9B%E4%B8%AA%E6%96%B0%E7%9A%84%E5%AE%B9%E5%99%A8%E7%B1%BB"><span class="nav-number">2.</span> <span class="nav-text">四个新的容器类</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E5%AD%90"><span class="nav-number">2.1.</span> <span class="nav-text">引子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set"><span class="nav-number">2.2.</span> <span class="nav-text">set</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="nav-number">2.3.</span> <span class="nav-text">set的基本操作</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%88%9D%E6%8E%A2"><span class="nav-number">2.4.</span> <span class="nav-text">迭代器初探</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%BF%AD%E4%BB%A3%E5%99%A8%EF%BC%9F"><span class="nav-number">2.4.1.</span> <span class="nav-text">为什么要使用迭代器？</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AE%9E%E9%99%85%E6%93%8D%E4%BD%9C"><span class="nav-number">2.4.2.</span> <span class="nav-text">实际操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%8F%E7%BB%93"><span class="nav-number">2.4.3.</span> <span class="nav-text">小结</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BF%AD%E4%BB%A3%E7%9A%84%E8%8C%83%E5%9B%B4%E5%AE%9A%E4%B9%89"><span class="nav-number">2.4.4.</span> <span class="nav-text">迭代的范围定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E7%9A%84%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-number">2.5.</span> <span class="nav-text">集合的常用函数</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">We losers do nothing so winners keeping winning <br> </br> 仍在施工中</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">2</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://pisces.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  















  

  

</body>
</html>
