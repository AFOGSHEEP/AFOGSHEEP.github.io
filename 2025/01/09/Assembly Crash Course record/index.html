<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/32x32-avatar.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/32x32-avatar.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"midnightr3d.top","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":"ture","sidebar":"ture","scrollpercent":"ture"},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="set-register 题目要求： In this level, you will be working with registers. You will be asked to modify or read from registers. In this level, you will work with registers! Please set the following:">
<meta property="og:type" content="article">
<meta property="og:title" content="Assembly Crash Course record">
<meta property="og:url" content="http://midnightr3d.top/2025/01/09/Assembly%20Crash%20Course%20record/index.html">
<meta property="og:site_name" content="杜鹃声">
<meta property="og:description" content="set-register 题目要求： In this level, you will be working with registers. You will be asked to modify or read from registers. In this level, you will work with registers! Please set the following:">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-01-09T08:16:48.000Z">
<meta property="article:modified_time" content="2025-01-15T16:33:25.366Z">
<meta property="article:author" content="AAAFORGE">
<meta property="article:tag" content="学习笔记">
<meta property="article:tag" content="网安">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://midnightr3d.top/2025/01/09/Assembly%20Crash%20Course%20record/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Assembly Crash Course record | 杜鹃声</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/rss2.xml" title="杜鹃声" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">杜鹃声</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">斜阳暮</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-sitemap">

    <a href="/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://midnightr3d.top/2025/01/09/Assembly%20Crash%20Course%20record/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/1312386.jpeg">
      <meta itemprop="name" content="AAAFORGE">
      <meta itemprop="description" content="此情可待成追忆，只是当时已惘然">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杜鹃声">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Assembly Crash Course record
        </h1>

        <div class="post-meta">
        
          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2025-01-09 16:16:48" itemprop="dateCreated datePublished" datetime="2025-01-09T16:16:48+08:00">2025-01-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-01-16 00:33:25" itemprop="dateModified" datetime="2025-01-16T00:33:25+08:00">2025-01-16</time>
              </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="set-register">set-register</h2>
<p>题目要求：</p>
<p>In this level, you will be working with registers. You will be asked
to modify or read from registers.</p>
<p>In this level, you will work with registers! Please set the
following: <span id="more"></span></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdi = 0x1337</span><br></pre></td></tr></table></figure>
<p>似乎很简单，要求我们将 rdi 的值设置成
<code>0x1337</code>，但是会得到</p>
<p>=="WARNING: It looks like your input might not be assembled binary
code, but assembly source code. This challenge needs the raw binary
assembled code as input."==</p>
<p>程序并不能理解我们输入的汇编代码，所以我们要使用 pwntools
的工具来构造机器码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p=process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line">p.recvline()<span class="comment">#这行代码从进程 p 中接收一行数据。它会读取数据直到遇到换行符##（\n），然后返回这一行的内容。默认情况下，recvline() 会保留行尾的换行符。在这里，它用于读取目标程序输出的第一行数据，可能是程序的提示信息或其他初始输出，以便知#道程序已经准备好接收后续的输入。</span></span><br><span class="line">p.send(asm(<span class="string">&#x27;mov rdi,0x1337&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(p.readallS())<span class="comment">#首先调用 p.readall() 函数，读取进程 p 的所有剩余输出直到进程结束。它会阻塞当前线程，直到目标进程关闭其输出流。并自动转换成字符串，之后用print()输出</span></span><br></pre></td></tr></table></figure>
<p>得到
<code>flag:pwn.college&#123;QRxMx73Zr7Op3kSe-GPyic6TjdY.0FN5EDL4EDOxYzW&#125;</code></p>
<h2 id="set-multiple-registers">set-multiple-registers</h2>
<p>In this level, you will be working with registers. You will be asked
to modify or read from registers.</p>
<p>In this level, you will work with multiple registers. Please set the
following:</p>
<ul>
<li><code>rax = 0x1337</code></li>
<li><code>r12 = 0xCAFED00D1337BEEF</code></li>
<li><code>rsp = 0x31337</code></li>
</ul>
<p>类似的题目，从设置一个寄存器变为了设置多个</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	mov rax ,0x1337</span></span><br><span class="line"><span class="string">	mov r12 ,0xCAFED00D1337BEEF</span></span><br><span class="line"><span class="string">	mov rsp ,0x31337</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(p.recvall())</span><br></pre></td></tr></table></figure>
<h2 id="add-to-register">add-to-register</h2>
<p>In this level, you will be working with registers. You will be asked
to modify or read from registers.</p>
<p>We will set some values in memory dynamically before each run. On
each run, the values will change. This means you will need to perform
some formulaic operation with registers. We will tell you which
registers are set beforehand and where you should put the result. In
most cases, it's <code>rax</code>.</p>
<p>Many instructions exist in x86 that allow you to perform all the
normal math operations on registers and memory.</p>
<p>For shorthand, when we say <code>A += B</code>, it really means
<code>A = A + B</code>.</p>
<p>Here are some useful instructions:</p>
<ul>
<li><code>add reg1, reg2</code> &lt;=&gt; <code>reg1 += reg2</code></li>
<li><code>sub reg1, reg2</code> &lt;=&gt; <code>reg1 -= reg2</code></li>
<li><code>imul reg1, reg2</code> &lt;=&gt;
<code>reg1 *= reg2</code></li>
</ul>
<p><code>div</code> is more complicated, and we will discuss it later.
Note: all <code>regX</code> can be replaced by a constant or memory
location.</p>
<p>Do the following:</p>
<ul>
<li>Add <code>0x331337</code> to <code>rdi</code></li>
</ul>
<p>要求对寄存器进行加法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    add rdi, 0x331337&#x27;&#x27;&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(p.recvallS())</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>得到
<code>flag:pwn.college&#123;oQeaHikpX98CEqAk6biPBYRAxUc.0VN5EDL4EDOxYzW&#125;</code></p>
<h2 id="linear-equation-registers">linear-equation-registers</h2>
<p>In this level, you will be working with registers. You will be asked
to modify or read from registers.</p>
<p>We will now set some values in memory dynamically before each run. On
each run, the values will change. This means you will need to do some
type of formulaic operation with registers. We will tell you which
registers are set beforehand and where you should put the result. In
most cases, it's <code>rax</code>.</p>
<p>Using your new knowledge, please compute the following:</p>
<ul>
<li>``` f(x) = mx + b <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  , where:</span><br><span class="line"></span><br><span class="line">  - `m = rdi`</span><br><span class="line">  - `x = rsi`</span><br><span class="line">  - `b = rdx`</span><br><span class="line"></span><br><span class="line">Place the result into `rax`.</span><br><span class="line"></span><br><span class="line">Note: There is an important difference between `mul` (unsigned multiply) and `imul` (signed multiply) in terms of which registers are used. Look at the documentation on these instructions to see the difference.</span><br><span class="line"></span><br><span class="line">In this case, you will want to use `imul`.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">练习一下乘法</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">from pwn import *</span><br><span class="line">context.arch = &#x27;amd64&#x27;</span><br><span class="line">p= process(&quot;/challenge/run&quot;)</span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(&#x27;&#x27;&#x27;</span><br><span class="line">	xor rax,rax		#初始化寄存器</span><br><span class="line">	imul rdi,rsi</span><br><span class="line">	mov rax,rdx</span><br><span class="line">	add rax,rdi</span><br><span class="line">&#x27;&#x27;&#x27;))</span><br><span class="line">print(p.recvall())</span><br></pre></td></tr></table></figure></li>
</ul>
<p>获取答案。后面还是不要直接写出 flag 了。</p>
<h2 id="integer-division">integer-division</h2>
<p>Division in x86 is more special than in normal math. Math here is
called integer math, meaning every value is a whole number.</p>
<p>As an example: <code>10 / 3 = 3</code> in integer math.</p>
<p>Why?</p>
<p>Because <code>3.33</code> is rounded down to an integer.</p>
<p>The relevant instructions for this level are:</p>
<ul>
<li><code>mov rax, reg1</code></li>
<li><code>div reg2</code></li>
</ul>
<p>Note: <code>div</code> is a special instruction that can divide a
128-bit dividend by a 64-bit divisor while storing both the quotient and
the remainder, using only one register as an operand.</p>
<p>How does this complex <code>div</code> instruction work and operate
on a 128-bit dividend (which is twice as large as a register)?</p>
<p>For the instruction <code>div reg</code>, the following happens:</p>
<ul>
<li><code>rax = rdx:rax / reg</code></li>
<li><code>rdx = remainder</code></li>
</ul>
<p><code>rdx:rax</code> means that <code>rdx</code> will be the upper
64-bits of the 128-bit dividend and <code>rax</code> will be the lower
64-bits of the 128-bit dividend.</p>
<p>You must be careful about what is in <code>rdx</code> and
<code>rax</code> before you call <code>div</code>.</p>
<p>Please compute the following:</p>
<ul>
<li>``` speed = distance / time <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  , where:</span><br><span class="line"></span><br><span class="line">  - `distance = rdi`</span><br><span class="line">  - `time = rsi`</span><br><span class="line">  - `speed = rax`</span><br><span class="line"></span><br><span class="line">Note that distance will be at most a 64-bit value, so `rdx` should be 0 when dividing.</span><br><span class="line"></span><br><span class="line">在 x86 汇编中，`div` 指令用于执行整数除法，它可以将一个 128 位的被除数除以一个 64 位的除数，并同时存储商和余数。这个指令的特殊之处在于它使用了两个寄存器来表示被除数：`rdx` 和 `rax`。其中，`rdx` 存储被除数的高 64 位，而 `rax` 存储被除数的低 64 位。</span><br><span class="line"></span><br><span class="line">在执行 `div reg` 指令时，以下操作会发生：</span><br><span class="line"></span><br><span class="line">1. `rax` 寄存器将被设置为 `rdx:rax`（即由 `rdx` 和 `rax` 组成的 128 位数）除以 `reg` 的商。</span><br><span class="line">2. `rdx` 寄存器将被设置为除法的余数。</span><br><span class="line"></span><br><span class="line">接下来就是练习除法</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">from pwn import *</span><br><span class="line">context.arch = &#x27;amd64&#x27;</span><br><span class="line">p= process(&quot;/challenge/run&quot;)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(asm(&#x27;&#x27;&#x27;</span><br><span class="line">    mov rax,rdi</span><br><span class="line">    xor rdx,rdx</span><br><span class="line">    div rsi</span><br><span class="line">&#x27;&#x27;&#x27;))</span><br><span class="line">print(p.recvall())</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="module-opretion">module-opretion</h2>
<p>Modulo in assembly is another interesting concept!</p>
<p>x86 allows you to get the remainder after a <code>div</code>
operation.</p>
<p>For instance: <code>10 / 3</code> results in a remainder of
<code>1</code>.</p>
<p>The remainder is the same as modulo, which is also called the "mod"
operator.</p>
<p>In most programming languages, we refer to mod with the symbol
<code>%</code>.</p>
<p>Please compute the following: <code>rdi % rsi</code></p>
<p>Place the value in <code>rax</code>.</p>
<p>关于模的运算。但是 x86 没有直接求模的运算。所以需要手动算一下。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p= process(<span class="string">&quot;/challenge/run&quot;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	xor rdx,rdx</span></span><br><span class="line"><span class="string">	mov rax,rdi</span></span><br><span class="line"><span class="string">	div rsi</span></span><br><span class="line"><span class="string">	xor rax,rax</span></span><br><span class="line"><span class="string">	mov rax,rdx</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(p.recvall())</span><br></pre></td></tr></table></figure>
<p>记得寄存器用前要清零，还有就是一般用 <code>rax</code>
作为函数返还数值的寄存器。</p>
<h2 id="set-upper-byte">set-upper-byte</h2>
<p>Another cool concept in x86 is the ability to independently access
the lower register bytes.</p>
<p>Each register in x86_64 is 64 bits in size, and in the previous
levels, we have accessed the full register using <code>rax</code>,
<code>rdi</code>, or <code>rsi</code>.</p>
<p>We can also access the lower bytes of each register using different
register names.</p>
<p>For example, the lower 32 bits of <code>rax</code> can be accessed
using <code>eax</code>, the lower 16 bits using <code>ax</code>, and the
lower 8 bits using <code>al</code>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MSB                                    LSB</span><br><span class="line">+----------------------------------------+</span><br><span class="line">|                   rax                  |</span><br><span class="line">+--------------------+-------------------+</span><br><span class="line">                     |        eax        |</span><br><span class="line">                     +---------+---------+</span><br><span class="line">                               |   ax    |</span><br><span class="line">                               +----+----+</span><br><span class="line">                               | ah | al |</span><br><span class="line">                               +----+----+</span><br></pre></td></tr></table></figure>
<p>Lower register bytes access is applicable to almost all
registers.</p>
<p>Using only one move instruction, please set the upper 8 bits of the
<code>ax</code> register to <code>0x42</code>.</p>
<p>介绍了 <code>x86</code>
架构中寄存器的特性——寄存器可以被划分为不同的部分，以便可以单独访问其部分位。这种设计允许程序员更灵活地处理数据，尤其是在需要对数据的特定部分进行操作时。</p>
<p>以 <code>rax</code> 寄存器为例，它是一个 64
位的寄存器，可以被分为不同的部分：</p>
<ul>
<li><code>rax</code>：整个 64 位寄存器。</li>
<li><code>eax</code>：<code>rax</code> 的低 32 位。</li>
<li><code>ax</code>：<code>eax</code> 的低 16 位。</li>
<li><code>al</code>：<code>ax</code> 的低 8 位。</li>
<li><code>ah</code>：<code>ax</code> 的高 8 位。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov ah,0x42</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(output)  </span><br></pre></td></tr></table></figure>
<p>补充:</p>
<p>MSB 和 LSB 是位的两种称呼：</p>
<ul>
<li><strong>MSB (Most Significant
Bit)</strong>：最高有效位。在二进制数中，MSB
是位于最左侧的位，具有最大的数值权重。例如，在一个 8 位的二进制数
<code>10110101</code> 中，最左边的 <code>1</code> 就是 MSB，它代表了
<code>2^7</code> 的权重。</li>
<li><strong>LSB (Least Significant
Bit)</strong>：最低有效位。在二进制数中，LSB
是位于最右侧的位，具有最小的数值权重。例如，在同一个 8 位的二进制数
<code>10110101</code> 中，最右边的 <code>1</code> 就是 LSB，它代表了
<code>2^0</code> 的权重。</li>
</ul>
<p>常用寄存器</p>
<table>
<colgroup>
<col style="width: 21%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 13%" />
<col style="width: 19%" />
<col style="width: 19%" />
</colgroup>
<thead>
<tr>
<th>x64 调用约定</th>
<th>64 位寄存器</th>
<th>32 位寄存器</th>
<th>16 位寄存器</th>
<th>8 位寄存器（低）</th>
<th>8 位寄存器（高）</th>
</tr>
</thead>
<tbody>
<tr>
<td>函数返回值</td>
<td>rax</td>
<td>eax</td>
<td>ax</td>
<td>al</td>
<td>al</td>
</tr>
<tr>
<td></td>
<td>rbx</td>
<td>ebx</td>
<td>bx</td>
<td>bl</td>
<td>bl</td>
</tr>
<tr>
<td>第四个参数</td>
<td>rcx</td>
<td>ecb</td>
<td>cx</td>
<td>cl</td>
<td>cl</td>
</tr>
<tr>
<td>第三个参数</td>
<td>rdx</td>
<td>edx</td>
<td>dx</td>
<td>dl</td>
<td>dl</td>
</tr>
<tr>
<td>第一个参数</td>
<td>rdi</td>
<td>edi</td>
<td>di</td>
<td>dil</td>
<td></td>
</tr>
<tr>
<td>第二个参数</td>
<td>rsi</td>
<td>esi</td>
<td>si</td>
<td>sil</td>
<td></td>
</tr>
<tr>
<td>下一条指令的地址</td>
<td>rip</td>
<td>eip</td>
<td>ip</td>
<td></td>
<td></td>
</tr>
<tr>
<td>栈底指针</td>
<td>rbp</td>
<td>ebp</td>
<td>bp</td>
<td>bpl</td>
<td></td>
</tr>
<tr>
<td>栈顶指针</td>
<td>rsp</td>
<td>esp</td>
<td>sp</td>
<td>spl</td>
<td></td>
</tr>
<tr>
<td>第五个参数</td>
<td>r8</td>
<td>r8d</td>
<td>r8w</td>
<td>r8b</td>
<td></td>
</tr>
<tr>
<td>第六个参数</td>
<td>r9</td>
<td>r9d</td>
<td>r9w</td>
<td>r9b</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="efficient-modulo">efficient-modulo</h2>
<p>It turns out that using the <code>div</code> operator to compute the
modulo operation is slow!</p>
<p>We can use a math trick to optimize the modulo operator
(<code>%</code>). Compilers use this trick a lot.</p>
<p>If we have <code>x % y</code>, and <code>y</code> is a power of 2,
such as <code>2^n</code>, the result will be the lower <code>n</code>
bits of <code>x</code>.</p>
<p>Therefore, we can use the lower register byte access to efficiently
implement modulo!</p>
<p>Using only the following instruction(s):</p>
<ul>
<li><code>mov</code></li>
</ul>
<p>Please compute the following:</p>
<ul>
<li><code>rax = rdi % 256</code></li>
<li><code>rbx = rsi % 65536</code></li>
</ul>
<p>如何使用寄存器的低位字节来高效地实现模运算？不难发现，当模数是 2
的幂时，例如 2^n，模数就是低 n
位，也就是说可以通过直接取寄存器的低位字节来得到模运算的结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov al, dil</span></span><br><span class="line"><span class="string">    mov bx, si</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br></pre></td></tr></table></figure>
<h2 id="byte-extraction">byte-extraction</h2>
<p>Shifting bits around in assembly is another interesting concept!</p>
<p>x86 allows you to 'shift' bits around in a register.</p>
<p>Take, for instance, <code>al</code>, the lowest 8 bits of
<code>rax</code>.</p>
<p>The value in <code>al</code> (in bits) is:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rax = 10001010</span><br></pre></td></tr></table></figure>
<p>If we shift once to the left using the <code>shl</code>
instruction:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shl al, 1</span><br></pre></td></tr></table></figure>
<p>The new value is:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">al = 00010100</span><br></pre></td></tr></table></figure>
<p>Everything shifted to the left, and the highest bit fell off while a
new 0 was added to the right side.</p>
<p>You can use this to do special things to the bits you care about.</p>
<p>Shifting has the nice side effect of doing quick multiplication (by
2) or division (by 2), and can also be used to compute modulo.</p>
<p>Here are the important instructions:</p>
<ul>
<li><code>shl reg1, reg2</code> &lt;=&gt; Shift <code>reg1</code> left
by the amount in <code>reg2</code></li>
<li><code>shr reg1, reg2</code> &lt;=&gt; Shift <code>reg1</code> right
by the amount in <code>reg2</code></li>
</ul>
<p>Note: 'reg2' can be replaced by a constant or memory location.</p>
<p>Using only the following instructions:</p>
<ul>
<li><code>mov</code>, <code>shr</code>, <code>shl</code></li>
</ul>
<p>Please perform the following: Set <code>rax</code> to the 5th least
significant byte of <code>rdi</code>.</p>
<p>For example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rdi = | B7 | B6 | B5 | B4 | B3 | B2 | B1 | B0 |</span><br><span class="line">Set rax to the value of B4</span><br></pre></td></tr></table></figure>
<p>移位时最高位遗弃，填充最低位置零。<code>shl rax, rbx</code> 意思是
rax 左移 rbx 的值，rbx 为 8 则左移 8 位。</p>
<p>当一个寄存器的高位都是 0
时，读取的数值实际上就是其最低有效位（LSB）部分的值。这是因为高位的 0
对数值没有贡献。</p>
<p>例如，假设有一个 64 位寄存器，其值为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000000000000000000000000000000000000000000000000000001010</span><br></pre></td></tr></table></figure>
<p>这个寄存器的值实际上是 10（十进制），因为只有最低的 4
位是有效的（<code>1010</code> 表示的是 10）。高位的 0
并不影响最终的数值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    shl rdi,24</span></span><br><span class="line"><span class="string">    shr rdi,56</span></span><br><span class="line"><span class="string">    mov rax,rdi&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br></pre></td></tr></table></figure>
<h2 id="bitwise-and">bitwise-and</h2>
<p>In this level, you will be working with bit logic and operations.
This will involve heavy use of directly interacting with bits stored in
a register or memory location. You will also likely need to make use of
the logic instructions in x86: <code>and</code>, <code>or</code>,
<code>not</code>, <code>xor</code>.</p>
<p>Bitwise logic in assembly is yet another interesting concept! x86
allows you to perform logic operations bit by bit on registers.</p>
<p>For the sake of this example, say registers only store 8 bits.</p>
<p>The values in <code>rax</code> and <code>rbx</code> are:</p>
<ul>
<li><code>rax = 10101010</code></li>
<li><code>rbx = 00110011</code></li>
</ul>
<p>If we were to perform a bitwise AND of <code>rax</code> and
<code>rbx</code> using the <code>and rax, rbx</code> instruction, the
result would be calculated by ANDing each bit pair one by one, hence why
it's called bitwise logic.</p>
<p>So from left to right:</p>
<ul>
<li>1 AND 0 = 0</li>
<li>0 AND 0 = 0</li>
<li>1 AND 1 = 1</li>
<li>0 AND 1 = 0</li>
<li>...</li>
</ul>
<p>Finally, we combine the results together to get:</p>
<ul>
<li><code>rax = 00100010</code></li>
</ul>
<p>Without using the following instructions: <code>mov</code>,
<code>xchg</code>, please perform the following:</p>
<p>Set <code>rax</code> to the value of <code>(rdi AND rsi)</code></p>
<p>学习 <code>x86</code> 中的逻辑运算符，此处是 <code>and</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    xor rax,rax</span></span><br><span class="line"><span class="string">    and rdi,rsi</span></span><br><span class="line"><span class="string">    add rax,rdi		#题目要求不能直接用mov,那就先初始化后加上</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="check-even">check-even</h2>
<p>In this level, you will be working with bit logic and operations.
This will involve heavy use of directly interacting with bits stored in
a register or memory location. You will also likely need to make use of
the logic instructions in x86: <code>and</code>, <code>or</code>,
<code>not</code>, <code>xor</code>.</p>
<p>Using only the following instructions:</p>
<ul>
<li><code>and</code></li>
<li><code>or</code></li>
<li><code>xor</code></li>
</ul>
<p>Implement the following logic:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if x is even then</span><br><span class="line">  y = 1</span><br><span class="line">else</span><br><span class="line">  y = 0</span><br></pre></td></tr></table></figure>
<p>Where:</p>
<ul>
<li><code>x = rdi</code></li>
<li><code>y = rax</code></li>
</ul>
<p>经典的判断奇偶性，但是 <code>x86</code> 只用逻辑运算符</p>
<p>二进制下的数字的奇偶性由最低位的那个 <code>1</code>
来决定，因为其他位置的变化都是在十进制下增减 <code>2</code> 的倍数。</p>
<p>故先用 <code>add</code>
运算来提取出最低位的数字，题目要求正好和当前结果相反，用
<code>xor</code> 来获得相对的数。最后把这个数字打入清零后的
<code>rax</code> 即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    and rdi,1</span></span><br><span class="line"><span class="string">    xor rdi,1</span></span><br><span class="line"><span class="string">    xor rax,rax</span></span><br><span class="line"><span class="string">    or rax,rdi</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">          ))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="memory-read">memory-read</h2>
<p>Recall that memory can be addressed, and each address contains
something at that location. Note that this is similar to addresses in
real life!</p>
<p>As an example: the real address '699 S Mill Ave, Tempe, AZ 85281'
maps to the 'ASU Brickyard'. We would also say it points to 'ASU
Brickyard'. We can represent this like:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;699 S Mill Ave, Tempe, AZ 85281&#x27;] = &#x27;ASU Brickyard&#x27;</span><br></pre></td></tr></table></figure>
<p>The address is special because it is unique. But that also does not
mean other addresses can't point to the same thing (as someone can have
multiple houses).</p>
<p>Memory is exactly the same!</p>
<p>For instance, the address in memory where your code is stored (when
we take it from you) is <code>0x400000</code>.</p>
<p>In x86, we can access the thing at a memory location, called
dereferencing, like so:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [some_address]        &lt;=&gt;     Moves the thing at &#x27;some_address&#x27; into rax</span><br></pre></td></tr></table></figure>
<p>This also works with things in registers:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [rdi]         &lt;=&gt;     Moves the thing stored at the address of what rdi holds to rax</span><br></pre></td></tr></table></figure>
<p>This works the same for writing to memory:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov [rax], rdi         &lt;=&gt;     Moves rdi to the address of what rax holds.</span><br></pre></td></tr></table></figure>
<p>So if <code>rax</code> was <code>0xdeadbeef</code>, then
<code>rdi</code> would get stored at the address
<code>0xdeadbeef</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0xdeadbeef] = rdi</span><br></pre></td></tr></table></figure>
<p>Note: Memory is linear, and in x86_64, it goes from <code>0</code> to
<code>0xffffffffffffffff</code> (yes, huge).</p>
<p>Please perform the following: Place the value stored at
<code>0x404000</code> into <code>rax</code>. Make sure the value in
<code>rax</code> is the original value stored at
<code>0x404000</code>.</p>
<p>类似上个模块里的练习，不过这次得通过 <code>pwntools</code>
给的渠道而不是直接运行汇编代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax,[0x404000]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="memory-write">memory-write</h2>
<p>In this level, you will be working with memory. This will require you
to read or write to things stored linearly in memory. If you are
confused, go look at the linear addressing module in 'ike. You may also
be asked to dereference things, possibly multiple times, to things we
dynamically put in memory for your use.</p>
<p>Please perform the following: Place the value stored in
<code>rax</code> to <code>0x404000</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov [0x404000],rax</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="memory-increment">memory-increment</h2>
<p>In this level, you will be working with memory. This will require you
to read or write to things stored linearly in memory. If you are
confused, go look at the linear addressing module in 'ike. You may also
be asked to dereference things, possibly multiple times, to things we
dynamically put in memory for your use.</p>
<p>Please perform the following:</p>
<ul>
<li>Place the value stored at <code>0x404000</code> into
<code>rax</code>.</li>
<li>Increment the value stored at the address <code>0x404000</code> by
<code>0x1337</code>.</li>
</ul>
<p>Make sure the value in <code>rax</code> is the original value stored
at <code>0x404000</code> and make sure that <code>[0x404000]</code> now
has the incremented value.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax,[0x404000]</span></span><br><span class="line"><span class="string">    mov rsi,0x1337</span></span><br><span class="line"><span class="string">    add [0x404000],rsi</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>记得灵活运用可以调用的寄存器</p>
<p>更多相关信息参考
==<strong>汇编的寻址模式和过程调用约定</strong>==</p>
<h2 id="byte-access">byte-access</h2>
<p>Recall that registers in x86_64 are 64 bits wide, meaning they can
store 64 bits. Similarly, each memory location can be treated as a
64-bit value. We refer to something that is 64 bits (8 bytes) as a quad
word.</p>
<p>Here is the breakdown of the names of memory sizes:</p>
<ul>
<li>Quad Word = 8 Bytes = 64 bits</li>
<li>Double Word = 4 bytes = 32 bits</li>
<li>Word = 2 bytes = 16 bits</li>
<li>Byte = 1 byte = 8 bits</li>
</ul>
<p>In x86_64, you can access each of these sizes when dereferencing an
address, just like using bigger or smaller register accesses:</p>
<ul>
<li><code>mov al, [address]</code> &lt;=&gt; moves the least significant
byte from address to <code>rax</code></li>
<li><code>mov ax, [address]</code> &lt;=&gt; moves the least significant
word from address to <code>rax</code></li>
<li><code>mov eax, [address]</code> &lt;=&gt; moves the least
significant double word from address to <code>rax</code></li>
<li><code>mov rax, [address]</code> &lt;=&gt; moves the full quad word
from address to <code>rax</code></li>
</ul>
<p>Remember that moving into <code>al</code> does not fully clear the
upper bytes.</p>
<p>Please perform the following: Set <code>rax</code> to the byte at
<code>0x404000</code>.</p>
<p><span style="font-family:serif;"><strong>四字 = 8 字节 =
64bits</strong></span> <span style="font-family:serif;"><strong>双字 = 4
字节 = 32bits</strong></span> <span
style="font-family:serif;"><strong>字 = 2 字节 = 16bits</strong></span>
<span style="font-family:serif;"><strong>1 字节 =
8bits</strong></span></p>
<p><span style="font-family:serif;"><strong>rax = 四字</strong></span>
<span style="font-family:serif;"><strong>eax = 双字</strong></span>
<span style="font-family:serif;"><strong>ax = 字</strong></span> <span
style="font-family:serif;"><strong>al = 字节</strong></span></p>
<p>按要求给寄存器按字节设置即可</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov al,[0x404000]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="memory-size-access">memory-size-access</h2>
<p>Recall the following:</p>
<ul>
<li>The breakdown of the names of memory sizes:
<ul>
<li>Quad Word = 8 Bytes = 64 bits</li>
<li>Double Word = 4 bytes = 32 bits</li>
<li>Word = 2 bytes = 16 bits</li>
<li>Byte = 1 byte = 8 bits</li>
</ul></li>
</ul>
<p>In x86_64, you can access each of these sizes when dereferencing an
address, just like using bigger or smaller register accesses:</p>
<ul>
<li><code>mov al, [address]</code> &lt;=&gt; moves the least significant
byte from address to <code>rax</code></li>
<li><code>mov ax, [address]</code> &lt;=&gt; moves the least significant
word from address to <code>rax</code></li>
<li><code>mov eax, [address]</code> &lt;=&gt; moves the least
significant double word from address to <code>rax</code></li>
<li><code>mov rax, [address]</code> &lt;=&gt; moves the full quad word
from address to <code>rax</code></li>
</ul>
<p>Please perform the following:</p>
<ul>
<li>Set <code>rax</code> to the byte at <code>0x404000</code></li>
<li>Set <code>rbx</code> to the word at <code>0x404000</code></li>
<li>Set <code>rcx</code> to the double word at
<code>0x404000</code></li>
<li>Set <code>rdx</code> to the quad word at <code>0x404000</code></li>
</ul>
<p>加量训练</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov al,[0x404000]</span></span><br><span class="line"><span class="string">    mov bx,[0x404000]</span></span><br><span class="line"><span class="string">    mov ecx,[0x404000]</span></span><br><span class="line"><span class="string">    mov rdx,[0x404000]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>不记得该用哪个寄存器可以去七号题 <code>set-upper-byte</code>
回忆一下</p>
<h2 id="little-endian-write">little-endian-write</h2>
<p>It is worth noting, as you may have noticed, that values are stored
in reverse order of how we represent them.</p>
<p>As an example, say:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0x1330] = 0x00000000deadc0de</span><br></pre></td></tr></table></figure>
<p>If you examined how it actually looked in memory, you would see:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[0x1330] = 0xde</span><br><span class="line">[0x1331] = 0xc0</span><br><span class="line">[0x1332] = 0xad</span><br><span class="line">[0x1333] = 0xde</span><br><span class="line">[0x1334] = 0x00</span><br><span class="line">[0x1335] = 0x00</span><br><span class="line">[0x1336] = 0x00</span><br><span class="line">[0x1337] = 0x00</span><br></pre></td></tr></table></figure>
<p>This format of storing things in 'reverse' is intentional in x86, and
it's called "Little Endian".</p>
<p>For this challenge, we will give you two addresses created
dynamically each run.</p>
<p>The first address will be placed in <code>rdi</code>. The second will
be placed in <code>rsi</code>.</p>
<p>Using the earlier mentioned info, perform the following:</p>
<ul>
<li>Set <code>[rdi] = 0xdeadbeef00001337</code></li>
<li>Set <code>[rsi] = 0xc0ffee0000</code></li>
</ul>
<p>Hint: it may require some tricks to assign a big constant to a
dereferenced register. Try setting a register to the constant value,
then assigning that register to the dereferenced register.</p>
<p>小端序以字为单位逆顺序排列，题目给了个提示：要将一个大常量赋值给一个内存地址，可以将大常量先加载到一个寄存器中，然后将寄存器的值存储到内存地址处。依次赋值即可。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax,0xdeadbeef00001337</span></span><br><span class="line"><span class="string">    mov [rdi],rax</span></span><br><span class="line"><span class="string">    mov rax,0xc0ffee0000</span></span><br><span class="line"><span class="string">    mov [rsi],rax</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="memory-sum">memory-sum</h2>
<p>Recall that memory is stored linearly.</p>
<p>What does that mean?</p>
<p>Say we access the quad word at <code>0x1337</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0x1337] = 0x00000000deadbeef</span><br></pre></td></tr></table></figure>
<p>The real way memory is laid out is byte by byte, little endian:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[0x1337] = 0xef</span><br><span class="line">[0x1337 + 1] = 0xbe</span><br><span class="line">[0x1337 + 2] = 0xad</span><br><span class="line">...</span><br><span class="line">[0x1337 + 7] = 0x00</span><br></pre></td></tr></table></figure>
<p>What does this do for us?</p>
<p>Well, it means that we can access things next to each other using
offsets, similar to what was shown above.</p>
<p>Say you want the 5th <em>byte</em> from an address, you can access it
like:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov al, [address+4]</span><br></pre></td></tr></table></figure>
<p>Remember, offsets start at 0.</p>
<p>Perform the following:</p>
<ul>
<li>Load two consecutive quad words from the address stored in
<code>rdi</code>.</li>
<li>Calculate the sum of the previous steps' quad words.</li>
<li>Store the sum at the address in <code>rsi</code>.</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax,[rdi]</span></span><br><span class="line"><span class="string">    add rax,[rdi+8]</span></span><br><span class="line"><span class="string">    mov [rsi],rax 	#不要忘记给rsi添加括号，不然就只是修改寄存器的值而不是指向的内存地址中的值</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="stack-subtraction">stack-subtraction</h2>
<p>In these levels, we are going to introduce the stack.</p>
<p>The stack is a region of memory that can store values for later.</p>
<p>To store a value on the stack, we use the <code>push</code>
instruction, and to retrieve a value, we use <code>pop</code>.</p>
<p>The stack is a last in, first out (LIFO) memory structure, and this
means the last value pushed is the first value popped.</p>
<p>Imagine unloading plates from the dishwasher. Let's say there are 1
red, 1 green, and 1 blue. First, we place the red one in the cabinet,
then the green on top of the red, then the blue.</p>
<p>Our stack of plates would look like:</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Top ----&gt; Blue</span><br><span class="line">          Green</span><br><span class="line">Bottom -&gt; Red</span><br></pre></td></tr></table></figure>
<p>Now, if we wanted a plate to make a sandwich, we would retrieve the
top plate from the stack, which would be the blue one that was last into
the cabinet, ergo the first one out.</p>
<p>On x86, the <code>pop</code> instruction will take the value from the
top of the stack and put it into a register.</p>
<p>Similarly, the <code>push</code> instruction will take the value in a
register and push it onto the top of the stack.</p>
<p>Using these instructions, take the top value of the stack, subtract
<code>rdi</code> from it, then put it back.</p>
<p>终于学到栈了/(ㄒoㄒ)/~~。</p>
<p>想象一下你有一叠书放在桌子上，你只能从最上面拿书或放书，不能从中间或底部操作。这就像一个栈，只能从栈顶进行操作。</p>
<ul>
<li><strong>入栈（Push）</strong>：
<ul>
<li><strong>比喻</strong>：就像在书堆的最上面再放一本书。</li>
<li><strong>操作</strong>：将一个新元素添加到栈顶。在计算机中，这通常意味着将数据存储到栈的顶部，并更新栈指针（指向栈顶的指针）。</li>
<li><strong>效果</strong>：栈的大小增加，新元素成为栈顶元素。</li>
</ul></li>
<li><strong>出栈（Pop）</strong>：
<ul>
<li><strong>比喻</strong>：从书堆的最上面拿走一本书。</li>
<li><strong>操作</strong>：从栈顶移除一个元素，并返回该元素的值。同时更新栈指针。</li>
<li><strong>效果</strong>：栈的大小减少，原来位于栈顶下面的元素成为新的栈顶元素。</li>
</ul></li>
<li><strong>查看栈顶（Peek）</strong>：
<ul>
<li><strong>比喻</strong>：查看书堆最上面的书是什么，但不拿走它。</li>
<li><strong>操作</strong>：获取栈顶元素的值，但不移除该元素。</li>
<li><strong>效果</strong>：栈的大小和内容不变，只是查看了栈顶元素。</li>
</ul></li>
</ul>
<p>他这里没提具体用汇编代码如何操作，其实直接<code>pop</code>弹出，<code>push</code>压入即可。</p>
<p>栈是一种线性数据结构，遵循“后进先出”（Last In, First Out,
LIFO）的原则。这意味着最后放入栈中的元素将是第一个被取出的元素。由于寄存器数量有限，使用栈来储存数据便是一个极佳的选择。后面会经常和它打交道。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    sub,rax,rdi</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="swap-satck-values">swap-satck-values</h2>
<p>In this level, you will be working with the stack, the memory region
that dynamically expands and shrinks. You will be required to read and
write to the stack, which may require you to use the <code>pop</code>
and <code>push</code> instructions. You may also need to use the stack
pointer register (<code>rsp</code>) to know where the stack is
pointing.</p>
<p>In this level, we are going to explore the last in first out (LIFO)
property of the stack.</p>
<p>Using only the following instructions:</p>
<ul>
<li><code>push</code></li>
<li><code>pop</code></li>
</ul>
<p>Swap values in <code>rdi</code> and <code>rsi</code>.</p>
<p>Example:</p>
<ul>
<li>If to start <code>rdi = 2</code> and <code>rsi = 5</code></li>
<li>Then to end <code>rdi = 5</code> and <code>rsi = 2</code></li>
</ul>
<p>仅用<code>pop</code>和<code>push</code>进行数值交换，栈的基本用法</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    push rdi</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    push rsi</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    pop rsi</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="average-stack-values">average-stack-values</h2>
<p>In the previous levels, you used <code>push</code> and
<code>pop</code> to store and load data from the stack. However, you can
also access the stack directly using the stack pointer.</p>
<p>On x86, the stack pointer is stored in the special register,
<code>rsp</code>. <code>rsp</code> always stores the memory address of
the top of the stack, i.e., the memory address of the last value
pushed.</p>
<p>Similar to the memory levels, we can use <code>[rsp]</code> to access
the value at the memory address in <code>rsp</code>.</p>
<p>Without using <code>pop</code>, please calculate the average of 4
consecutive quad words stored on the stack. Push the average on the
stack.</p>
<p>Hint:</p>
<ul>
<li><code>RSP+0x??</code> Quad Word A</li>
<li><code>RSP+0x??</code> Quad Word B</li>
<li><code>RSP+0x??</code> Quad Word C</li>
<li><code>RSP</code> Quad Word D</li>
</ul>
<p>介绍了栈指针<code>rsp</code>,提示了我们用栈指针的具体操作。</p>
<ul>
<li><strong>栈指针的操作</strong>：
<ul>
<li><strong>入栈（Push）</strong>：将数据推入栈时，<code>RSP</code>会减小（向下移动），因为x86-64架构的栈是向下增长的。</li>
<li><strong>出栈（Pop）</strong>：从栈中弹出数据时，<code>RSP</code>会增加（向上移动）。</li>
<li><strong>直接访问</strong>：可以通过<code>[RSP + offset]</code>的形式直接访问栈上的数据，其中<code>offset</code>是相对于栈顶的偏移量。</li>
</ul></li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax,[rsp]</span></span><br><span class="line"><span class="string">    add rax,[rsp+8]</span></span><br><span class="line"><span class="string">    add rax,[rsp+16]</span></span><br><span class="line"><span class="string">    add rax,[rsp+24]</span></span><br><span class="line"><span class="string">    mov rsi,4			; rax存储被除数的低 64 位。</span></span><br><span class="line"><span class="string">    div rsi	</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="abusolute-jump">abusolute-jump</h2>
<p>Earlier, you learned how to manipulate data in a pseudo-control way,
but x86 gives us actual instructions to manipulate control flow
directly.</p>
<p>There are two major ways to manipulate control flow:</p>
<ul>
<li>Through a jump</li>
<li>Through a call</li>
</ul>
<p>In this level, you will work with jumps.</p>
<p>There are two types of jumps:</p>
<ul>
<li>Unconditional jumps</li>
<li>Conditional jumps</li>
</ul>
<p>Unconditional jumps always trigger and are not based on the results
of earlier instructions.</p>
<p>As you know, memory locations can store data and instructions. Your
code will be stored at <code>0x400042</code> (this will change each
run).</p>
<p>For all jumps, there are three types:</p>
<ul>
<li>Relative jumps: jump + or - the next instruction.</li>
<li>Absolute jumps: jump to a specific address.</li>
<li>Indirect jumps: jump to the memory address specified in a
register.</li>
</ul>
<p>In x86, absolute jumps (jump to a specific address) are accomplished
by first putting the target address in a register <code>reg</code>, then
doing <code>jmp reg</code>.</p>
<p>In this level, we will ask you to do an absolute jump. Perform the
following: Jump to the absolute address <code>0x403000</code>.</p>
<p>x86_64用法 jmp <register></p>
<p>绝对跳转和相对跳转也是两个经久不衰的话题。题目里说到的<code>reg</code>其实就是regitser，寄存器的缩写，并不是特指某一个寄存器。当然jmp指令也不能直接给出地址进行跳转，必须要用寄存器作为中介。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">	mov rax,0x403000</span></span><br><span class="line"><span class="string">    jmp rax</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="relative-jump">relative-jump</h2>
<p>Recall that for all jumps, there are three types:</p>
<ul>
<li>Relative jumps</li>
<li>Absolute jumps</li>
<li>Indirect jumps</li>
</ul>
<p>In this level, we will ask you to do a relative jump. You will need
to fill space in your code with something to make this relative jump
possible. We suggest using the <code>nop</code> instruction. It's 1 byte
long and very predictable.</p>
<p>In fact, the assembler that we're using has a handy
<code>.rept</code> directive that you can use to repeat assembly
instructions some number of times: <a
target="_blank" rel="noopener" href="https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_chapter/as_7.html">GNU
Assembler Manual</a></p>
<p>Useful instructions for this level:</p>
<ul>
<li><code>jmp (reg1 | addr | offset)</code></li>
<li><code>nop</code></li>
</ul>
<p>Hint: For the relative jump, look up how to use <code>labels</code>
in x86.</p>
<p>Using the above knowledge, perform the following:</p>
<ul>
<li>Make the first instruction in your code a <code>jmp</code>.</li>
<li>Make that <code>jmp</code> a relative jump to 0x51 bytes from the
current position.</li>
<li>At the code location where the relative jump will redirect control
flow, set <code>rax</code> to 0x1.</li>
</ul>
<p>头一次看晕乎乎的，问了几遍kimi终于明白了。</p>
<p>题目要求的相对跳转实际上是通过设置一个<code>label</code>地址后，不断填充无意义的<code>nop</code>空指令来实现的跳转。当我们执行到<code>label</code>时，结果的确是相对于目前的地址进行了一定字节的跳转。</p>
<p><code>.rept 0x??</code></p>
<p><code>instructions</code></p>
<p><code>.endr</code></p>
<p>相当于一个循环语句.</p>
<p><code>address</code>是一个标签（label）,它用于标记代码中的某个位置,通常用于指示跳转指令的目标位置或其他重要的代码段。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    jmp address</span></span><br><span class="line"><span class="string">    .rept 0x51</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    .endr</span></span><br><span class="line"><span class="string">    address:</span></span><br><span class="line"><span class="string">    mov rax,0x1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>关于代码的可能问题：</p>
<ol type="1">
<li><strong>执行<code>jmp address</code>指令</strong>：
<ul>
<li>这条指令告诉CPU跳转到<code>address</code>标签所标记的位置。由于<code>address</code>标签标记的是<code>mov rax, 0x1</code>指令的起始位置，所以CPU会跳过接下来的81个<code>nop</code>指令，直接跳转到<code>mov rax, 0x1</code>指令处开始执行。</li>
</ul></li>
<li><strong>跳转到<code>address</code>标签后，执行<code>mov rax, 0x1</code>指令</strong>：
<ul>
<li>在跳转到<code>address</code>标签后，CPU会执行<code>mov rax, 0x1</code>指令，将<code>rax</code>寄存器的值设置为1。</li>
</ul></li>
<li><strong>关于81个<code>nop</code>指令</strong></li>
</ol>
<ul>
<li><strong>填充作用</strong>：这81个<code>nop</code>指令实际上是用来填充代码空间的。它们确保从<code>jmp address</code>指令到<code>address</code>标签之间的距离正好是81字节。这是为了满足相对跳转的要求，使得<code>jmp</code>指令能够正确地跳转到目标位置。</li>
<li><strong>不执行</strong>：在程序执行过程中，这81个<code>nop</code>指令并不会被实际执行。因为<code>jmp address</code>指令已经将控制流跳转到了<code>address</code>标签处，所以CPU会跳过这些<code>nop</code>指令，直接执行<code>mov rax, 0x1</code>指令。</li>
</ul>
<h2 id="jump-trampoline">jump-trampoline</h2>
<p>Now, we will combine the two prior levels and perform the
following:</p>
<ul>
<li>Create a two jump trampoline:
<ul>
<li>Make the first instruction in your code a <code>jmp</code>.</li>
<li>Make that <code>jmp</code> a relative jump to 0x51 bytes from its
current position.</li>
<li>At 0x51, write the following code:
<ul>
<li>Place the top value on the stack into register
<code>rdi</code>.</li>
<li><code>jmp</code> to the absolute address 0x403000.</li>
</ul></li>
</ul></li>
</ul>
<p>熟悉下刚学到的两种跳转方式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    jmp address</span></span><br><span class="line"><span class="string">    .rept 0x51</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    .endr</span></span><br><span class="line"><span class="string">    address:</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    mov rdi,rax</span></span><br><span class="line"><span class="string">    mov rsi,0x403000</span></span><br><span class="line"><span class="string">    jmp rsi</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="conditional-jump">conditional-jump</h2>
<p>In this level, you will be working with control flow manipulation.
This involves using instructions to both indirectly and directly control
the special register <code>rip</code>, the instruction pointer. You will
use instructions such as <code>jmp</code>, <code>call</code>,
<code>cmp</code>, and their alternatives to implement the requested
behavior.</p>
<p>We will be testing your code multiple times in this level with
dynamic values! This means we will be running your code in a variety of
random ways to verify that the logic is robust enough to survive normal
use.</p>
<p>We will now introduce you to conditional jumps--one of the most
valuable instructions in x86. In higher-level programming languages, an
if-else structure exists to do things like:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if x is even:</span><br><span class="line">    is_even = 1</span><br><span class="line">else:</span><br><span class="line">    is_even = 0</span><br></pre></td></tr></table></figure>
<p>This should look familiar since it is implementable in only
bit-logic, which you've done in a prior level. In these structures, we
can control the program's control flow based on dynamic values provided
to the program.</p>
<p>Implementing the above logic with jmps can be done like so:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">; assume rdi = x, rax is output</span><br><span class="line">; rdx = rdi mod 2</span><br><span class="line">mov rax, rdi</span><br><span class="line">mov rsi, 2</span><br><span class="line">div rsi</span><br><span class="line">; remainder is 0 if even</span><br><span class="line">cmp rdx, 0</span><br><span class="line">; jump to not_even code if it&#x27;s not 0</span><br><span class="line">jne not_even</span><br><span class="line">; fall through to even code</span><br><span class="line">mov rbx, 1</span><br><span class="line">jmp done</span><br><span class="line">; jump to this only when not_even</span><br><span class="line">not_even:</span><br><span class="line">mov rbx, 0</span><br><span class="line">done:</span><br><span class="line">mov rax, rbx</span><br><span class="line">; more instructions here</span><br></pre></td></tr></table></figure>
<p>Often though, you want more than just a single 'if-else'. Sometimes
you want two if checks, followed by an else. To do this, you need to
make sure that you have control flow that 'falls-through' to the next
<code>if</code> after it fails. All must jump to the same
<code>done</code> after execution to avoid the else.</p>
<p>There are many jump types in x86, it will help to learn how they can
be used. Nearly all of them rely on something called the ZF, the Zero
Flag. The ZF is set to 1 when a <code>cmp</code> is equal, 0
otherwise.</p>
<p>Using the above knowledge, implement the following:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if [x] is 0x7f454c46:</span><br><span class="line">    y = [x+4] + [x+8] + [x+12]</span><br><span class="line">else if [x] is 0x00005A4D:</span><br><span class="line">    y = [x+4] - [x+8] - [x+12]</span><br><span class="line">else:</span><br><span class="line">    y = [x+4] * [x+8] * [x+12]</span><br></pre></td></tr></table></figure>
<p>Where:</p>
<ul>
<li><code>x = rdi</code>, <code>y = rax</code>.</li>
</ul>
<p>Assume each dereferenced value is a signed dword. This means the
values can start as a negative value at each memory position.</p>
<p>A valid solution will use the following at least once:</p>
<ul>
<li><code>jmp</code> (any variant), <code>cmp</code></li>
</ul>
<p>接下来的挑战是进行流操作，后悔没在下午开始学。。最后十道题几乎要花上做之前二十道两倍的时间。。。😭😭😭😅😅😅</p>
<p>还好有没脾气的ai，不然去discord或者bing上早不知道要猴年马月才能做完。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.update(arch=<span class="string">&quot;amd64&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;/challenge/run&quot;</span>)</span><br><span class="line">p.write(asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">mov eax, [rdi]</span></span><br><span class="line"><span class="string">mov ebx, [rdi + 4]</span></span><br><span class="line"><span class="string">mov ecx, [rdi + 8]</span></span><br><span class="line"><span class="string">mov edx, [rdi + 12]</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">cmp eax, 0x7f454c46</span></span><br><span class="line"><span class="string">je con1</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">cmp eax, 0x00005A4D</span></span><br><span class="line"><span class="string">je con2</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">imul ebx, ecx</span></span><br><span class="line"><span class="string">imul ebx, edx</span></span><br><span class="line"><span class="string">jmp done</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">con1:</span></span><br><span class="line"><span class="string">add ebx, ecx</span></span><br><span class="line"><span class="string">add ebx, edx</span></span><br><span class="line"><span class="string">jmp done</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">con2:</span></span><br><span class="line"><span class="string">sub ebx, ecx</span></span><br><span class="line"><span class="string">sub ebx, edx</span></span><br><span class="line"><span class="string">done:</span></span><br><span class="line"><span class="string">mov eax, ebx&quot;&quot;&quot;</span>))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="indirect-jump">indirect-jump</h2>
<p>The last jump type is the indirect jump, often used for switch
statements in the real world. Switch statements are a special case of
if-statements that use only numbers to determine where the control flow
will go.</p>
<p>Here is an example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">switch(number):</span><br><span class="line">  0: jmp do_thing_0</span><br><span class="line">  1: jmp do_thing_1</span><br><span class="line">  2: jmp do_thing_2</span><br><span class="line">  default: jmp do_default_thing</span><br></pre></td></tr></table></figure>
<p>The switch in this example works on <code>number</code>, which can
either be 0, 1, or 2. If <code>number</code> is not one of those
numbers, the default triggers. You can consider this a reduced else-if
type structure. In x86, you are already used to using numbers, so it
should be no surprise that you can make if statements based on something
being an exact number. Additionally, if you know the range of the
numbers, a switch statement works very well.</p>
<p>Take, for instance, the existence of a jump table. A jump table is a
contiguous section of memory that holds addresses of places to jump.</p>
<p>In the above example, the jump table could look like:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0x1337] = address of do_thing_0</span><br><span class="line">[0x1337+0x8] = address of do_thing_1</span><br><span class="line">[0x1337+0x10] = address of do_thing_2</span><br><span class="line">[0x1337+0x18] = address of do_default_thing</span><br></pre></td></tr></table></figure>
<p>Using the jump table, we can greatly reduce the amount of
<code>cmps</code> we use. Now all we need to check is if
<code>number</code> is greater than 2. If it is, always do:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp [0x1337+0x18]</span><br></pre></td></tr></table></figure>
<p>Otherwise:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp [jump_table_address + number * 8]</span><br></pre></td></tr></table></figure>
<p>Using the above knowledge, implement the following logic:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if rdi is 0:</span><br><span class="line">  jmp 0x40301e</span><br><span class="line">else if rdi is 1:</span><br><span class="line">  jmp 0x4030da</span><br><span class="line">else if rdi is 2:</span><br><span class="line">  jmp 0x4031d5</span><br><span class="line">else if rdi is 3:</span><br><span class="line">  jmp 0x403268</span><br><span class="line">else:</span><br><span class="line">  jmp 0x40332c</span><br></pre></td></tr></table></figure>
<p>Please do the above with the following constraints:</p>
<ul>
<li>Assume <code>rdi</code> will NOT be negative.</li>
<li>Use no more than 1 <code>cmp</code> instruction.</li>
<li>Use no more than 3 jumps (of any variant).</li>
<li>We will provide you with the number to 'switch' on in
<code>rdi</code>.</li>
<li>We will provide you with a jump table base address in
<code>rsi</code>.</li>
</ul>
<p>Here is an example table:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[0x40427c] = 0x40301e (addrs will change)</span><br><span class="line">[0x404284] = 0x4030da</span><br><span class="line">[0x40428c] = 0x4031d5</span><br><span class="line">[0x404294] = 0x403268</span><br><span class="line">[0x40429c] = 0x40332c</span><br></pre></td></tr></table></figure>
<p>学会使用跳转表来实现<code>switch</code>的功能，这就是底层代码。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">cmp rdi, 4</span></span><br><span class="line"><span class="string">jae default</span></span><br><span class="line"><span class="string">jmp [rsi + rdi * 8]</span></span><br><span class="line"><span class="string">jmp end</span></span><br><span class="line"><span class="string">default:</span></span><br><span class="line"><span class="string">jmp [rsi + 4 * 8]</span></span><br><span class="line"><span class="string">end:</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="average-loop">average-loop</h2>
<p>In a previous level, you computed the average of 4 integer quad
words, which was a fixed amount of things to compute. But how do you
work with sizes you get when the program is running?</p>
<p>In most programming languages, a structure exists called the
for-loop, which allows you to execute a set of instructions for a
bounded amount of times. The bounded amount can be either known before
or during the program's run, with "during" meaning the value is given to
you dynamically.</p>
<p>As an example, a for-loop can be used to compute the sum of the
numbers 1 to n:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sum = 0</span><br><span class="line">i = 1</span><br><span class="line">while i &lt;= n:</span><br><span class="line">    sum += i</span><br><span class="line">    i += 1</span><br></pre></td></tr></table></figure>
<p>Please compute the average of <code>n</code> consecutive quad words,
where:</p>
<ul>
<li><code>rdi</code> = memory address of the 1st quad word</li>
<li><code>rsi</code> = <code>n</code> (amount to loop for)</li>
<li><code>rax</code> = average computed</li>
</ul>
<p>就像是在实现高级语言</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax,0</span></span><br><span class="line"><span class="string">    mov rcx,0</span></span><br><span class="line"><span class="string">    loop_start:</span></span><br><span class="line"><span class="string">        cmp rcx, rsi</span></span><br><span class="line"><span class="string">        jge loop_end</span></span><br><span class="line"><span class="string">        add rax, [rdi + rcx * 8]</span></span><br><span class="line"><span class="string">        inc rcx</span></span><br><span class="line"><span class="string">        jmp loop_start</span></span><br><span class="line"><span class="string">    loop_end:</span></span><br><span class="line"><span class="string">    div rsi</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="count-non-zero">count-non-zero</h2>
<p>In previous levels, you discovered the for-loop to iterate for a
<em>number</em> of times, both dynamically and statically known, but
what happens when you want to iterate until you meet a condition?</p>
<p>A second loop structure exists called the while-loop to fill this
demand. In the while-loop, you iterate until a condition is met.</p>
<p>As an example, say we had a location in memory with adjacent numbers
and we wanted to get the average of all the numbers until we find one
bigger or equal to <code>0xff</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">average = 0</span><br><span class="line">i = 0</span><br><span class="line">while x[i] &lt; 0xff:</span><br><span class="line">  average += x[i]</span><br><span class="line">  i += 1</span><br><span class="line">average /= i</span><br></pre></td></tr></table></figure>
<p>Using the above knowledge, please perform the following:</p>
<p>Count the consecutive non-zero bytes in a contiguous region of
memory, where:</p>
<ul>
<li><code>rdi</code> = memory address of the 1st byte</li>
<li><code>rax</code> = number of consecutive non-zero bytes</li>
</ul>
<p>Additionally, if <code>rdi = 0</code>, then set <code>rax = 0</code>
(we will check)!</p>
<p>An example test-case, let:</p>
<ul>
<li><code>rdi = 0x1000</code></li>
<li><code>[0x1000] = 0x41</code></li>
<li><code>[0x1001] = 0x42</code></li>
<li><code>[0x1002] = 0x43</code></li>
<li><code>[0x1003] = 0x00</code></li>
</ul>
<p>Then: <code>rax = 3</code> should be set.</p>
<p>建构一下while循环</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line">p.write(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    cmp rdi,0</span></span><br><span class="line"><span class="string">    je set_zero</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    xor rcx,rcx</span></span><br><span class="line"><span class="string">    while_loop:</span></span><br><span class="line"><span class="string">    	cmp byte [rdi],0</span></span><br><span class="line"><span class="string">    	je end_loop</span></span><br><span class="line"><span class="string">    	inc rcx</span></span><br><span class="line"><span class="string">    	inc rdi</span></span><br><span class="line"><span class="string">    	jmp while_loop</span></span><br><span class="line"><span class="string">    end_loop:</span></span><br><span class="line"><span class="string">    	mov rax,rcx</span></span><br><span class="line"><span class="string">    	jmp done</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    set_zero:</span></span><br><span class="line"><span class="string">    xor rax,rax</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    done:</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意,在x86-64汇编中，使用<code>cmp</code>指令比较内存中的值时，需要明确指定操作数的大小。提示“ambiguous
operand size for <code>cmp</code>”</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/tmp/pwn-asm-n0jy2att/step1: Assembler messages:</span><br><span class="line">/tmp/pwn-asm-n0jy2att/step1:12: Error: ambiguous operand size <span class="keyword">for</span> `cmp<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>
<p>可以通过在<code>cmp</code>指令中明确指定操作数的大小，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp byte ptr [rdi], 0</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp dword ptr [rdi], 0</span><br></pre></td></tr></table></figure>
<p><code>ptr</code>,<strong>Pointer</strong>,汇编语言中，<code>ptr</code>是一个类型指示符，用于明确指定操作数的大小。使用<code>cmp</code>指令比较内存中的值时，汇编器可能不知道你是想比较一个字节、一个字（16位）、一个双字（32位）还是一个四字（64位）。通过加上<code>ptr</code>，你可以明确指定操作数的大小，从而消除歧义。</p>
<p>就像题目里，我们比较的是一个字节，所以要用<code>byte</code>指出。</p>
<h2 id="string-lower">string-lower</h2>
<p>In previous levels, you implemented a while loop to count the number
of consecutive non-zero bytes in a contiguous region of memory.</p>
<p>In this level, you will be provided with a contiguous region of
memory again and will loop over each performing a conditional operation
till a zero byte is reached. All of which will be contained in a
function!</p>
<p>A function is a callable segment of code that does not destroy
control flow.</p>
<p>Functions use the instructions "call" and "ret".</p>
<p>The "call" instruction pushes the memory address of the next
instruction onto the stack and then jumps to the value stored in the
first argument.</p>
<p>Let's use the following instructions as an example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x1021 mov rax, 0x400000</span><br><span class="line">0x1028 call rax</span><br><span class="line">0x102a mov [rsi], rax</span><br></pre></td></tr></table></figure>
<ol type="1">
<li><code>call</code> pushes <code>0x102a</code>, the address of the
next instruction, onto the stack.</li>
<li><code>call</code> jumps to <code>0x400000</code>, the value stored
in <code>rax</code>.</li>
</ol>
<p>The "ret" instruction is the opposite of "call".</p>
<p><code>ret</code> pops the top value off of the stack and jumps to
it.</p>
<p>Let's use the following instructions and stack as an example:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack ADDR  VALUE</span><br><span class="line">0x103f mov rax, rdx         RSP + 0x8   0xdeadbeef</span><br><span class="line">0x1042 ret                  RSP + 0x0   0x0000102a</span><br></pre></td></tr></table></figure>
<p>Here, <code>ret</code> will jump to <code>0x102a</code>.</p>
<p>Please implement the following logic:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">str_lower(src_addr):</span><br><span class="line">  i = 0</span><br><span class="line">  if src_addr != 0:</span><br><span class="line">    while [src_addr] != 0x00:</span><br><span class="line">      if [src_addr] &lt;= 0x5a:</span><br><span class="line">        [src_addr] = foo([src_addr])</span><br><span class="line">        i += 1</span><br><span class="line">      src_addr += 1</span><br><span class="line">  return i</span><br></pre></td></tr></table></figure>
<p><code>foo</code> is provided at <code>0x403000</code>.
<code>foo</code> takes a single argument as a value and returns a
value.</p>
<p>All functions (<code>foo</code> and <code>str_lower</code>) must
follow the Linux amd64 calling convention (also known as System V AMD64
ABI): <a
target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI">System
V AMD64 ABI</a></p>
<p>Therefore, your function <code>str_lower</code> should look for
<code>src_addr</code> in <code>rdi</code> and place the function return
in <code>rax</code>.</p>
<p>An important note is that <code>src_addr</code> is an address in
memory (where the string is located) and <code>[src_addr]</code> refers
to the byte that exists at <code>src_addr</code>.</p>
<p>Therefore, the function <code>foo</code> accepts a byte as its first
argument and returns a byte.</p>
<p>注意foo函数返还的是一个字节大小的值，不能直接用al</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line">p.write(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    cmp rdi, 0</span></span><br><span class="line"><span class="string">    je return_0</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    xor rcx, rcx</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    while_loop:</span></span><br><span class="line"><span class="string">        cmp byte ptr [rdi], 0</span></span><br><span class="line"><span class="string">        je return_0</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        mov al, byte ptr [rdi]</span></span><br><span class="line"><span class="string">        cmp al, 0x5a</span></span><br><span class="line"><span class="string">        jg next_byte</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">       	mov rsi,rdi</span></span><br><span class="line"><span class="string">        mov dil,al</span></span><br><span class="line"><span class="string">        call rbx</span></span><br><span class="line"><span class="string">        mov rdi,rsi</span></span><br><span class="line"><span class="string">        mov byte ptr [rdi],al</span></span><br><span class="line"><span class="string">        inc rcx</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    next_byte:</span></span><br><span class="line"><span class="string">        inc rdi</span></span><br><span class="line"><span class="string">        jmp while_loop</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    return_0:</span></span><br><span class="line"><span class="string">        mov rax, rcx</span></span><br><span class="line"><span class="string">        ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>))</span><br><span class="line">output = p.recvall().decode()</span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure>
<p>上面代码不对，暂时没有debug成功</p>
<p>以下是网上找到的通过的代码</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line">p.write(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    str_lower:</span></span><br><span class="line"><span class="string">    mov rbx, 0x403000       </span></span><br><span class="line"><span class="string">    xor rcx, rcx            </span></span><br><span class="line"><span class="string">    test rdi, rdi          </span></span><br><span class="line"><span class="string">    jz done                 </span></span><br><span class="line"><span class="string">process_string:</span></span><br><span class="line"><span class="string">    mov al, byte ptr [rdi]  </span></span><br><span class="line"><span class="string">    test al, al             </span></span><br><span class="line"><span class="string">    jz done                </span></span><br><span class="line"><span class="string">    cmp al, 0x5A           </span></span><br><span class="line"><span class="string">    jg skip_conversion      </span></span><br><span class="line"><span class="string">    mov rsi, rdi           </span></span><br><span class="line"><span class="string">    mov dil, al             </span></span><br><span class="line"><span class="string">    call rbx                </span></span><br><span class="line"><span class="string">    mov rdi, rsi            </span></span><br><span class="line"><span class="string">    mov byte ptr [rdi], al   </span></span><br><span class="line"><span class="string">    inc rcx                 </span></span><br><span class="line"><span class="string">skip_conversion:</span></span><br><span class="line"><span class="string">    inc rdi                  </span></span><br><span class="line"><span class="string">    jmp process_string       </span></span><br><span class="line"><span class="string">done:</span></span><br><span class="line"><span class="string">    mov rax, rcx             </span></span><br><span class="line"><span class="string">    ret        </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>))</span><br><span class="line">output = p.recvall().decode()</span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure>
<h2 id="most-common-byte">most-common-byte</h2>
<p>A function stack frame is a set of pointers and values pushed onto
the stack to save things for later use and allocate space on the stack
for function variables.</p>
<p>First, let's talk about the special register <code>rbp</code>, the
Stack Base Pointer.</p>
<p>The <code>rbp</code> register is used to tell where our stack frame
first started. As an example, say we want to construct some list (a
contiguous space of memory) that is only used in our function. The list
is 5 elements long, and each element is a dword. A list of 5 elements
would already take 5 registers, so instead, we can make space on the
stack!</p>
<p>The assembly would look like:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">; setup the base of the stack as the current top</span><br><span class="line">mov rbp, rsp</span><br><span class="line">; move the stack 0x14 bytes (5 * 4) down</span><br><span class="line">; acts as an allocation</span><br><span class="line">sub rsp, 0x14</span><br><span class="line">; assign list[2] = 1337</span><br><span class="line">mov eax, 1337</span><br><span class="line">mov [rbp-0x8], eax</span><br><span class="line">; do more operations on the list ...</span><br><span class="line">; restore the allocated space</span><br><span class="line">mov rsp, rbp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure>
<p>Notice how <code>rbp</code> is always used to restore the stack to
where it originally was. If we don't restore the stack after use, we
will eventually run out. In addition, notice how we subtracted from
<code>rsp</code>, because the stack grows down. To make the stack have
more space, we subtract the space we need. The <code>ret</code> and
<code>call</code> still work the same.</p>
<p>Once again, please make function(s) that implement the following:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">most_common_byte(src_addr, size):</span><br><span class="line">  i = 0</span><br><span class="line">  while i &lt;= size-1:</span><br><span class="line">    curr_byte = [src_addr + i]</span><br><span class="line">    [stack_base - curr_byte] += 1</span><br><span class="line">    i += 1</span><br><span class="line"></span><br><span class="line">  b = 0</span><br><span class="line">  max_freq = 0</span><br><span class="line">  max_freq_byte = 0</span><br><span class="line">  while b &lt;= 0xff:</span><br><span class="line">    if [stack_base - b] &gt; max_freq:</span><br><span class="line">      max_freq = [stack_base - b]</span><br><span class="line">      max_freq_byte = b</span><br><span class="line">    b += 1</span><br><span class="line"></span><br><span class="line">  return max_freq_byte</span><br></pre></td></tr></table></figure>
<p><strong>Assumptions:</strong></p>
<ul>
<li>There will never be more than 0xffff of any byte</li>
<li>The size will never be longer than 0xffff</li>
<li>The list will have at least one element</li>
</ul>
<p><strong>Constraints:</strong></p>
<ul>
<li>You must put the "counting list" on the stack</li>
<li>You must restore the stack like in a normal function</li>
<li>You cannot modify the data at <code>src_addr</code></li>
</ul>
<p>汇编代码部分的终局一战🥲🥲🥲🥲🥲</p>
<hr />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line">p.write(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    most_common_byte:</span></span><br><span class="line"><span class="string">    push rbp                 </span></span><br><span class="line"><span class="string">    mov rbp, rsp           </span></span><br><span class="line"><span class="string">    sub rsp, 256            </span></span><br><span class="line"><span class="string">    xor rcx, rcx            </span></span><br><span class="line"><span class="string">initialize_counting_list_with_zero:</span></span><br><span class="line"><span class="string">    mov byte ptr [rbp + rcx - 256], 0  </span></span><br><span class="line"><span class="string">    inc rcx                              </span></span><br><span class="line"><span class="string">    cmp rcx, 256                         </span></span><br><span class="line"><span class="string">    jl initialize_counting_list_with_zero </span></span><br><span class="line"><span class="string">    xor rcx, rcx                        </span></span><br><span class="line"><span class="string">count_bytes:</span></span><br><span class="line"><span class="string">    movzx eax, byte ptr [rdi + rcx]     </span></span><br><span class="line"><span class="string">    inc byte ptr [rbp + rax - 256]      </span></span><br><span class="line"><span class="string">    inc rcx                             </span></span><br><span class="line"><span class="string">    cmp rcx, rsi                       </span></span><br><span class="line"><span class="string">    jl count_bytes                     </span></span><br><span class="line"><span class="string">init_b_max_freq_max_freq_byte:</span></span><br><span class="line"><span class="string">    xor rcx, rcx                        </span></span><br><span class="line"><span class="string">    xor rdx, rdx                         </span></span><br><span class="line"><span class="string">    xor rbx, rbx                         </span></span><br><span class="line"><span class="string">find_most_common_byte:</span></span><br><span class="line"><span class="string">    movzx eax, byte ptr [rbp + rcx - 256] </span></span><br><span class="line"><span class="string">    cmp al, dl                           </span></span><br><span class="line"><span class="string">    jle next_byte                        </span></span><br><span class="line"><span class="string">update_max_freq_and_max_freq_byte:</span></span><br><span class="line"><span class="string">    mov dl, al                           </span></span><br><span class="line"><span class="string">    mov bl, cl                           </span></span><br><span class="line"><span class="string">next_byte:</span></span><br><span class="line"><span class="string">    inc rcx                              </span></span><br><span class="line"><span class="string">    cmp rcx, 256                        </span></span><br><span class="line"><span class="string">    jl find_most_common_byte             </span></span><br><span class="line"><span class="string">return:</span></span><br><span class="line"><span class="string">    mov al, bl                          </span></span><br><span class="line"><span class="string">restore:</span></span><br><span class="line"><span class="string">    mov rsp, rbp                        </span></span><br><span class="line"><span class="string">    pop rbp                               </span></span><br><span class="line"><span class="string">    ret                                   </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>))</span><br><span class="line">output = p.recvall().decode()</span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure>
<p>还得沉淀</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>AAAFORGE
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://midnightr3d.top/2025/01/09/Assembly%20Crash%20Course%20record/" title="Assembly Crash Course record">http://midnightr3d.top/2025/01/09/Assembly Crash Course record/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>

        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag"># 学习笔记</a>
              <a href="/tags/%E7%BD%91%E5%AE%89/" rel="tag"># 网安</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/01/06/%E9%85%8D%E7%BD%AEwsl%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/" rel="prev" title="wsl图形化界面安装踩坑">
      <i class="fa fa-chevron-left"></i> wsl图形化界面安装踩坑
    </a></div>
      <div class="post-nav-item">
    <a href="/2025/01/13/%E8%BD%AC%E8%BD%BD%E7%9A%84pwntools%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/" rel="next" title="[转载文章]菜鸟笔记之pwn工具篇--pwntools库的基本使用">
      [转载文章]菜鸟笔记之pwn工具篇--pwntools库的基本使用 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#set-register"><span class="nav-number">1.</span> <span class="nav-text">set-register</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set-multiple-registers"><span class="nav-number">2.</span> <span class="nav-text">set-multiple-registers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#add-to-register"><span class="nav-number">3.</span> <span class="nav-text">add-to-register</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#linear-equation-registers"><span class="nav-number">4.</span> <span class="nav-text">linear-equation-registers</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#integer-division"><span class="nav-number">5.</span> <span class="nav-text">integer-division</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#module-opretion"><span class="nav-number">6.</span> <span class="nav-text">module-opretion</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#set-upper-byte"><span class="nav-number">7.</span> <span class="nav-text">set-upper-byte</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#efficient-modulo"><span class="nav-number">8.</span> <span class="nav-text">efficient-modulo</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#byte-extraction"><span class="nav-number">9.</span> <span class="nav-text">byte-extraction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#bitwise-and"><span class="nav-number">10.</span> <span class="nav-text">bitwise-and</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#check-even"><span class="nav-number">11.</span> <span class="nav-text">check-even</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#memory-read"><span class="nav-number">12.</span> <span class="nav-text">memory-read</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#memory-write"><span class="nav-number">13.</span> <span class="nav-text">memory-write</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#memory-increment"><span class="nav-number">14.</span> <span class="nav-text">memory-increment</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#byte-access"><span class="nav-number">15.</span> <span class="nav-text">byte-access</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#memory-size-access"><span class="nav-number">16.</span> <span class="nav-text">memory-size-access</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#little-endian-write"><span class="nav-number">17.</span> <span class="nav-text">little-endian-write</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#memory-sum"><span class="nav-number">18.</span> <span class="nav-text">memory-sum</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#stack-subtraction"><span class="nav-number">19.</span> <span class="nav-text">stack-subtraction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#swap-satck-values"><span class="nav-number">20.</span> <span class="nav-text">swap-satck-values</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#average-stack-values"><span class="nav-number">21.</span> <span class="nav-text">average-stack-values</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#abusolute-jump"><span class="nav-number">22.</span> <span class="nav-text">abusolute-jump</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#relative-jump"><span class="nav-number">23.</span> <span class="nav-text">relative-jump</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#jump-trampoline"><span class="nav-number">24.</span> <span class="nav-text">jump-trampoline</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#conditional-jump"><span class="nav-number">25.</span> <span class="nav-text">conditional-jump</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#indirect-jump"><span class="nav-number">26.</span> <span class="nav-text">indirect-jump</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#average-loop"><span class="nav-number">27.</span> <span class="nav-text">average-loop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#count-non-zero"><span class="nav-number">28.</span> <span class="nav-text">count-non-zero</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string-lower"><span class="nav-number">29.</span> <span class="nav-text">string-lower</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#most-common-byte"><span class="nav-number">30.</span> <span class="nav-text">most-common-byte</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="AAAFORGE"
      src="/images/1312386.jpeg">
  <p class="site-author-name" itemprop="name">AAAFORGE</p>
  <div class="site-description" itemprop="description">此情可待成追忆，只是当时已惘然</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:g2420844892@gmail.com" title="E-Mail → mailto:g2420844892@gmail.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>
        <div class="back-to-top motion-element">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">AAAFORGE</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

<div class="theme-info">
  <div class="powered-by"></div>
  <span class="post-count">本博客全站共64.1k字</span>
</div>


        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script size="300" alpha="0.6" zIndex="-1" src="/lib/canvas-ribbon/canvas-ribbon.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="//cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_sphere.min.js"></script>


  




  
<script src="/js/local-search.js"></script>











<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'neutral',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
          load: ['[tex]/mhchem'],
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
          packages: {'[+]': ['mhchem']},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
