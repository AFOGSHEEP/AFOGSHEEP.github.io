<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>杜鹃声</title>
    <link>http://midnightr3d.top/</link>
    
    <atom:link href="http://midnightr3d.top/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>此情可待成追忆，只是当时已惘然</description>
    <pubDate>Fri, 17 Jan 2025 17:10:13 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>embryogdb-襁褓中的调试</title>
      <link>http://midnightr3d.top/2025/01/17/embryogdb%20record/</link>
      <guid>http://midnightr3d.top/2025/01/17/embryogdb%20record/</guid>
      <pubDate>Fri, 17 Jan 2025 15:37:45 GMT</pubDate>
      
        
        
      <description>&lt;h2 id=&quot;level6&quot;&gt;level6&lt;/h2&gt;
&lt;p&gt;主要提下level6和level8，前者是靠&lt;code&gt;call (void)win()&lt;/code&gt;水过的，后者是花了比较多的精力才理解&lt;/p&gt;
&lt;p&gt;You can modify the state of yo</description>
        
      
      
      
      <content:encoded><![CDATA[<h2 id="level6">level6</h2><p>主要提下level6和level8，前者是靠<code>call (void)win()</code>水过的，后者是花了比较多的精力才理解</p><p>You can modify the state of your target program with the<code>set</code> command. For example, you can use<code>set $rdi = 0</code> to zero out $rdi. You can use<code>set *((uint64_t *) $rsp) = 0x1234</code> to set the first value onthe stack to 0x1234. You can use<code>set *((uint16_t *) 0x31337000) = 0x1337</code> to set 2 bytes at0x31337000 to 0x1337.</p><p>Suppose your target is some networked application which reads fromsome socket on fd 42. Maybe it would be easier for the purposes of youranalysis if the target instead read from stdin. You could achievesomething like that with the following gdb script:</p><p>start catch syscall read commands silent if ($rdi == 42) set $rdi = 0end continue end continue</p><p>This example gdb script demonstrates how you can automatically breakon system calls, and how you can use conditions within your commands toconditionally perform gdb commands.</p><p>In the previous level, your gdb scripting solution likely stillrequired you to copy and paste your solutions. This time, try to write ascript that doesn't require you to ever talk to the program, and insteadautomatically solves each challenge by correctly modifying registers /memory.</p><p>level5是通过实时在终端中打印出对应位置的随机值，再手动输入；这题更进一步，要求脚本自动给随机值找到并输入。</p><p>在卡了几天后参考这位师傅的博客找到了解决方案：<code>[Debugging Refresher](https://j-shiro.github.io/p/debugging-refresher/)</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0x00005798218a7d0b in main ()</span><br><span class="line">(gdb) x/16i $rip</span><br><span class="line">=&gt; 0x5798218a7d0b &lt;main+613&gt;:   lea    0xbfd(%rip),%rdi        # 0x5798218a890f</span><br><span class="line">   0x5798218a7d12 &lt;main+620&gt;:   mov    $0x0,%eax</span><br><span class="line">   0x5798218a7d17 &lt;main+625&gt;:   callq  0x5798218a7260 &lt;__isoc99_scanf@plt&gt;</span><br><span class="line">   0x5798218a7d1c &lt;main+630&gt;:   mov    -0x10(%rbp),%rax</span><br><span class="line">   0x5798218a7d20 &lt;main+634&gt;:   mov    %rax,%rsi</span><br><span class="line">   0x5798218a7d23 &lt;main+637&gt;:   lea    0xbea(%rip),%rdi        # 0x5798218a8914</span><br><span class="line">   0x5798218a7d2a &lt;main+644&gt;:   mov    $0x0,%eax</span><br><span class="line">   0x5798218a7d2f &lt;main+649&gt;:   callq  0x5798218a71d0 &lt;printf@plt&gt;</span><br><span class="line">   0x5798218a7d34 &lt;main+654&gt;:   mov    -0x18(%rbp),%rax</span><br><span class="line">   0x5798218a7d38 &lt;main+658&gt;:   mov    %rax,%rsi</span><br><span class="line">   0x5798218a7d3b &lt;main+661&gt;:   lea    0xbe3(%rip),%rdi        # 0x5798218a8925</span><br><span class="line">   0x5798218a7d42 &lt;main+668&gt;:   mov    $0x0,%eax</span><br><span class="line">   0x5798218a7d47 &lt;main+673&gt;:   callq  0x5798218a71d0 &lt;printf@plt&gt;</span><br><span class="line">   0x5798218a7d4c &lt;main+678&gt;:   mov    -0x10(%rbp),%rdx</span><br><span class="line">   0x5798218a7d50 &lt;main+682&gt;:   mov    -0x18(%rbp),%rax</span><br><span class="line">   0x5798218a7d54 &lt;main+686&gt;:   cmp    %rax,%rdx</span><br></pre></td></tr></table></figure><p>运行22次空指令后能找到<code>cmp %rax,%rdx</code>,再运行一次就会发现要让函数往下走的要求就是要<code>rax</code>和<code>rdx</code>相等。脚本就很好写了.</p><p>在<code>main+686</code>中断并修改两个寄存器的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">start</span><br><span class="line">run</span><br><span class="line">break *main+686</span><br><span class="line">commands</span><br><span class="line">        silent</span><br><span class="line">        set $rdx = $rax</span><br><span class="line">        continue</span><br><span class="line">end</span><br><span class="line">continue</span><br></pre></td></tr></table></figure><p>然后最多运行64次<code>continue</code>就可以得到flag了</p><h2 id="level8">level8</h2><p>As we demonstrated in the previous level, gdb has FULL control overthe target process. Under normal circumstances, gdb running as yourregular user cannot attach to a privileged process. This is why gdbisn't a massive security issue which would allow you to just immediatelysolve all the levels. Nevertheless, gdb is still an extremely powerfultool.</p><p>Running within this elevated instance of gdb gives you elevatedcontrol over the entire system. To clearly demonstrate this, see whathappens when you run the command <code>call (void)win()</code>.</p><p>Note that this will <em>not</em> get you the flag (it seems that webroke the win function!), so you'll need to work a bit harder to getthis flag!</p><p>As it turns out, all of the levels other levels in module could besolved in this way.</p><p>GDB is very powerful!</p><p>当我们想要调用<code>win（）</code>函数时会发生什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">0x00005b9bc84e6b99 in main ()</span><br><span class="line">(gdb) call (void)win()</span><br><span class="line"></span><br><span class="line">Program received signal SIGSEGV, Segmentation fault.</span><br><span class="line">0x00005b9bc84e6969 in win ()</span><br><span class="line">The program being debugged was signaled while in a function called from GDB.</span><br><span class="line">GDB remains in the frame where the signal was received.</span><br><span class="line">To change this behavior use &quot;set unwindonsignal on&quot;.</span><br><span class="line">Evaluation of the expression containing the function</span><br><span class="line">(win) will be abandoned.</span><br><span class="line">When the function is done executing, GDB will silently stop.</span><br></pre></td></tr></table></figure><p>查看一下<code>win()</code>的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">   0x00005b9bc84e6951 &lt;+0&gt;:     endbr64 </span><br><span class="line">   0x00005b9bc84e6955 &lt;+4&gt;:     push   %rbp</span><br><span class="line">   0x00005b9bc84e6956 &lt;+5&gt;:     mov    %rsp,%rbp</span><br><span class="line">   0x00005b9bc84e6959 &lt;+8&gt;:     sub    $0x10,%rsp</span><br><span class="line">   0x00005b9bc84e695d &lt;+12&gt;:    movq   $0x0,-0x8(%rbp)</span><br><span class="line">   0x00005b9bc84e6965 &lt;+20&gt;:    mov    -0x8(%rbp),%rax</span><br><span class="line">=&gt; 0x00005b9bc84e6969 &lt;+24&gt;:    mov    (%rax),%eax</span><br><span class="line">   0x00005b9bc84e696b &lt;+26&gt;:    lea    0x1(%rax),%edx</span><br><span class="line">   0x00005b9bc84e696e &lt;+29&gt;:    mov    -0x8(%rbp),%rax</span><br><span class="line">   0x00005b9bc84e6972 &lt;+33&gt;:    mov    %edx,(%rax)</span><br><span class="line">   0x00005b9bc84e6974 &lt;+35&gt;:    lea    0x73e(%rip),%rdi        # 0x5b9bc84e70b9</span><br><span class="line">   0x00005b9bc84e697b &lt;+42&gt;:    callq  0x5b9bc84e6180 &lt;puts@plt&gt;</span><br><span class="line">   0x00005b9bc84e6980 &lt;+47&gt;:    mov    $0x0,%esi</span><br><span class="line">   0x00005b9bc84e6985 &lt;+52&gt;:    lea    0x749(%rip),%rdi        # 0x5b9bc84e70d5</span><br><span class="line">   0x00005b9bc84e698c &lt;+59&gt;:    mov    $0x0,%eax</span><br><span class="line">   0x00005b9bc84e6991 &lt;+64&gt;:    callq  0x5b9bc84e6240 &lt;open@plt&gt;</span><br><span class="line">   0x00005b9bc84e6996 &lt;+69&gt;:    mov    %eax,0x26a4(%rip)        # 0x5b9bc84e9040 &lt;flag_fd.5712&gt;</span><br><span class="line">   0x00005b9bc84e699c &lt;+75&gt;:    mov    0x269e(%rip),%eax        # 0x5b9bc84e9040 &lt;flag_fd.5712&gt;</span><br><span class="line">   0x00005b9bc84e69a2 &lt;+81&gt;:    test   %eax,%eax</span><br><span class="line">   0x00005b9bc84e69a4 &lt;+83&gt;:    jns    0x5b9bc84e69ef &lt;win+158&gt;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set $rip = 0x5bb43cb6b980 #实际上从win+35到win+47都行</span><br><span class="line">c</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="http://midnightr3d.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</category>
      
      <category domain="http://midnightr3d.top/tags/%E7%BD%91%E5%AE%89/">网安</category>
      
      
      <comments>http://midnightr3d.top/2025/01/17/embryogdb%20record/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>[转载文章]菜鸟笔记之pwn工具篇--pwntools库的基本使用</title>
      <link>http://midnightr3d.top/2025/01/13/%E8%BD%AC%E8%BD%BD%E7%9A%84pwntools%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</link>
      <guid>http://midnightr3d.top/2025/01/13/%E8%BD%AC%E8%BD%BD%E7%9A%84pwntools%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</guid>
      <pubDate>Mon, 13 Jan 2025 12:28:45 GMT</pubDate>
      
      <description>&lt;p&gt;==原文章链接：==&lt;code&gt;[菜鸟笔记之pwn工具篇--pwntools库的基本使用 - XiDP - 博客园](https://www.cnblogs.com/XiDP0/p/18445564)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&quot;啥是pwntools&quot;&gt;啥是pwntools?&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Pwntools&lt;/strong&gt; 是一个用于漏洞利用和二进制分析的
&lt;code&gt;Python 库&lt;/code&gt;，广泛应用于安全研究、渗透测试和竞争性编程（如
CTF，Capture The
Flag）它为用户提供了一套强大的工具和功能，以&lt;code&gt;简化与二进制文件的交互&lt;/code&gt;、&lt;code&gt;网络通信&lt;/code&gt;以及各种&lt;code&gt;常见任务的执行&lt;/code&gt;。</description>
      
      
      
      <content:encoded><![CDATA[<p>==原文章链接：==<code>[菜鸟笔记之pwn工具篇--pwntools库的基本使用 - XiDP - 博客园](https://www.cnblogs.com/XiDP0/p/18445564)</code></p><h2 id="啥是pwntools">啥是pwntools?</h2><p><strong>Pwntools</strong> 是一个用于漏洞利用和二进制分析的<code>Python 库</code>，广泛应用于安全研究、渗透测试和竞争性编程（如CTF，Capture TheFlag）它为用户提供了一套强大的工具和功能，以<code>简化与二进制文件的交互</code>、<code>网络通信</code>以及各种<code>常见任务的执行</code>。<span id="more"></span></p><p>简而言之，<code>pwntools</code>可以说是pwn手必备的工具，它帮助pwn手<code>连接远程服务器</code>，<code>发送信息</code>，<code>接收信息</code>，以及提供了很多工具来帮助pwn手快速攻克题目</p><h2 id="如何安装pwntools">如何安装pwntools?</h2><p>按照以下流程在python3中安装pwntools</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; apt-get update</span><br><span class="line">&gt;&gt;&gt; apt-get install python3 python3-pip python3-dev git libssl-dev libffi-dev build-essential</span><br><span class="line">&gt;&gt;&gt; python3 -m pip install --upgrade pip</span><br><span class="line">&gt;&gt;&gt; python3 -m pip install --upgrade pwntools</span><br></pre></td></tr></table></figure><h2 id="如何使用pwntools">如何使用pwntools?</h2><p>显然我们需要学会使用python,并在编写脚本的时候导入pwntools库</p><h3 id="导入pwntools">导入pwntools:</h3><p>这大概会是每一个pwn手的编写脚本时的第一句话</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> * <span class="comment">#使用from来导入pwntools模块</span></span><br></pre></td></tr></table></figure><h3 id="设置基本信息">设置基本信息:</h3><p>在打靶机前需要按照靶机的类型设置好基本信息,因为<code>pwntools</code>中很多工具需要依靠<code>contest</code>来自动选择类型，比如<code>shellcraft(用于生成shellcode代码的工具)</code>等<code>os</code>是靶机的系统类型一般就是<code>linux系统</code><code>arch</code>是指题目的架构,我们可以使用<code>checksec</code>工具来查看具体的架构，一般是<code>AMD64</code>或<code>i386</code><code>log_level</code>是指日志输出等级，可以设置为<code>debug</code>或者直接不设置删掉也行，设置为debug在脚本运行的时候会输出我们具体发送了什么信息，靶机反馈了什么信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;AMD64&#x27;</span>, log_level=<span class="string">&#x27;debug&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="连接远程靶机">连接远程靶机:</h3><p>在pwn(1.0.0)中曾经介绍过，我们启动靶机后会得到一个靶机地址，把靶机地址的前缀和端口分别输入在<code>remote</code>里面，<code>ip</code>用<code>''</code>包裹起来用逗号隔开<code>端口</code>，这样就实现了远程连接</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">用于连接远程服务器，并把连接到的进程命名为p，后续的函数都围绕这个p进程展开</span><br><span class="line">p = remote(<span class="string">&quot;ip&quot;</span>,port) </span><br><span class="line">比如:p = remote(<span class="string">&quot;node5.buuoj.cn&quot;</span>,<span class="number">5555</span>)</span><br></pre></td></tr></table></figure><p>当然偶尔也有题目需要用ssh来连接靶机的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">通过使用ssh来连接靶机</span><br><span class="line">p = ssh(host=<span class="string">&#x27;192.168.xx.xxx&#x27;</span>, user=<span class="string">&#x27;xidp&#x27;</span>, port=<span class="number">6666</span>, password=<span class="string">&#x27;88888888&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="本地调试">本地调试:</h3><p>在远程之前，我们可以在本地先进行一些测试,那么我们可以本地运行文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">本地调试程序,并且将进程命名为p</span><br><span class="line">p = process(<span class="string">&quot;文件名&quot;</span>)</span><br><span class="line">比如:p = process(<span class="string">&quot;./pwn&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="发送信息">发送信息:</h3><p>假设我们需要发送的是<code>payload</code>这个变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">**************************************************</span><br><span class="line">p.send(payload) <span class="comment"># 直接发送payload</span></span><br><span class="line">**************************************************</span><br><span class="line">p.sendline(payload) <span class="comment"># 发送payload，但是结尾会有一个\n</span></span><br><span class="line">**************************************************</span><br><span class="line">p.sendafter(<span class="string">&quot;string&quot;</span>, payload) <span class="comment"># 接收到 string (这里说的string可以替换成任何信息) 之后会发送payload，但是如果没有接收到string，那么就会导致脚本一直卡在这里不动</span></span><br><span class="line">**************************************************</span><br><span class="line">p.sendlineafer(<span class="string">&quot;string&quot;</span>, payload) <span class="comment"># 接收到 string 之后会发送payload 并且在payload最后添加\n</span></span><br></pre></td></tr></table></figure><p>一般常用的发送就这几种，此时可能会有一个疑问，<code>p.send</code> 和<code>p.sendline</code> 就差一个<code>\n</code>有什么区别?有区别，比如<code>gets()</code>和<code>scanf()</code>这类函数它们会以<code>\n</code>作为结束符号，如果我们没有发送<code>\n</code>,它们就会一直卡着等待输入，所以遇到这类输入函数就必须要用<code>p.sendline</code>来添加<code>\n</code>(当然如果我们手动在payload里面添加<code>\n</code>也OK)。遇到<code>read()</code>这类函数则使用<code>p.sendline</code>和<code>p.send</code>都可以.</p><p>那如果我们都使用<code>p.sendline</code>不就好了吗?NO，这并不好，比如我们遇到<code>read()</code>并且希望发送一些字符串比如<code>"flag"</code>,如果你用<code>p.send("flag")</code>那么没错你发送的是<code>flag</code>，计算机解析后是<code>\x67\x61\x6C\x66</code>，而如果你用的是<code>p.sendline("flag")</code>，则你发送的是<code>flag\n</code>,计算机解析后是<code>\x0a\x67\x61\x6C\x66</code>,这一点细节上的差距就可能导致我们的脚本无法打通，所以我们需要面对合适的函数使用合适的方法，后续我们将会继续讨论<code>read()、scanf()、fgets()和gets()</code>这类函数在输入的时候具体有什么区别</p><h3 id="接收信息">接收信息:</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">**************************************************</span><br><span class="line">p.recv(<span class="built_in">int</span>) 利用recv来接收返回的数据，并且可以控制接受到的字节数</span><br><span class="line">比如:p.recv(<span class="number">7</span>) =&gt; 系统输出<span class="string">&#x27;hello world&#x27;</span> =&gt; 我们会接受到<span class="string">&#x27;hello w&#x27;</span> </span><br><span class="line">**************************************************</span><br><span class="line">p.recvline(<span class="string">&#x27;string&#x27;</span>) 设置一个标识符，接收标识符所在的那一行</span><br><span class="line">比如:p.recvline(<span class="string">&#x27;O.o&#x27;</span>)</span><br><span class="line"><span class="comment">#系统输出:</span></span><br><span class="line">Hello World </span><br><span class="line">This <span class="keyword">is</span> a test. </span><br><span class="line">O.o This <span class="keyword">is</span> the target line. </span><br><span class="line">Goodbye.</span><br><span class="line"><span class="comment">#我们接收:</span></span><br><span class="line">O.o This <span class="keyword">is</span> the target line. </span><br><span class="line">**************************************************</span><br><span class="line">p.recvlines(N) 接收 N 行输出</span><br><span class="line">**************************************************</span><br><span class="line">p.recvuntil(<span class="string">&#x27;string&#x27;</span>) 可以指定接收到某一字符串的时候停止 ,还有第二个参数 drop，drop=<span class="literal">True</span>(默认为false) 表示丢弃设定的停止符号</span><br><span class="line">比如:p.recvuntil(<span class="string">&#x27;or&#x27;</span>) </span><br><span class="line"><span class="comment">#系统输出:</span></span><br><span class="line">hello world </span><br><span class="line"><span class="comment">#我们接收:</span></span><br><span class="line">hello wor  </span><br><span class="line">比如:a = io.recvuntil(<span class="string">&#x27;]&#x27;</span>, drop=<span class="literal">True</span>)</span><br><span class="line">就是一直获取到`]`符号出现就停止，并且不接收`]`符号</span><br><span class="line">**************************************************</span><br></pre></td></tr></table></figure><h3 id="传递到终端">传递到终端:</h3><p>大概是每个脚本的最后一句话</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p.interactive()</span><br><span class="line">接受信息并且在终端操作，程序拿到shell，然后就可以转接到linux终端上，让pwn手享受拿flag的乐趣</span><br></pre></td></tr></table></figure><h3 id="构造发送地址类型">构造发送地址类型:</h3><p><code>p64/p32/u64/u32</code>这类函数的作用:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">**************************************************</span><br><span class="line">p64(<span class="built_in">int</span>) </span><br><span class="line">p64(<span class="number">0xfaceb00c</span>) =&gt; <span class="string">&#x27;\x0c\xb0\xce\xfa\x00\x00\x00\x00\x00&#x27;</span></span><br><span class="line">**************************************************</span><br><span class="line">u64(<span class="built_in">str</span>) </span><br><span class="line">u64(<span class="string">&#x27;\x0c\xb0\xce\xfa\x00\x00\x00\x00&#x27;</span>) =&gt;<span class="number">0xfaceb00c</span></span><br><span class="line">**************************************************</span><br><span class="line">p32(<span class="built_in">int</span>)  </span><br><span class="line">p32(<span class="number">0xfaceb00c</span>) =&gt; <span class="string">&#x27;\x0c\xb0\xce\xfa&#x27;</span></span><br><span class="line">**************************************************</span><br><span class="line">u32(<span class="built_in">str</span>) </span><br><span class="line">u32(<span class="string">&#x27;\x0c\xb0\xce\xfa&#x27;</span>) =&gt; <span class="number">0xfaceb00c</span></span><br><span class="line">**************************************************</span><br></pre></td></tr></table></figure><p><code>p64()</code>这种类型用于将消息变成对应的进制流（因为原本程序里面的数据都是已经编译过的，所以打入的数据也需要是编译过的,所以需要使用p64()这类工具）<code>u64()</code>这种类型<code>用于泄露地址</code>的时候将泄露的进制流变成对应的原本的样子，方便来辨认查找glibc版本</p><p>因为一般计算机都是小端程序，所以这两个函数都自带有将数据变成小端需要的样子，如果遇到大端程序可能需要额外注意</p><p>除了<code>p32()</code>这种转化方式还有，<code>flat()</code>，它可以将多个数据结构（如字符串、整数等）连接在一起，并将它们转换为二进制数据。通常用于构建复杂的ROP链的<code>shellcode</code>。flat函数会将数据扁平化，将它们按照顺序连接在一起，不做任何其他处理。在提供的代码中，<code>flat</code>被用于构建一个包含多个元素的列表，然后将它们连接起来形成一个二进制数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">payload = flat([<span class="number">0x12345678</span>, <span class="string">&#x27;AAAA&#x27;</span>, <span class="number">0xdeadbeef</span>], word_size=<span class="number">4</span>/<span class="number">8</span>)</span><br></pre></td></tr></table></figure><h4 id="的汇编与反汇编">的汇编与反汇编:</h4><p>pwntools提供了两个工具:<code>asm</code>函数可以将汇编代码转为对应的二进制<code>disasm</code>函数则相反可以将二进制转化为汇编代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>asm(<span class="string">&#x27;mov eax, 0&#x27;</span>)   <span class="comment">#汇编</span></span><br><span class="line"><span class="string">&#x27;\xb8\x00\x00\x00\x00&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>disasm(<span class="string">&#x27;\xb8\x0b\x00\x00\x00&#x27;</span>)  <span class="comment">#反汇编</span></span><br><span class="line"><span class="string">&#x27;mov    eax,0xb&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="生成shllcode后门">生成shllcode后门:</h4><p><strong>pwnlib.shellcraft模块</strong>包含<strong>生成shell代码</strong>的函数。在使用之前我们需要通过<strong>context设置架构</strong>，然后<strong>生成shellcode</strong>也就是生成后门</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">context(os=<span class="string">&#x27;linux&#x27;</span>, arch=<span class="string">&#x27;i386&#x27;</span>)</span><br><span class="line"><span class="comment"># 表示将当前执行上下文的体系结构设置为i386(这里的i386可以通过checksec来查看文件是什么架构的  </span></span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line"><span class="comment"># asm()是把括号内的内容编译成机器码(只有机器码才可以执行)，一般用来打入后门。pwntools自带的后门函数，可以生成类似system(&#x27;/bin/sh/&#x27;)这样功能的汇编代码 </span></span><br><span class="line"><span class="comment"># 通常可以配合  .ljust() 来使用  </span></span><br><span class="line">shellcode.ljust(<span class="number">112</span>, <span class="string">b&#x27;A&#x27;</span>)  </span><br><span class="line"><span class="comment"># 这里的 .ljust() 是 Python 中字符串对象的方法，用于在字符串的右侧填充指定的字符，使字符串达到指定的长度。</span></span><br></pre></td></tr></table></figure><p>纯净版shellcode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context(arch=<span class="string">&#x27;i386&#x27;</span>, os=<span class="string">&#x27;linux&#x27;</span>)</span><br><span class="line">shellcode = asm(shellcraft.sh())</span><br><span class="line">shellcode.ljust(<span class="number">112</span>, <span class="string">b&#x27;A&#x27;</span>)  </span><br></pre></td></tr></table></figure><p>当然也有专门的网站收集shellcode shellcode的网址：https://www.exploit-db.com/shellcodes/43550下面也提供一些已经编译好的shellcode: 64位linux的24Byte的shellcode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shellcode_x64 =<span class="string">&quot;\x6a\x3b\x58\x99\x52\x48\xbb\x2f\x2f\x62\x69\x6e\x2f\x73\x68\x53\x54\x5f\x52\x57\x54\x5e\x0f\x05&quot;</span></span><br></pre></td></tr></table></figure><p>64位Linux的23Byte的shellcode</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shellcode_x64 =<span class="string">&quot;\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05&quot;</span></span><br></pre></td></tr></table></figure><p>更多的时候根据题目的要求，我们需要自己手动编写shellcode来绕过一些检测，所以编写<code>shellcode</code>是后续必须要掌握的一种技巧</p><p>运行时调用gdb调试: 使用<code>gdb.attach</code>函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gdb.attach(p, gdbscript=<span class="string">&quot;&quot;&quot; b main; commands; silent printf &quot;Breakpoint hit\n&quot;; continue; end &quot;&quot;&quot;</span>)</span><br><span class="line">在需要进行调试的位置插入gdb.attach(p)即可在执行到的时候打开gdb进行调试</span><br><span class="line">p是指定的需要调试的进程(必须要本地调试，否则会报错)</span><br><span class="line">gdbscript是打开gdb后需要进行的操作，使用 ; 进行隔离</span><br></pre></td></tr></table></figure><p>一般<code>gdb.attach(p)</code>可以和<code>pause()</code>函数连用，可以确保在gdb完全打开之前脚本不运行<code>pause()</code>函数用于暂停脚本的运行，直到用户输入任意数据</p><h4 id="elf模块">ELF模块:</h4><p>我们可以通过这个模块来快速获取pwn文件的<code>got表地址</code>以及<code>plt表地址</code>用于获取<code>ELF文件的信息</code>，首先使用<code>ELF()</code>获取这个文件的句柄，然后使用这个句柄调用函数，和IO模块很相似。下面演示了：获取基地址、获取函数地址（基于符号）、获取函数got地址、获取函数plt地址，和LibcSearcher库联动使用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">elf = ELF(<span class="string">&#x27;./pwn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">elf.address <span class="comment"># 文件装载的基地址 =&gt; 0x400000</span></span><br><span class="line"></span><br><span class="line">main_addr = elf.symbols[<span class="string">&#x27;main&#x27;</span>] <span class="comment"># 获取函数地址 =&gt; 0x401680</span></span><br><span class="line"></span><br><span class="line">write_got = elf.got[<span class="string">&#x27;write&#x27;</span>] <span class="comment"># 获取对应函数在GOT表的地址 =&gt; 0x60b070</span></span><br><span class="line"></span><br><span class="line">write_plt = elf.plt[<span class="string">&#x27;write&#x27;</span>] <span class="comment"># 获取对应函数在PLT表的地址 =&gt; 0x401680</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="http://midnightr3d.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</category>
      
      <category domain="http://midnightr3d.top/tags/%E7%BD%91%E5%AE%89/">网安</category>
      
      <category domain="http://midnightr3d.top/tags/%E8%BD%AC%E8%BD%BD/">转载</category>
      
      
      <comments>http://midnightr3d.top/2025/01/13/%E8%BD%AC%E8%BD%BD%E7%9A%84pwntools%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Assembly Crash Course record</title>
      <link>http://midnightr3d.top/2025/01/09/Assembly%20Crash%20Course%20record/</link>
      <guid>http://midnightr3d.top/2025/01/09/Assembly%20Crash%20Course%20record/</guid>
      <pubDate>Thu, 09 Jan 2025 08:16:48 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;set-register&quot;&gt;set-register&lt;/h2&gt;
&lt;p&gt;题目要求：&lt;/p&gt;
&lt;p&gt;In this level, you will be working with registers. You will be asked
to modify or read from registers.&lt;/p&gt;
&lt;p&gt;In this level, you will work with registers! Please set the
following:</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="set-register">set-register</h2><p>题目要求：</p><p>In this level, you will be working with registers. You will be askedto modify or read from registers.</p><p>In this level, you will work with registers! Please set thefollowing: <span id="more"></span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rdi = 0x1337</span><br></pre></td></tr></table></figure><p>似乎很简单，要求我们将 rdi 的值设置成<code>0x1337</code>，但是会得到</p><p>=="WARNING: It looks like your input might not be assembled binarycode, but assembly source code. This challenge needs the raw binaryassembled code as input."==</p><p>程序并不能理解我们输入的汇编代码，所以我们要使用 pwntools的工具来构造机器码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch=<span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p=process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line">p.recvline()<span class="comment">#这行代码从进程 p 中接收一行数据。它会读取数据直到遇到换行符##（\n），然后返回这一行的内容。默认情况下，recvline() 会保留行尾的换行符。在这里，它用于读取目标程序输出的第一行数据，可能是程序的提示信息或其他初始输出，以便知#道程序已经准备好接收后续的输入。</span></span><br><span class="line">p.send(asm(<span class="string">&#x27;mov rdi,0x1337&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(p.readallS())<span class="comment">#首先调用 p.readall() 函数，读取进程 p 的所有剩余输出直到进程结束。它会阻塞当前线程，直到目标进程关闭其输出流。并自动转换成字符串，之后用print()输出</span></span><br></pre></td></tr></table></figure><p>得到<code>flag:pwn.college&#123;QRxMx73Zr7Op3kSe-GPyic6TjdY.0FN5EDL4EDOxYzW&#125;</code></p><h2 id="set-multiple-registers">set-multiple-registers</h2><p>In this level, you will be working with registers. You will be askedto modify or read from registers.</p><p>In this level, you will work with multiple registers. Please set thefollowing:</p><ul><li><code>rax = 0x1337</code></li><li><code>r12 = 0xCAFED00D1337BEEF</code></li><li><code>rsp = 0x31337</code></li></ul><p>类似的题目，从设置一个寄存器变为了设置多个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rax ,0x1337</span></span><br><span class="line"><span class="string">mov r12 ,0xCAFED00D1337BEEF</span></span><br><span class="line"><span class="string">mov rsp ,0x31337</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(p.recvall())</span><br></pre></td></tr></table></figure><h2 id="add-to-register">add-to-register</h2><p>In this level, you will be working with registers. You will be askedto modify or read from registers.</p><p>We will set some values in memory dynamically before each run. Oneach run, the values will change. This means you will need to performsome formulaic operation with registers. We will tell you whichregisters are set beforehand and where you should put the result. Inmost cases, it's <code>rax</code>.</p><p>Many instructions exist in x86 that allow you to perform all thenormal math operations on registers and memory.</p><p>For shorthand, when we say <code>A += B</code>, it really means<code>A = A + B</code>.</p><p>Here are some useful instructions:</p><ul><li><code>add reg1, reg2</code> &lt;=&gt; <code>reg1 += reg2</code></li><li><code>sub reg1, reg2</code> &lt;=&gt; <code>reg1 -= reg2</code></li><li><code>imul reg1, reg2</code> &lt;=&gt;<code>reg1 *= reg2</code></li></ul><p><code>div</code> is more complicated, and we will discuss it later.Note: all <code>regX</code> can be replaced by a constant or memorylocation.</p><p>Do the following:</p><ul><li>Add <code>0x331337</code> to <code>rdi</code></li></ul><p>要求对寄存器进行加法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    add rdi, 0x331337&#x27;&#x27;&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(p.recvallS())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>得到<code>flag:pwn.college&#123;oQeaHikpX98CEqAk6biPBYRAxUc.0VN5EDL4EDOxYzW&#125;</code></p><h2 id="linear-equation-registers">linear-equation-registers</h2><p>In this level, you will be working with registers. You will be askedto modify or read from registers.</p><p>We will now set some values in memory dynamically before each run. Oneach run, the values will change. This means you will need to do sometype of formulaic operation with registers. We will tell you whichregisters are set beforehand and where you should put the result. Inmost cases, it's <code>rax</code>.</p><p>Using your new knowledge, please compute the following:</p><ul><li>``` f(x) = mx + b <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  , where:</span><br><span class="line"></span><br><span class="line">  - `m = rdi`</span><br><span class="line">  - `x = rsi`</span><br><span class="line">  - `b = rdx`</span><br><span class="line"></span><br><span class="line">Place the result into `rax`.</span><br><span class="line"></span><br><span class="line">Note: There is an important difference between `mul` (unsigned multiply) and `imul` (signed multiply) in terms of which registers are used. Look at the documentation on these instructions to see the difference.</span><br><span class="line"></span><br><span class="line">In this case, you will want to use `imul`.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">练习一下乘法</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">from pwn import *</span><br><span class="line">context.arch = &#x27;amd64&#x27;</span><br><span class="line">p= process(&quot;/challenge/run&quot;)</span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(&#x27;&#x27;&#x27;</span><br><span class="line">xor rax,rax#初始化寄存器</span><br><span class="line">imul rdi,rsi</span><br><span class="line">mov rax,rdx</span><br><span class="line">add rax,rdi</span><br><span class="line">&#x27;&#x27;&#x27;))</span><br><span class="line">print(p.recvall())</span><br></pre></td></tr></table></figure></li></ul><p>获取答案。后面还是不要直接写出 flag 了。</p><h2 id="integer-division">integer-division</h2><p>Division in x86 is more special than in normal math. Math here iscalled integer math, meaning every value is a whole number.</p><p>As an example: <code>10 / 3 = 3</code> in integer math.</p><p>Why?</p><p>Because <code>3.33</code> is rounded down to an integer.</p><p>The relevant instructions for this level are:</p><ul><li><code>mov rax, reg1</code></li><li><code>div reg2</code></li></ul><p>Note: <code>div</code> is a special instruction that can divide a128-bit dividend by a 64-bit divisor while storing both the quotient andthe remainder, using only one register as an operand.</p><p>How does this complex <code>div</code> instruction work and operateon a 128-bit dividend (which is twice as large as a register)?</p><p>For the instruction <code>div reg</code>, the following happens:</p><ul><li><code>rax = rdx:rax / reg</code></li><li><code>rdx = remainder</code></li></ul><p><code>rdx:rax</code> means that <code>rdx</code> will be the upper64-bits of the 128-bit dividend and <code>rax</code> will be the lower64-bits of the 128-bit dividend.</p><p>You must be careful about what is in <code>rdx</code> and<code>rax</code> before you call <code>div</code>.</p><p>Please compute the following:</p><ul><li>``` speed = distance / time <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  , where:</span><br><span class="line"></span><br><span class="line">  - `distance = rdi`</span><br><span class="line">  - `time = rsi`</span><br><span class="line">  - `speed = rax`</span><br><span class="line"></span><br><span class="line">Note that distance will be at most a 64-bit value, so `rdx` should be 0 when dividing.</span><br><span class="line"></span><br><span class="line">在 x86 汇编中，`div` 指令用于执行整数除法，它可以将一个 128 位的被除数除以一个 64 位的除数，并同时存储商和余数。这个指令的特殊之处在于它使用了两个寄存器来表示被除数：`rdx` 和 `rax`。其中，`rdx` 存储被除数的高 64 位，而 `rax` 存储被除数的低 64 位。</span><br><span class="line"></span><br><span class="line">在执行 `div reg` 指令时，以下操作会发生：</span><br><span class="line"></span><br><span class="line">1. `rax` 寄存器将被设置为 `rdx:rax`（即由 `rdx` 和 `rax` 组成的 128 位数）除以 `reg` 的商。</span><br><span class="line">2. `rdx` 寄存器将被设置为除法的余数。</span><br><span class="line"></span><br><span class="line">接下来就是练习除法</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">from pwn import *</span><br><span class="line">context.arch = &#x27;amd64&#x27;</span><br><span class="line">p= process(&quot;/challenge/run&quot;)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(asm(&#x27;&#x27;&#x27;</span><br><span class="line">    mov rax,rdi</span><br><span class="line">    xor rdx,rdx</span><br><span class="line">    div rsi</span><br><span class="line">&#x27;&#x27;&#x27;))</span><br><span class="line">print(p.recvall())</span><br></pre></td></tr></table></figure></li></ul><h2 id="module-opretion">module-opretion</h2><p>Modulo in assembly is another interesting concept!</p><p>x86 allows you to get the remainder after a <code>div</code>operation.</p><p>For instance: <code>10 / 3</code> results in a remainder of<code>1</code>.</p><p>The remainder is the same as modulo, which is also called the "mod"operator.</p><p>In most programming languages, we refer to mod with the symbol<code>%</code>.</p><p>Please compute the following: <code>rdi % rsi</code></p><p>Place the value in <code>rax</code>.</p><p>关于模的运算。但是 x86 没有直接求模的运算。所以需要手动算一下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p= process(<span class="string">&quot;/challenge/run&quot;</span>)</span><br><span class="line">p.recv()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">xor rdx,rdx</span></span><br><span class="line"><span class="string">mov rax,rdi</span></span><br><span class="line"><span class="string">div rsi</span></span><br><span class="line"><span class="string">xor rax,rax</span></span><br><span class="line"><span class="string">mov rax,rdx</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(p.recvall())</span><br></pre></td></tr></table></figure><p>记得寄存器用前要清零，还有就是一般用 <code>rax</code>作为函数返还数值的寄存器。</p><h2 id="set-upper-byte">set-upper-byte</h2><p>Another cool concept in x86 is the ability to independently accessthe lower register bytes.</p><p>Each register in x86_64 is 64 bits in size, and in the previouslevels, we have accessed the full register using <code>rax</code>,<code>rdi</code>, or <code>rsi</code>.</p><p>We can also access the lower bytes of each register using differentregister names.</p><p>For example, the lower 32 bits of <code>rax</code> can be accessedusing <code>eax</code>, the lower 16 bits using <code>ax</code>, and thelower 8 bits using <code>al</code>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">MSB                                    LSB</span><br><span class="line">+----------------------------------------+</span><br><span class="line">|                   rax                  |</span><br><span class="line">+--------------------+-------------------+</span><br><span class="line">                     |        eax        |</span><br><span class="line">                     +---------+---------+</span><br><span class="line">                               |   ax    |</span><br><span class="line">                               +----+----+</span><br><span class="line">                               | ah | al |</span><br><span class="line">                               +----+----+</span><br></pre></td></tr></table></figure><p>Lower register bytes access is applicable to almost allregisters.</p><p>Using only one move instruction, please set the upper 8 bits of the<code>ax</code> register to <code>0x42</code>.</p><p>介绍了 <code>x86</code>架构中寄存器的特性——寄存器可以被划分为不同的部分，以便可以单独访问其部分位。这种设计允许程序员更灵活地处理数据，尤其是在需要对数据的特定部分进行操作时。</p><p>以 <code>rax</code> 寄存器为例，它是一个 64位的寄存器，可以被分为不同的部分：</p><ul><li><code>rax</code>：整个 64 位寄存器。</li><li><code>eax</code>：<code>rax</code> 的低 32 位。</li><li><code>ax</code>：<code>eax</code> 的低 16 位。</li><li><code>al</code>：<code>ax</code> 的低 8 位。</li><li><code>ah</code>：<code>ax</code> 的高 8 位。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov ah,0x42</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(output)  </span><br></pre></td></tr></table></figure><p>补充:</p><p>MSB 和 LSB 是位的两种称呼：</p><ul><li><strong>MSB (Most SignificantBit)</strong>：最高有效位。在二进制数中，MSB是位于最左侧的位，具有最大的数值权重。例如，在一个 8 位的二进制数<code>10110101</code> 中，最左边的 <code>1</code> 就是 MSB，它代表了<code>2^7</code> 的权重。</li><li><strong>LSB (Least SignificantBit)</strong>：最低有效位。在二进制数中，LSB是位于最右侧的位，具有最小的数值权重。例如，在同一个 8 位的二进制数<code>10110101</code> 中，最右边的 <code>1</code> 就是 LSB，它代表了<code>2^0</code> 的权重。</li></ul><p>常用寄存器</p><table><colgroup><col style="width: 21%" /><col style="width: 13%" /><col style="width: 13%" /><col style="width: 13%" /><col style="width: 19%" /><col style="width: 19%" /></colgroup><thead><tr><th>x64 调用约定</th><th>64 位寄存器</th><th>32 位寄存器</th><th>16 位寄存器</th><th>8 位寄存器（低）</th><th>8 位寄存器（高）</th></tr></thead><tbody><tr><td>函数返回值</td><td>rax</td><td>eax</td><td>ax</td><td>al</td><td>al</td></tr><tr><td></td><td>rbx</td><td>ebx</td><td>bx</td><td>bl</td><td>bl</td></tr><tr><td>第四个参数</td><td>rcx</td><td>ecb</td><td>cx</td><td>cl</td><td>cl</td></tr><tr><td>第三个参数</td><td>rdx</td><td>edx</td><td>dx</td><td>dl</td><td>dl</td></tr><tr><td>第一个参数</td><td>rdi</td><td>edi</td><td>di</td><td>dil</td><td></td></tr><tr><td>第二个参数</td><td>rsi</td><td>esi</td><td>si</td><td>sil</td><td></td></tr><tr><td>下一条指令的地址</td><td>rip</td><td>eip</td><td>ip</td><td></td><td></td></tr><tr><td>栈底指针</td><td>rbp</td><td>ebp</td><td>bp</td><td>bpl</td><td></td></tr><tr><td>栈顶指针</td><td>rsp</td><td>esp</td><td>sp</td><td>spl</td><td></td></tr><tr><td>第五个参数</td><td>r8</td><td>r8d</td><td>r8w</td><td>r8b</td><td></td></tr><tr><td>第六个参数</td><td>r9</td><td>r9d</td><td>r9w</td><td>r9b</td><td></td></tr></tbody></table><h2 id="efficient-modulo">efficient-modulo</h2><p>It turns out that using the <code>div</code> operator to compute themodulo operation is slow!</p><p>We can use a math trick to optimize the modulo operator(<code>%</code>). Compilers use this trick a lot.</p><p>If we have <code>x % y</code>, and <code>y</code> is a power of 2,such as <code>2^n</code>, the result will be the lower <code>n</code>bits of <code>x</code>.</p><p>Therefore, we can use the lower register byte access to efficientlyimplement modulo!</p><p>Using only the following instruction(s):</p><ul><li><code>mov</code></li></ul><p>Please compute the following:</p><ul><li><code>rax = rdi % 256</code></li><li><code>rbx = rsi % 65536</code></li></ul><p>如何使用寄存器的低位字节来高效地实现模运算？不难发现，当模数是 2的幂时，例如 2^n，模数就是低 n位，也就是说可以通过直接取寄存器的低位字节来得到模运算的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov al, dil</span></span><br><span class="line"><span class="string">    mov bx, si</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br></pre></td></tr></table></figure><h2 id="byte-extraction">byte-extraction</h2><p>Shifting bits around in assembly is another interesting concept!</p><p>x86 allows you to 'shift' bits around in a register.</p><p>Take, for instance, <code>al</code>, the lowest 8 bits of<code>rax</code>.</p><p>The value in <code>al</code> (in bits) is:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rax = 10001010</span><br></pre></td></tr></table></figure><p>If we shift once to the left using the <code>shl</code>instruction:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shl al, 1</span><br></pre></td></tr></table></figure><p>The new value is:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">al = 00010100</span><br></pre></td></tr></table></figure><p>Everything shifted to the left, and the highest bit fell off while anew 0 was added to the right side.</p><p>You can use this to do special things to the bits you care about.</p><p>Shifting has the nice side effect of doing quick multiplication (by2) or division (by 2), and can also be used to compute modulo.</p><p>Here are the important instructions:</p><ul><li><code>shl reg1, reg2</code> &lt;=&gt; Shift <code>reg1</code> leftby the amount in <code>reg2</code></li><li><code>shr reg1, reg2</code> &lt;=&gt; Shift <code>reg1</code> rightby the amount in <code>reg2</code></li></ul><p>Note: 'reg2' can be replaced by a constant or memory location.</p><p>Using only the following instructions:</p><ul><li><code>mov</code>, <code>shr</code>, <code>shl</code></li></ul><p>Please perform the following: Set <code>rax</code> to the 5th leastsignificant byte of <code>rdi</code>.</p><p>For example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">rdi = | B7 | B6 | B5 | B4 | B3 | B2 | B1 | B0 |</span><br><span class="line">Set rax to the value of B4</span><br></pre></td></tr></table></figure><p>移位时最高位遗弃，填充最低位置零。<code>shl rax, rbx</code> 意思是rax 左移 rbx 的值，rbx 为 8 则左移 8 位。</p><p>当一个寄存器的高位都是 0时，读取的数值实际上就是其最低有效位（LSB）部分的值。这是因为高位的 0对数值没有贡献。</p><p>例如，假设有一个 64 位寄存器，其值为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">00000000000000000000000000000000000000000000000000000000001010</span><br></pre></td></tr></table></figure><p>这个寄存器的值实际上是 10（十进制），因为只有最低的 4位是有效的（<code>1010</code> 表示的是 10）。高位的 0并不影响最终的数值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    shl rdi,24</span></span><br><span class="line"><span class="string">    shr rdi,56</span></span><br><span class="line"><span class="string">    mov rax,rdi&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br></pre></td></tr></table></figure><h2 id="bitwise-and">bitwise-and</h2><p>In this level, you will be working with bit logic and operations.This will involve heavy use of directly interacting with bits stored ina register or memory location. You will also likely need to make use ofthe logic instructions in x86: <code>and</code>, <code>or</code>,<code>not</code>, <code>xor</code>.</p><p>Bitwise logic in assembly is yet another interesting concept! x86allows you to perform logic operations bit by bit on registers.</p><p>For the sake of this example, say registers only store 8 bits.</p><p>The values in <code>rax</code> and <code>rbx</code> are:</p><ul><li><code>rax = 10101010</code></li><li><code>rbx = 00110011</code></li></ul><p>If we were to perform a bitwise AND of <code>rax</code> and<code>rbx</code> using the <code>and rax, rbx</code> instruction, theresult would be calculated by ANDing each bit pair one by one, hence whyit's called bitwise logic.</p><p>So from left to right:</p><ul><li>1 AND 0 = 0</li><li>0 AND 0 = 0</li><li>1 AND 1 = 1</li><li>0 AND 1 = 0</li><li>...</li></ul><p>Finally, we combine the results together to get:</p><ul><li><code>rax = 00100010</code></li></ul><p>Without using the following instructions: <code>mov</code>,<code>xchg</code>, please perform the following:</p><p>Set <code>rax</code> to the value of <code>(rdi AND rsi)</code></p><p>学习 <code>x86</code> 中的逻辑运算符，此处是 <code>and</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    xor rax,rax</span></span><br><span class="line"><span class="string">    and rdi,rsi</span></span><br><span class="line"><span class="string">    add rax,rdi#题目要求不能直接用mov,那就先初始化后加上</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="check-even">check-even</h2><p>In this level, you will be working with bit logic and operations.This will involve heavy use of directly interacting with bits stored ina register or memory location. You will also likely need to make use ofthe logic instructions in x86: <code>and</code>, <code>or</code>,<code>not</code>, <code>xor</code>.</p><p>Using only the following instructions:</p><ul><li><code>and</code></li><li><code>or</code></li><li><code>xor</code></li></ul><p>Implement the following logic:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if x is even then</span><br><span class="line">  y = 1</span><br><span class="line">else</span><br><span class="line">  y = 0</span><br></pre></td></tr></table></figure><p>Where:</p><ul><li><code>x = rdi</code></li><li><code>y = rax</code></li></ul><p>经典的判断奇偶性，但是 <code>x86</code> 只用逻辑运算符</p><p>二进制下的数字的奇偶性由最低位的那个 <code>1</code>来决定，因为其他位置的变化都是在十进制下增减 <code>2</code> 的倍数。</p><p>故先用 <code>add</code>运算来提取出最低位的数字，题目要求正好和当前结果相反，用<code>xor</code> 来获得相对的数。最后把这个数字打入清零后的<code>rax</code> 即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"></span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    and rdi,1</span></span><br><span class="line"><span class="string">    xor rdi,1</span></span><br><span class="line"><span class="string">    xor rax,rax</span></span><br><span class="line"><span class="string">    or rax,rdi</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">          ))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="memory-read">memory-read</h2><p>Recall that memory can be addressed, and each address containssomething at that location. Note that this is similar to addresses inreal life!</p><p>As an example: the real address '699 S Mill Ave, Tempe, AZ 85281'maps to the 'ASU Brickyard'. We would also say it points to 'ASUBrickyard'. We can represent this like:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#x27;699 S Mill Ave, Tempe, AZ 85281&#x27;] = &#x27;ASU Brickyard&#x27;</span><br></pre></td></tr></table></figure><p>The address is special because it is unique. But that also does notmean other addresses can't point to the same thing (as someone can havemultiple houses).</p><p>Memory is exactly the same!</p><p>For instance, the address in memory where your code is stored (whenwe take it from you) is <code>0x400000</code>.</p><p>In x86, we can access the thing at a memory location, calleddereferencing, like so:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [some_address]        &lt;=&gt;     Moves the thing at &#x27;some_address&#x27; into rax</span><br></pre></td></tr></table></figure><p>This also works with things in registers:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [rdi]         &lt;=&gt;     Moves the thing stored at the address of what rdi holds to rax</span><br></pre></td></tr></table></figure><p>This works the same for writing to memory:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov [rax], rdi         &lt;=&gt;     Moves rdi to the address of what rax holds.</span><br></pre></td></tr></table></figure><p>So if <code>rax</code> was <code>0xdeadbeef</code>, then<code>rdi</code> would get stored at the address<code>0xdeadbeef</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0xdeadbeef] = rdi</span><br></pre></td></tr></table></figure><p>Note: Memory is linear, and in x86_64, it goes from <code>0</code> to<code>0xffffffffffffffff</code> (yes, huge).</p><p>Please perform the following: Place the value stored at<code>0x404000</code> into <code>rax</code>. Make sure the value in<code>rax</code> is the original value stored at<code>0x404000</code>.</p><p>类似上个模块里的练习，不过这次得通过 <code>pwntools</code>给的渠道而不是直接运行汇编代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax,[0x404000]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="memory-write">memory-write</h2><p>In this level, you will be working with memory. This will require youto read or write to things stored linearly in memory. If you areconfused, go look at the linear addressing module in 'ike. You may alsobe asked to dereference things, possibly multiple times, to things wedynamically put in memory for your use.</p><p>Please perform the following: Place the value stored in<code>rax</code> to <code>0x404000</code>.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov [0x404000],rax</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="memory-increment">memory-increment</h2><p>In this level, you will be working with memory. This will require youto read or write to things stored linearly in memory. If you areconfused, go look at the linear addressing module in 'ike. You may alsobe asked to dereference things, possibly multiple times, to things wedynamically put in memory for your use.</p><p>Please perform the following:</p><ul><li>Place the value stored at <code>0x404000</code> into<code>rax</code>.</li><li>Increment the value stored at the address <code>0x404000</code> by<code>0x1337</code>.</li></ul><p>Make sure the value in <code>rax</code> is the original value storedat <code>0x404000</code> and make sure that <code>[0x404000]</code> nowhas the incremented value.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax,[0x404000]</span></span><br><span class="line"><span class="string">    mov rsi,0x1337</span></span><br><span class="line"><span class="string">    add [0x404000],rsi</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>记得灵活运用可以调用的寄存器</p><p>更多相关信息参考==<strong>汇编的寻址模式和过程调用约定</strong>==</p><h2 id="byte-access">byte-access</h2><p>Recall that registers in x86_64 are 64 bits wide, meaning they canstore 64 bits. Similarly, each memory location can be treated as a64-bit value. We refer to something that is 64 bits (8 bytes) as a quadword.</p><p>Here is the breakdown of the names of memory sizes:</p><ul><li>Quad Word = 8 Bytes = 64 bits</li><li>Double Word = 4 bytes = 32 bits</li><li>Word = 2 bytes = 16 bits</li><li>Byte = 1 byte = 8 bits</li></ul><p>In x86_64, you can access each of these sizes when dereferencing anaddress, just like using bigger or smaller register accesses:</p><ul><li><code>mov al, [address]</code> &lt;=&gt; moves the least significantbyte from address to <code>rax</code></li><li><code>mov ax, [address]</code> &lt;=&gt; moves the least significantword from address to <code>rax</code></li><li><code>mov eax, [address]</code> &lt;=&gt; moves the leastsignificant double word from address to <code>rax</code></li><li><code>mov rax, [address]</code> &lt;=&gt; moves the full quad wordfrom address to <code>rax</code></li></ul><p>Remember that moving into <code>al</code> does not fully clear theupper bytes.</p><p>Please perform the following: Set <code>rax</code> to the byte at<code>0x404000</code>.</p><p><span style="font-family:serif;"><strong>四字 = 8 字节 =64bits</strong></span> <span style="font-family:serif;"><strong>双字 = 4字节 = 32bits</strong></span> <spanstyle="font-family:serif;"><strong>字 = 2 字节 = 16bits</strong></span><span style="font-family:serif;"><strong>1 字节 =8bits</strong></span></p><p><span style="font-family:serif;"><strong>rax = 四字</strong></span><span style="font-family:serif;"><strong>eax = 双字</strong></span><span style="font-family:serif;"><strong>ax = 字</strong></span> <spanstyle="font-family:serif;"><strong>al = 字节</strong></span></p><p>按要求给寄存器按字节设置即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov al,[0x404000]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="memory-size-access">memory-size-access</h2><p>Recall the following:</p><ul><li>The breakdown of the names of memory sizes:<ul><li>Quad Word = 8 Bytes = 64 bits</li><li>Double Word = 4 bytes = 32 bits</li><li>Word = 2 bytes = 16 bits</li><li>Byte = 1 byte = 8 bits</li></ul></li></ul><p>In x86_64, you can access each of these sizes when dereferencing anaddress, just like using bigger or smaller register accesses:</p><ul><li><code>mov al, [address]</code> &lt;=&gt; moves the least significantbyte from address to <code>rax</code></li><li><code>mov ax, [address]</code> &lt;=&gt; moves the least significantword from address to <code>rax</code></li><li><code>mov eax, [address]</code> &lt;=&gt; moves the leastsignificant double word from address to <code>rax</code></li><li><code>mov rax, [address]</code> &lt;=&gt; moves the full quad wordfrom address to <code>rax</code></li></ul><p>Please perform the following:</p><ul><li>Set <code>rax</code> to the byte at <code>0x404000</code></li><li>Set <code>rbx</code> to the word at <code>0x404000</code></li><li>Set <code>rcx</code> to the double word at<code>0x404000</code></li><li>Set <code>rdx</code> to the quad word at <code>0x404000</code></li></ul><p>加量训练</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov al,[0x404000]</span></span><br><span class="line"><span class="string">    mov bx,[0x404000]</span></span><br><span class="line"><span class="string">    mov ecx,[0x404000]</span></span><br><span class="line"><span class="string">    mov rdx,[0x404000]</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>不记得该用哪个寄存器可以去七号题 <code>set-upper-byte</code>回忆一下</p><h2 id="little-endian-write">little-endian-write</h2><p>It is worth noting, as you may have noticed, that values are storedin reverse order of how we represent them.</p><p>As an example, say:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0x1330] = 0x00000000deadc0de</span><br></pre></td></tr></table></figure><p>If you examined how it actually looked in memory, you would see:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[0x1330] = 0xde</span><br><span class="line">[0x1331] = 0xc0</span><br><span class="line">[0x1332] = 0xad</span><br><span class="line">[0x1333] = 0xde</span><br><span class="line">[0x1334] = 0x00</span><br><span class="line">[0x1335] = 0x00</span><br><span class="line">[0x1336] = 0x00</span><br><span class="line">[0x1337] = 0x00</span><br></pre></td></tr></table></figure><p>This format of storing things in 'reverse' is intentional in x86, andit's called "Little Endian".</p><p>For this challenge, we will give you two addresses createddynamically each run.</p><p>The first address will be placed in <code>rdi</code>. The second willbe placed in <code>rsi</code>.</p><p>Using the earlier mentioned info, perform the following:</p><ul><li>Set <code>[rdi] = 0xdeadbeef00001337</code></li><li>Set <code>[rsi] = 0xc0ffee0000</code></li></ul><p>Hint: it may require some tricks to assign a big constant to adereferenced register. Try setting a register to the constant value,then assigning that register to the dereferenced register.</p><p>小端序以字为单位逆顺序排列，题目给了个提示：要将一个大常量赋值给一个内存地址，可以将大常量先加载到一个寄存器中，然后将寄存器的值存储到内存地址处。依次赋值即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax,0xdeadbeef00001337</span></span><br><span class="line"><span class="string">    mov [rdi],rax</span></span><br><span class="line"><span class="string">    mov rax,0xc0ffee0000</span></span><br><span class="line"><span class="string">    mov [rsi],rax</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="memory-sum">memory-sum</h2><p>Recall that memory is stored linearly.</p><p>What does that mean?</p><p>Say we access the quad word at <code>0x1337</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0x1337] = 0x00000000deadbeef</span><br></pre></td></tr></table></figure><p>The real way memory is laid out is byte by byte, little endian:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[0x1337] = 0xef</span><br><span class="line">[0x1337 + 1] = 0xbe</span><br><span class="line">[0x1337 + 2] = 0xad</span><br><span class="line">...</span><br><span class="line">[0x1337 + 7] = 0x00</span><br></pre></td></tr></table></figure><p>What does this do for us?</p><p>Well, it means that we can access things next to each other usingoffsets, similar to what was shown above.</p><p>Say you want the 5th <em>byte</em> from an address, you can access itlike:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov al, [address+4]</span><br></pre></td></tr></table></figure><p>Remember, offsets start at 0.</p><p>Perform the following:</p><ul><li>Load two consecutive quad words from the address stored in<code>rdi</code>.</li><li>Calculate the sum of the previous steps' quad words.</li><li>Store the sum at the address in <code>rsi</code>.</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax,[rdi]</span></span><br><span class="line"><span class="string">    add rax,[rdi+8]</span></span><br><span class="line"><span class="string">    mov [rsi],rax #不要忘记给rsi添加括号，不然就只是修改寄存器的值而不是指向的内存地址中的值</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="stack-subtraction">stack-subtraction</h2><p>In these levels, we are going to introduce the stack.</p><p>The stack is a region of memory that can store values for later.</p><p>To store a value on the stack, we use the <code>push</code>instruction, and to retrieve a value, we use <code>pop</code>.</p><p>The stack is a last in, first out (LIFO) memory structure, and thismeans the last value pushed is the first value popped.</p><p>Imagine unloading plates from the dishwasher. Let's say there are 1red, 1 green, and 1 blue. First, we place the red one in the cabinet,then the green on top of the red, then the blue.</p><p>Our stack of plates would look like:</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Top ----&gt; Blue</span><br><span class="line">          Green</span><br><span class="line">Bottom -&gt; Red</span><br></pre></td></tr></table></figure><p>Now, if we wanted a plate to make a sandwich, we would retrieve thetop plate from the stack, which would be the blue one that was last intothe cabinet, ergo the first one out.</p><p>On x86, the <code>pop</code> instruction will take the value from thetop of the stack and put it into a register.</p><p>Similarly, the <code>push</code> instruction will take the value in aregister and push it onto the top of the stack.</p><p>Using these instructions, take the top value of the stack, subtract<code>rdi</code> from it, then put it back.</p><p>终于学到栈了/(ㄒoㄒ)/~~。</p><p>想象一下你有一叠书放在桌子上，你只能从最上面拿书或放书，不能从中间或底部操作。这就像一个栈，只能从栈顶进行操作。</p><ul><li><strong>入栈（Push）</strong>：<ul><li><strong>比喻</strong>：就像在书堆的最上面再放一本书。</li><li><strong>操作</strong>：将一个新元素添加到栈顶。在计算机中，这通常意味着将数据存储到栈的顶部，并更新栈指针（指向栈顶的指针）。</li><li><strong>效果</strong>：栈的大小增加，新元素成为栈顶元素。</li></ul></li><li><strong>出栈（Pop）</strong>：<ul><li><strong>比喻</strong>：从书堆的最上面拿走一本书。</li><li><strong>操作</strong>：从栈顶移除一个元素，并返回该元素的值。同时更新栈指针。</li><li><strong>效果</strong>：栈的大小减少，原来位于栈顶下面的元素成为新的栈顶元素。</li></ul></li><li><strong>查看栈顶（Peek）</strong>：<ul><li><strong>比喻</strong>：查看书堆最上面的书是什么，但不拿走它。</li><li><strong>操作</strong>：获取栈顶元素的值，但不移除该元素。</li><li><strong>效果</strong>：栈的大小和内容不变，只是查看了栈顶元素。</li></ul></li></ul><p>他这里没提具体用汇编代码如何操作，其实直接<code>pop</code>弹出，<code>push</code>压入即可。</p><p>栈是一种线性数据结构，遵循“后进先出”（Last In, First Out,LIFO）的原则。这意味着最后放入栈中的元素将是第一个被取出的元素。由于寄存器数量有限，使用栈来储存数据便是一个极佳的选择。后面会经常和它打交道。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    sub,rax,rdi</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="swap-satck-values">swap-satck-values</h2><p>In this level, you will be working with the stack, the memory regionthat dynamically expands and shrinks. You will be required to read andwrite to the stack, which may require you to use the <code>pop</code>and <code>push</code> instructions. You may also need to use the stackpointer register (<code>rsp</code>) to know where the stack ispointing.</p><p>In this level, we are going to explore the last in first out (LIFO)property of the stack.</p><p>Using only the following instructions:</p><ul><li><code>push</code></li><li><code>pop</code></li></ul><p>Swap values in <code>rdi</code> and <code>rsi</code>.</p><p>Example:</p><ul><li>If to start <code>rdi = 2</code> and <code>rsi = 5</code></li><li>Then to end <code>rdi = 5</code> and <code>rsi = 2</code></li></ul><p>仅用<code>pop</code>和<code>push</code>进行数值交换，栈的基本用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    push rdi</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    push rsi</span></span><br><span class="line"><span class="string">    pop rdi</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">    pop rsi</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="average-stack-values">average-stack-values</h2><p>In the previous levels, you used <code>push</code> and<code>pop</code> to store and load data from the stack. However, you canalso access the stack directly using the stack pointer.</p><p>On x86, the stack pointer is stored in the special register,<code>rsp</code>. <code>rsp</code> always stores the memory address ofthe top of the stack, i.e., the memory address of the last valuepushed.</p><p>Similar to the memory levels, we can use <code>[rsp]</code> to accessthe value at the memory address in <code>rsp</code>.</p><p>Without using <code>pop</code>, please calculate the average of 4consecutive quad words stored on the stack. Push the average on thestack.</p><p>Hint:</p><ul><li><code>RSP+0x??</code> Quad Word A</li><li><code>RSP+0x??</code> Quad Word B</li><li><code>RSP+0x??</code> Quad Word C</li><li><code>RSP</code> Quad Word D</li></ul><p>介绍了栈指针<code>rsp</code>,提示了我们用栈指针的具体操作。</p><ul><li><strong>栈指针的操作</strong>：<ul><li><strong>入栈（Push）</strong>：将数据推入栈时，<code>RSP</code>会减小（向下移动），因为x86-64架构的栈是向下增长的。</li><li><strong>出栈（Pop）</strong>：从栈中弹出数据时，<code>RSP</code>会增加（向上移动）。</li><li><strong>直接访问</strong>：可以通过<code>[RSP + offset]</code>的形式直接访问栈上的数据，其中<code>offset</code>是相对于栈顶的偏移量。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax,[rsp]</span></span><br><span class="line"><span class="string">    add rax,[rsp+8]</span></span><br><span class="line"><span class="string">    add rax,[rsp+16]</span></span><br><span class="line"><span class="string">    add rax,[rsp+24]</span></span><br><span class="line"><span class="string">    mov rsi,4; rax存储被除数的低 64 位。</span></span><br><span class="line"><span class="string">    div rsi</span></span><br><span class="line"><span class="string">    push rax</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="abusolute-jump">abusolute-jump</h2><p>Earlier, you learned how to manipulate data in a pseudo-control way,but x86 gives us actual instructions to manipulate control flowdirectly.</p><p>There are two major ways to manipulate control flow:</p><ul><li>Through a jump</li><li>Through a call</li></ul><p>In this level, you will work with jumps.</p><p>There are two types of jumps:</p><ul><li>Unconditional jumps</li><li>Conditional jumps</li></ul><p>Unconditional jumps always trigger and are not based on the resultsof earlier instructions.</p><p>As you know, memory locations can store data and instructions. Yourcode will be stored at <code>0x400042</code> (this will change eachrun).</p><p>For all jumps, there are three types:</p><ul><li>Relative jumps: jump + or - the next instruction.</li><li>Absolute jumps: jump to a specific address.</li><li>Indirect jumps: jump to the memory address specified in aregister.</li></ul><p>In x86, absolute jumps (jump to a specific address) are accomplishedby first putting the target address in a register <code>reg</code>, thendoing <code>jmp reg</code>.</p><p>In this level, we will ask you to do an absolute jump. Perform thefollowing: Jump to the absolute address <code>0x403000</code>.</p><p>x86_64用法 jmp <register></p><p>绝对跳转和相对跳转也是两个经久不衰的话题。题目里说到的<code>reg</code>其实就是regitser，寄存器的缩写，并不是特指某一个寄存器。当然jmp指令也不能直接给出地址进行跳转，必须要用寄存器作为中介。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">mov rax,0x403000</span></span><br><span class="line"><span class="string">    jmp rax</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="relative-jump">relative-jump</h2><p>Recall that for all jumps, there are three types:</p><ul><li>Relative jumps</li><li>Absolute jumps</li><li>Indirect jumps</li></ul><p>In this level, we will ask you to do a relative jump. You will needto fill space in your code with something to make this relative jumppossible. We suggest using the <code>nop</code> instruction. It's 1 bytelong and very predictable.</p><p>In fact, the assembler that we're using has a handy<code>.rept</code> directive that you can use to repeat assemblyinstructions some number of times: <ahref="https://ftp.gnu.org/old-gnu/Manuals/gas-2.9.1/html_chapter/as_7.html">GNUAssembler Manual</a></p><p>Useful instructions for this level:</p><ul><li><code>jmp (reg1 | addr | offset)</code></li><li><code>nop</code></li></ul><p>Hint: For the relative jump, look up how to use <code>labels</code>in x86.</p><p>Using the above knowledge, perform the following:</p><ul><li>Make the first instruction in your code a <code>jmp</code>.</li><li>Make that <code>jmp</code> a relative jump to 0x51 bytes from thecurrent position.</li><li>At the code location where the relative jump will redirect controlflow, set <code>rax</code> to 0x1.</li></ul><p>头一次看晕乎乎的，问了几遍kimi终于明白了。</p><p>题目要求的相对跳转实际上是通过设置一个<code>label</code>地址后，不断填充无意义的<code>nop</code>空指令来实现的跳转。当我们执行到<code>label</code>时，结果的确是相对于目前的地址进行了一定字节的跳转。</p><p><code>.rept 0x??</code></p><p><code>instructions</code></p><p><code>.endr</code></p><p>相当于一个循环语句.</p><p><code>address</code>是一个标签（label）,它用于标记代码中的某个位置,通常用于指示跳转指令的目标位置或其他重要的代码段。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    jmp address</span></span><br><span class="line"><span class="string">    .rept 0x51</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    .endr</span></span><br><span class="line"><span class="string">    address:</span></span><br><span class="line"><span class="string">    mov rax,0x1</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关于代码的可能问题：</p><ol type="1"><li><strong>执行<code>jmp address</code>指令</strong>：<ul><li>这条指令告诉CPU跳转到<code>address</code>标签所标记的位置。由于<code>address</code>标签标记的是<code>mov rax, 0x1</code>指令的起始位置，所以CPU会跳过接下来的81个<code>nop</code>指令，直接跳转到<code>mov rax, 0x1</code>指令处开始执行。</li></ul></li><li><strong>跳转到<code>address</code>标签后，执行<code>mov rax, 0x1</code>指令</strong>：<ul><li>在跳转到<code>address</code>标签后，CPU会执行<code>mov rax, 0x1</code>指令，将<code>rax</code>寄存器的值设置为1。</li></ul></li><li><strong>关于81个<code>nop</code>指令</strong></li></ol><ul><li><strong>填充作用</strong>：这81个<code>nop</code>指令实际上是用来填充代码空间的。它们确保从<code>jmp address</code>指令到<code>address</code>标签之间的距离正好是81字节。这是为了满足相对跳转的要求，使得<code>jmp</code>指令能够正确地跳转到目标位置。</li><li><strong>不执行</strong>：在程序执行过程中，这81个<code>nop</code>指令并不会被实际执行。因为<code>jmp address</code>指令已经将控制流跳转到了<code>address</code>标签处，所以CPU会跳过这些<code>nop</code>指令，直接执行<code>mov rax, 0x1</code>指令。</li></ul><h2 id="jump-trampoline">jump-trampoline</h2><p>Now, we will combine the two prior levels and perform thefollowing:</p><ul><li>Create a two jump trampoline:<ul><li>Make the first instruction in your code a <code>jmp</code>.</li><li>Make that <code>jmp</code> a relative jump to 0x51 bytes from itscurrent position.</li><li>At 0x51, write the following code:<ul><li>Place the top value on the stack into register<code>rdi</code>.</li><li><code>jmp</code> to the absolute address 0x403000.</li></ul></li></ul></li></ul><p>熟悉下刚学到的两种跳转方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line"> </span><br><span class="line">p.recvline()</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    jmp address</span></span><br><span class="line"><span class="string">    .rept 0x51</span></span><br><span class="line"><span class="string">    nop</span></span><br><span class="line"><span class="string">    .endr</span></span><br><span class="line"><span class="string">    address:</span></span><br><span class="line"><span class="string">    pop rax</span></span><br><span class="line"><span class="string">    mov rdi,rax</span></span><br><span class="line"><span class="string">    mov rsi,0x403000</span></span><br><span class="line"><span class="string">    jmp rsi</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line">))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="conditional-jump">conditional-jump</h2><p>In this level, you will be working with control flow manipulation.This involves using instructions to both indirectly and directly controlthe special register <code>rip</code>, the instruction pointer. You willuse instructions such as <code>jmp</code>, <code>call</code>,<code>cmp</code>, and their alternatives to implement the requestedbehavior.</p><p>We will be testing your code multiple times in this level withdynamic values! This means we will be running your code in a variety ofrandom ways to verify that the logic is robust enough to survive normaluse.</p><p>We will now introduce you to conditional jumps--one of the mostvaluable instructions in x86. In higher-level programming languages, anif-else structure exists to do things like:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if x is even:</span><br><span class="line">    is_even = 1</span><br><span class="line">else:</span><br><span class="line">    is_even = 0</span><br></pre></td></tr></table></figure><p>This should look familiar since it is implementable in onlybit-logic, which you've done in a prior level. In these structures, wecan control the program's control flow based on dynamic values providedto the program.</p><p>Implementing the above logic with jmps can be done like so:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">; assume rdi = x, rax is output</span><br><span class="line">; rdx = rdi mod 2</span><br><span class="line">mov rax, rdi</span><br><span class="line">mov rsi, 2</span><br><span class="line">div rsi</span><br><span class="line">; remainder is 0 if even</span><br><span class="line">cmp rdx, 0</span><br><span class="line">; jump to not_even code if it&#x27;s not 0</span><br><span class="line">jne not_even</span><br><span class="line">; fall through to even code</span><br><span class="line">mov rbx, 1</span><br><span class="line">jmp done</span><br><span class="line">; jump to this only when not_even</span><br><span class="line">not_even:</span><br><span class="line">mov rbx, 0</span><br><span class="line">done:</span><br><span class="line">mov rax, rbx</span><br><span class="line">; more instructions here</span><br></pre></td></tr></table></figure><p>Often though, you want more than just a single 'if-else'. Sometimesyou want two if checks, followed by an else. To do this, you need tomake sure that you have control flow that 'falls-through' to the next<code>if</code> after it fails. All must jump to the same<code>done</code> after execution to avoid the else.</p><p>There are many jump types in x86, it will help to learn how they canbe used. Nearly all of them rely on something called the ZF, the ZeroFlag. The ZF is set to 1 when a <code>cmp</code> is equal, 0otherwise.</p><p>Using the above knowledge, implement the following:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if [x] is 0x7f454c46:</span><br><span class="line">    y = [x+4] + [x+8] + [x+12]</span><br><span class="line">else if [x] is 0x00005A4D:</span><br><span class="line">    y = [x+4] - [x+8] - [x+12]</span><br><span class="line">else:</span><br><span class="line">    y = [x+4] * [x+8] * [x+12]</span><br></pre></td></tr></table></figure><p>Where:</p><ul><li><code>x = rdi</code>, <code>y = rax</code>.</li></ul><p>Assume each dereferenced value is a signed dword. This means thevalues can start as a negative value at each memory position.</p><p>A valid solution will use the following at least once:</p><ul><li><code>jmp</code> (any variant), <code>cmp</code></li></ul><p>接下来的挑战是进行流操作，后悔没在下午开始学。。最后十道题几乎要花上做之前二十道两倍的时间。。。😭😭😭😅😅😅</p><p>还好有没脾气的ai，不然去discord或者bing上早不知道要猴年马月才能做完。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.update(arch=<span class="string">&quot;amd64&quot;</span>)</span><br><span class="line">p = process(<span class="string">&quot;/challenge/run&quot;</span>)</span><br><span class="line">p.write(asm(<span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">mov eax, [rdi]</span></span><br><span class="line"><span class="string">mov ebx, [rdi + 4]</span></span><br><span class="line"><span class="string">mov ecx, [rdi + 8]</span></span><br><span class="line"><span class="string">mov edx, [rdi + 12]</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">cmp eax, 0x7f454c46</span></span><br><span class="line"><span class="string">je con1</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">cmp eax, 0x00005A4D</span></span><br><span class="line"><span class="string">je con2</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">imul ebx, ecx</span></span><br><span class="line"><span class="string">imul ebx, edx</span></span><br><span class="line"><span class="string">jmp done</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">con1:</span></span><br><span class="line"><span class="string">add ebx, ecx</span></span><br><span class="line"><span class="string">add ebx, edx</span></span><br><span class="line"><span class="string">jmp done</span></span><br><span class="line"><span class="string"> </span></span><br><span class="line"><span class="string">con2:</span></span><br><span class="line"><span class="string">sub ebx, ecx</span></span><br><span class="line"><span class="string">sub ebx, edx</span></span><br><span class="line"><span class="string">done:</span></span><br><span class="line"><span class="string">mov eax, ebx&quot;&quot;&quot;</span>))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="indirect-jump">indirect-jump</h2><p>The last jump type is the indirect jump, often used for switchstatements in the real world. Switch statements are a special case ofif-statements that use only numbers to determine where the control flowwill go.</p><p>Here is an example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">switch(number):</span><br><span class="line">  0: jmp do_thing_0</span><br><span class="line">  1: jmp do_thing_1</span><br><span class="line">  2: jmp do_thing_2</span><br><span class="line">  default: jmp do_default_thing</span><br></pre></td></tr></table></figure><p>The switch in this example works on <code>number</code>, which caneither be 0, 1, or 2. If <code>number</code> is not one of thosenumbers, the default triggers. You can consider this a reduced else-iftype structure. In x86, you are already used to using numbers, so itshould be no surprise that you can make if statements based on somethingbeing an exact number. Additionally, if you know the range of thenumbers, a switch statement works very well.</p><p>Take, for instance, the existence of a jump table. A jump table is acontiguous section of memory that holds addresses of places to jump.</p><p>In the above example, the jump table could look like:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[0x1337] = address of do_thing_0</span><br><span class="line">[0x1337+0x8] = address of do_thing_1</span><br><span class="line">[0x1337+0x10] = address of do_thing_2</span><br><span class="line">[0x1337+0x18] = address of do_default_thing</span><br></pre></td></tr></table></figure><p>Using the jump table, we can greatly reduce the amount of<code>cmps</code> we use. Now all we need to check is if<code>number</code> is greater than 2. If it is, always do:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp [0x1337+0x18]</span><br></pre></td></tr></table></figure><p>Otherwise:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmp [jump_table_address + number * 8]</span><br></pre></td></tr></table></figure><p>Using the above knowledge, implement the following logic:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if rdi is 0:</span><br><span class="line">  jmp 0x40301e</span><br><span class="line">else if rdi is 1:</span><br><span class="line">  jmp 0x4030da</span><br><span class="line">else if rdi is 2:</span><br><span class="line">  jmp 0x4031d5</span><br><span class="line">else if rdi is 3:</span><br><span class="line">  jmp 0x403268</span><br><span class="line">else:</span><br><span class="line">  jmp 0x40332c</span><br></pre></td></tr></table></figure><p>Please do the above with the following constraints:</p><ul><li>Assume <code>rdi</code> will NOT be negative.</li><li>Use no more than 1 <code>cmp</code> instruction.</li><li>Use no more than 3 jumps (of any variant).</li><li>We will provide you with the number to 'switch' on in<code>rdi</code>.</li><li>We will provide you with a jump table base address in<code>rsi</code>.</li></ul><p>Here is an example table:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[0x40427c] = 0x40301e (addrs will change)</span><br><span class="line">[0x404284] = 0x4030da</span><br><span class="line">[0x40428c] = 0x4031d5</span><br><span class="line">[0x404294] = 0x403268</span><br><span class="line">[0x40429c] = 0x40332c</span><br></pre></td></tr></table></figure><p>学会使用跳转表来实现<code>switch</code>的功能，这就是底层代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">cmp rdi, 4</span></span><br><span class="line"><span class="string">jae default</span></span><br><span class="line"><span class="string">jmp [rsi + rdi * 8]</span></span><br><span class="line"><span class="string">jmp end</span></span><br><span class="line"><span class="string">default:</span></span><br><span class="line"><span class="string">jmp [rsi + 4 * 8]</span></span><br><span class="line"><span class="string">end:</span></span><br><span class="line"><span class="string">nop</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="average-loop">average-loop</h2><p>In a previous level, you computed the average of 4 integer quadwords, which was a fixed amount of things to compute. But how do youwork with sizes you get when the program is running?</p><p>In most programming languages, a structure exists called thefor-loop, which allows you to execute a set of instructions for abounded amount of times. The bounded amount can be either known beforeor during the program's run, with "during" meaning the value is given toyou dynamically.</p><p>As an example, a for-loop can be used to compute the sum of thenumbers 1 to n:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sum = 0</span><br><span class="line">i = 1</span><br><span class="line">while i &lt;= n:</span><br><span class="line">    sum += i</span><br><span class="line">    i += 1</span><br></pre></td></tr></table></figure><p>Please compute the average of <code>n</code> consecutive quad words,where:</p><ul><li><code>rdi</code> = memory address of the 1st quad word</li><li><code>rsi</code> = <code>n</code> (amount to loop for)</li><li><code>rax</code> = average computed</li></ul><p>就像是在实现高级语言</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line">p.send(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    mov rax,0</span></span><br><span class="line"><span class="string">    mov rcx,0</span></span><br><span class="line"><span class="string">    loop_start:</span></span><br><span class="line"><span class="string">        cmp rcx, rsi</span></span><br><span class="line"><span class="string">        jge loop_end</span></span><br><span class="line"><span class="string">        add rax, [rdi + rcx * 8]</span></span><br><span class="line"><span class="string">        inc rcx</span></span><br><span class="line"><span class="string">        jmp loop_start</span></span><br><span class="line"><span class="string">    loop_end:</span></span><br><span class="line"><span class="string">    div rsi</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="count-non-zero">count-non-zero</h2><p>In previous levels, you discovered the for-loop to iterate for a<em>number</em> of times, both dynamically and statically known, butwhat happens when you want to iterate until you meet a condition?</p><p>A second loop structure exists called the while-loop to fill thisdemand. In the while-loop, you iterate until a condition is met.</p><p>As an example, say we had a location in memory with adjacent numbersand we wanted to get the average of all the numbers until we find onebigger or equal to <code>0xff</code>:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">average = 0</span><br><span class="line">i = 0</span><br><span class="line">while x[i] &lt; 0xff:</span><br><span class="line">  average += x[i]</span><br><span class="line">  i += 1</span><br><span class="line">average /= i</span><br></pre></td></tr></table></figure><p>Using the above knowledge, please perform the following:</p><p>Count the consecutive non-zero bytes in a contiguous region ofmemory, where:</p><ul><li><code>rdi</code> = memory address of the 1st byte</li><li><code>rax</code> = number of consecutive non-zero bytes</li></ul><p>Additionally, if <code>rdi = 0</code>, then set <code>rax = 0</code>(we will check)!</p><p>An example test-case, let:</p><ul><li><code>rdi = 0x1000</code></li><li><code>[0x1000] = 0x41</code></li><li><code>[0x1001] = 0x42</code></li><li><code>[0x1002] = 0x43</code></li><li><code>[0x1003] = 0x00</code></li></ul><p>Then: <code>rax = 3</code> should be set.</p><p>建构一下while循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"> </span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line">p.write(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    cmp rdi,0</span></span><br><span class="line"><span class="string">    je set_zero</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    xor rcx,rcx</span></span><br><span class="line"><span class="string">    while_loop:</span></span><br><span class="line"><span class="string">    cmp byte [rdi],0</span></span><br><span class="line"><span class="string">    je end_loop</span></span><br><span class="line"><span class="string">    inc rcx</span></span><br><span class="line"><span class="string">    inc rdi</span></span><br><span class="line"><span class="string">    jmp while_loop</span></span><br><span class="line"><span class="string">    end_loop:</span></span><br><span class="line"><span class="string">    mov rax,rcx</span></span><br><span class="line"><span class="string">    jmp done</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    set_zero:</span></span><br><span class="line"><span class="string">    xor rax,rax</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    done:</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>))</span><br><span class="line">output = p.recvall().decode()  </span><br><span class="line"><span class="built_in">print</span>(output)  </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>注意,在x86-64汇编中，使用<code>cmp</code>指令比较内存中的值时，需要明确指定操作数的大小。提示“ambiguousoperand size for <code>cmp</code>”</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/tmp/pwn-asm-n0jy2att/step1: Assembler messages:</span><br><span class="line">/tmp/pwn-asm-n0jy2att/step1:12: Error: ambiguous operand size <span class="keyword">for</span> `cmp<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure><p>可以通过在<code>cmp</code>指令中明确指定操作数的大小，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp byte ptr [rdi], 0</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cmp dword ptr [rdi], 0</span><br></pre></td></tr></table></figure><p><code>ptr</code>,<strong>Pointer</strong>,汇编语言中，<code>ptr</code>是一个类型指示符，用于明确指定操作数的大小。使用<code>cmp</code>指令比较内存中的值时，汇编器可能不知道你是想比较一个字节、一个字（16位）、一个双字（32位）还是一个四字（64位）。通过加上<code>ptr</code>，你可以明确指定操作数的大小，从而消除歧义。</p><p>就像题目里，我们比较的是一个字节，所以要用<code>byte</code>指出。</p><h2 id="string-lower">string-lower</h2><p>In previous levels, you implemented a while loop to count the numberof consecutive non-zero bytes in a contiguous region of memory.</p><p>In this level, you will be provided with a contiguous region ofmemory again and will loop over each performing a conditional operationtill a zero byte is reached. All of which will be contained in afunction!</p><p>A function is a callable segment of code that does not destroycontrol flow.</p><p>Functions use the instructions "call" and "ret".</p><p>The "call" instruction pushes the memory address of the nextinstruction onto the stack and then jumps to the value stored in thefirst argument.</p><p>Let's use the following instructions as an example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0x1021 mov rax, 0x400000</span><br><span class="line">0x1028 call rax</span><br><span class="line">0x102a mov [rsi], rax</span><br></pre></td></tr></table></figure><ol type="1"><li><code>call</code> pushes <code>0x102a</code>, the address of thenext instruction, onto the stack.</li><li><code>call</code> jumps to <code>0x400000</code>, the value storedin <code>rax</code>.</li></ol><p>The "ret" instruction is the opposite of "call".</p><p><code>ret</code> pops the top value off of the stack and jumps toit.</p><p>Let's use the following instructions and stack as an example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stack ADDR  VALUE</span><br><span class="line">0x103f mov rax, rdx         RSP + 0x8   0xdeadbeef</span><br><span class="line">0x1042 ret                  RSP + 0x0   0x0000102a</span><br></pre></td></tr></table></figure><p>Here, <code>ret</code> will jump to <code>0x102a</code>.</p><p>Please implement the following logic:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">str_lower(src_addr):</span><br><span class="line">  i = 0</span><br><span class="line">  if src_addr != 0:</span><br><span class="line">    while [src_addr] != 0x00:</span><br><span class="line">      if [src_addr] &lt;= 0x5a:</span><br><span class="line">        [src_addr] = foo([src_addr])</span><br><span class="line">        i += 1</span><br><span class="line">      src_addr += 1</span><br><span class="line">  return i</span><br></pre></td></tr></table></figure><p><code>foo</code> is provided at <code>0x403000</code>.<code>foo</code> takes a single argument as a value and returns avalue.</p><p>All functions (<code>foo</code> and <code>str_lower</code>) mustfollow the Linux amd64 calling convention (also known as System V AMD64ABI): <ahref="https://en.wikipedia.org/wiki/X86_calling_conventions#System_V_AMD64_ABI">SystemV AMD64 ABI</a></p><p>Therefore, your function <code>str_lower</code> should look for<code>src_addr</code> in <code>rdi</code> and place the function returnin <code>rax</code>.</p><p>An important note is that <code>src_addr</code> is an address inmemory (where the string is located) and <code>[src_addr]</code> refersto the byte that exists at <code>src_addr</code>.</p><p>Therefore, the function <code>foo</code> accepts a byte as its firstargument and returns a byte.</p><p>注意foo函数返还的是一个字节大小的值，不能直接用al</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line">p.write(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    cmp rdi, 0</span></span><br><span class="line"><span class="string">    je return_0</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    xor rcx, rcx</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    while_loop:</span></span><br><span class="line"><span class="string">        cmp byte ptr [rdi], 0</span></span><br><span class="line"><span class="string">        je return_0</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">        mov al, byte ptr [rdi]</span></span><br><span class="line"><span class="string">        cmp al, 0x5a</span></span><br><span class="line"><span class="string">        jg next_byte</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">       mov rsi,rdi</span></span><br><span class="line"><span class="string">        mov dil,al</span></span><br><span class="line"><span class="string">        call rbx</span></span><br><span class="line"><span class="string">        mov rdi,rsi</span></span><br><span class="line"><span class="string">        mov byte ptr [rdi],al</span></span><br><span class="line"><span class="string">        inc rcx</span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    next_byte:</span></span><br><span class="line"><span class="string">        inc rdi</span></span><br><span class="line"><span class="string">        jmp while_loop</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">        </span></span><br><span class="line"><span class="string">    return_0:</span></span><br><span class="line"><span class="string">        mov rax, rcx</span></span><br><span class="line"><span class="string">        ret</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>))</span><br><span class="line">output = p.recvall().decode()</span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure><p>上面代码不对，暂时没有debug成功</p><p>以下是网上找到的通过的代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line">p.write(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    str_lower:</span></span><br><span class="line"><span class="string">    mov rbx, 0x403000       </span></span><br><span class="line"><span class="string">    xor rcx, rcx            </span></span><br><span class="line"><span class="string">    test rdi, rdi          </span></span><br><span class="line"><span class="string">    jz done                 </span></span><br><span class="line"><span class="string">process_string:</span></span><br><span class="line"><span class="string">    mov al, byte ptr [rdi]  </span></span><br><span class="line"><span class="string">    test al, al             </span></span><br><span class="line"><span class="string">    jz done                </span></span><br><span class="line"><span class="string">    cmp al, 0x5A           </span></span><br><span class="line"><span class="string">    jg skip_conversion      </span></span><br><span class="line"><span class="string">    mov rsi, rdi           </span></span><br><span class="line"><span class="string">    mov dil, al             </span></span><br><span class="line"><span class="string">    call rbx                </span></span><br><span class="line"><span class="string">    mov rdi, rsi            </span></span><br><span class="line"><span class="string">    mov byte ptr [rdi], al   </span></span><br><span class="line"><span class="string">    inc rcx                 </span></span><br><span class="line"><span class="string">skip_conversion:</span></span><br><span class="line"><span class="string">    inc rdi                  </span></span><br><span class="line"><span class="string">    jmp process_string       </span></span><br><span class="line"><span class="string">done:</span></span><br><span class="line"><span class="string">    mov rax, rcx             </span></span><br><span class="line"><span class="string">    ret        </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>))</span><br><span class="line">output = p.recvall().decode()</span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure><h2 id="most-common-byte">most-common-byte</h2><p>A function stack frame is a set of pointers and values pushed ontothe stack to save things for later use and allocate space on the stackfor function variables.</p><p>First, let's talk about the special register <code>rbp</code>, theStack Base Pointer.</p><p>The <code>rbp</code> register is used to tell where our stack framefirst started. As an example, say we want to construct some list (acontiguous space of memory) that is only used in our function. The listis 5 elements long, and each element is a dword. A list of 5 elementswould already take 5 registers, so instead, we can make space on thestack!</p><p>The assembly would look like:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">; setup the base of the stack as the current top</span><br><span class="line">mov rbp, rsp</span><br><span class="line">; move the stack 0x14 bytes (5 * 4) down</span><br><span class="line">; acts as an allocation</span><br><span class="line">sub rsp, 0x14</span><br><span class="line">; assign list[2] = 1337</span><br><span class="line">mov eax, 1337</span><br><span class="line">mov [rbp-0x8], eax</span><br><span class="line">; do more operations on the list ...</span><br><span class="line">; restore the allocated space</span><br><span class="line">mov rsp, rbp</span><br><span class="line">ret</span><br></pre></td></tr></table></figure><p>Notice how <code>rbp</code> is always used to restore the stack towhere it originally was. If we don't restore the stack after use, wewill eventually run out. In addition, notice how we subtracted from<code>rsp</code>, because the stack grows down. To make the stack havemore space, we subtract the space we need. The <code>ret</code> and<code>call</code> still work the same.</p><p>Once again, please make function(s) that implement the following:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">most_common_byte(src_addr, size):</span><br><span class="line">  i = 0</span><br><span class="line">  while i &lt;= size-1:</span><br><span class="line">    curr_byte = [src_addr + i]</span><br><span class="line">    [stack_base - curr_byte] += 1</span><br><span class="line">    i += 1</span><br><span class="line"></span><br><span class="line">  b = 0</span><br><span class="line">  max_freq = 0</span><br><span class="line">  max_freq_byte = 0</span><br><span class="line">  while b &lt;= 0xff:</span><br><span class="line">    if [stack_base - b] &gt; max_freq:</span><br><span class="line">      max_freq = [stack_base - b]</span><br><span class="line">      max_freq_byte = b</span><br><span class="line">    b += 1</span><br><span class="line"></span><br><span class="line">  return max_freq_byte</span><br></pre></td></tr></table></figure><p><strong>Assumptions:</strong></p><ul><li>There will never be more than 0xffff of any byte</li><li>The size will never be longer than 0xffff</li><li>The list will have at least one element</li></ul><p><strong>Constraints:</strong></p><ul><li>You must put the "counting list" on the stack</li><li>You must restore the stack like in a normal function</li><li>You cannot modify the data at <code>src_addr</code></li></ul><p>汇编代码部分的终局一战🥲🥲🥲🥲🥲</p><hr /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">context.arch = <span class="string">&#x27;amd64&#x27;</span></span><br><span class="line">p = process(<span class="string">&#x27;/challenge/run&#x27;</span>)</span><br><span class="line">p.write(asm(<span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    most_common_byte:</span></span><br><span class="line"><span class="string">    push rbp                 </span></span><br><span class="line"><span class="string">    mov rbp, rsp           </span></span><br><span class="line"><span class="string">    sub rsp, 256            </span></span><br><span class="line"><span class="string">    xor rcx, rcx            </span></span><br><span class="line"><span class="string">initialize_counting_list_with_zero:</span></span><br><span class="line"><span class="string">    mov byte ptr [rbp + rcx - 256], 0  </span></span><br><span class="line"><span class="string">    inc rcx                              </span></span><br><span class="line"><span class="string">    cmp rcx, 256                         </span></span><br><span class="line"><span class="string">    jl initialize_counting_list_with_zero </span></span><br><span class="line"><span class="string">    xor rcx, rcx                        </span></span><br><span class="line"><span class="string">count_bytes:</span></span><br><span class="line"><span class="string">    movzx eax, byte ptr [rdi + rcx]     </span></span><br><span class="line"><span class="string">    inc byte ptr [rbp + rax - 256]      </span></span><br><span class="line"><span class="string">    inc rcx                             </span></span><br><span class="line"><span class="string">    cmp rcx, rsi                       </span></span><br><span class="line"><span class="string">    jl count_bytes                     </span></span><br><span class="line"><span class="string">init_b_max_freq_max_freq_byte:</span></span><br><span class="line"><span class="string">    xor rcx, rcx                        </span></span><br><span class="line"><span class="string">    xor rdx, rdx                         </span></span><br><span class="line"><span class="string">    xor rbx, rbx                         </span></span><br><span class="line"><span class="string">find_most_common_byte:</span></span><br><span class="line"><span class="string">    movzx eax, byte ptr [rbp + rcx - 256] </span></span><br><span class="line"><span class="string">    cmp al, dl                           </span></span><br><span class="line"><span class="string">    jle next_byte                        </span></span><br><span class="line"><span class="string">update_max_freq_and_max_freq_byte:</span></span><br><span class="line"><span class="string">    mov dl, al                           </span></span><br><span class="line"><span class="string">    mov bl, cl                           </span></span><br><span class="line"><span class="string">next_byte:</span></span><br><span class="line"><span class="string">    inc rcx                              </span></span><br><span class="line"><span class="string">    cmp rcx, 256                        </span></span><br><span class="line"><span class="string">    jl find_most_common_byte             </span></span><br><span class="line"><span class="string">return:</span></span><br><span class="line"><span class="string">    mov al, bl                          </span></span><br><span class="line"><span class="string">restore:</span></span><br><span class="line"><span class="string">    mov rsp, rbp                        </span></span><br><span class="line"><span class="string">    pop rbp                               </span></span><br><span class="line"><span class="string">    ret                                   </span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span>))</span><br><span class="line">output = p.recvall().decode()</span><br><span class="line"><span class="built_in">print</span>(output)</span><br></pre></td></tr></table></figure><p>还得沉淀</p>]]></content:encoded>
      
      
      
      <category domain="http://midnightr3d.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</category>
      
      <category domain="http://midnightr3d.top/tags/%E7%BD%91%E5%AE%89/">网安</category>
      
      
      <comments>http://midnightr3d.top/2025/01/09/Assembly%20Crash%20Course%20record/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>wsl图形化界面安装踩坑</title>
      <link>http://midnightr3d.top/2025/01/06/%E9%85%8D%E7%BD%AEwsl%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/</link>
      <guid>http://midnightr3d.top/2025/01/06/%E9%85%8D%E7%BD%AEwsl%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/</guid>
      <pubDate>Sun, 05 Jan 2025 16:53:29 GMT</pubDate>
      
      <description>&lt;p&gt;安装wsl后只有终端界面太单调了，遂网上寻找给Ubuntu添加图形界面的方法。中间遇见了一些坑，记下来以备查阅。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;主要参考：&lt;a
href=&quot;https://zhuanlan.zhihu.com/p/150555651?native.theme=1&quot;&gt;WSL2中使用VcXsrv实现xfce4图形界面+声音传输
- 知乎&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>安装wsl后只有终端界面太单调了，遂网上寻找给Ubuntu添加图形界面的方法。中间遇见了一些坑，记下来以备查阅。</p><blockquote><p>主要参考：<ahref="https://zhuanlan.zhihu.com/p/150555651?native.theme=1">WSL2中使用VcXsrv实现xfce4图形界面+声音传输- 知乎</a></p></blockquote><span id="more"></span><h2 id="vcxsrv安装与配置">VcXsrv安装与配置</h2><p>从SourceForge上下载最新的即可，</p><blockquote><p><a href="https://sourceforge.net/projects/vcxsrv/">VcXsrv Windows XServer download | SourceForge.net</a></p></blockquote><p>网站内会保持更新。</p><p>我下载的是<code>vcxsrv-64.1.20.14.0.installer.exe</code>,直接安装即可。</p><p>安装完成之后在开始菜单搜索或者在其文件夹里找到<code>xlaunch.exe</code>并启动</p><figure><img src="\images\image-20250104213215978-1735997822590-5.png"alt="image-20250104213215978" /><figcaption aria-hidden="true">image-20250104213215978</figcaption></figure><p>配置启动设置时，窗口模式使用 <code>One large window</code>，并在<code>Extra settings</code>里勾选<code>Disable access control</code>其他配置选择默认。</p><p>启动的窗口此时保持全黑。</p><figure><img src="/images/image-20250104213556580-1735997782254-3.png"alt="image-20250104213556580" /><figcaption aria-hidden="true">image-20250104213556580</figcaption></figure><p>并且一定要给VcXsrv设置通过防火墙。</p><p>启动一次xlaunch后在开始菜单里搜索<code>允许应用通过windows防火墙</code>,其中<code>VcXsrv windows xserver</code>一定要把专用和公用都设置上，不然后续会出现无法连接的情况。</p><figure><img src="/images/image-20250104214035451-1735998074299-8.png"alt="image-20250104214035451" /><figcaption aria-hidden="true">image-20250104214035451</figcaption></figure><h2 id="配置与启动xfce4">配置与启动xfce4</h2><p>安装<code>xfce4</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install -y xfce4</span><br></pre></td></tr></table></figure><p>下载好后配置 <strong><code>DISPLAY</code>[环境变量]</strong>，这里有许多坑。</p><ol type="1"><li>直接启动会出现如下问题</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DESKTOP-14VK3K3%:~$ startxfce4</span><br><span class="line">/usr/bin/startxfce4: X server already running on display :0.0</span><br><span class="line">xrdb: Connection refused</span><br><span class="line">xrdb: Can<span class="string">&#x27;t open display &#x27;</span>:0.0<span class="string">&#x27;</span></span><br><span class="line"><span class="string">Unable to init server: Could not connect: Connection refused</span></span><br><span class="line"><span class="string">xfce4-session: Cannot open display: .</span></span><br><span class="line"><span class="string">Type &#x27;</span>xfce4-session --<span class="built_in">help</span><span class="string">&#x27; for usage.</span></span><br></pre></td></tr></table></figure><p>没有配置ip地址和端口，或者直接配置成<code>0:0</code>是不能顺利启动。原因是<code>WSL2</code>其实是用<code>Hyper-V</code>技术实现的一个虚拟机,和<code>WSL1</code>的工作原理不一样。</p><ol start="2" type="1"><li>配置 <code>DISPLAY</code>信息</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先需要查看Windows系统和WSL2通信使用的虚拟网卡地址</span></span><br><span class="line">$ sudo vim /etc/resolv.conf</span><br><span class="line"><span class="comment"># nameserver后面的地址就是Windows系统虚拟网卡的地址,记一下,同时需要取消下面两行内容的注释,禁用自动重新生成配置文件,否则重启后这个地址会变</span></span><br><span class="line">[network]</span><br><span class="line">generateResolvConf = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ vim ~/.bashrc</span><br><span class="line"><span class="comment"># 在文件最后追加下面内容,地址使用上面查看到的</span></span><br><span class="line"><span class="built_in">export</span> DISPLAY=192.168.112.1:0</span><br></pre></td></tr></table></figure><p>或者使用下面的配置来动态获取ip信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自动在对应文件中检索相应信息</span></span><br><span class="line"><span class="built_in">export</span> DISPLAY=<span class="string">&quot;`grep nameserver /etc/resolv.conf | sed &#x27;s/nameserver //&#x27;`:0&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面的效率更高。使用这两种就不用去掉/etc/resolv.conf文件中那两行的注释</span></span><br><span class="line"><span class="built_in">export</span> DISPLAY=$(<span class="built_in">cat</span> /etc/resolv.conf | grep nameserver | awk <span class="string">&#x27;&#123;print $2&#125;&#x27;</span>):0</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>同时，如果是是使用最新的Ubuntu系统，也就是<code>ubuntu 22.04</code>或者之后的，需要在<code>.bashrc</code>加入<code>export WAYLAND_DISPLAY=$DISPLAY</code>，因为</li></ol><p><code>ubuntu22</code>默认使用WAYLAND而不是x11作为显示服务。之后记得<code>source ~/.bashrc</code>保存一下配置。</p><ol start="4" type="1"><li>如果上面都没起效，可以看看wsl版本是否有问题，在powershell里输入<code>wsl update</code>更新一下。当然如果是现在开始弄wsl的大概率是最新版本。</li></ol><h2 id="图形界面显示问题">图形界面显示问题</h2><p>折腾好后<code>xlaunch</code>的界面仍然是一片黑</p><figure><img src="/images/image-20250105215526302.png"alt="image-20250105215526302" /><figcaption aria-hidden="true">image-20250105215526302</figcaption></figure><p>但是任务栏里却有Ubuntu的面板</p><figure><img src="/images/image-20250105215618102.png"alt="image-20250105215618102" /><figcaption aria-hidden="true">image-20250105215618102</figcaption></figure><p>除了浏览器，其余应用，终端，文件管理器等都能正常使用。屏幕最上面还有横栏</p><figure><img src="/images/image-20250106002134830.png"alt="image-20250106002134830" /><figcaption aria-hidden="true">image-20250106002134830</figcaption></figure><p>启动时的报错信息如下，每次点击应用都会增加报错，估计是因为没有在正确的屏幕上显示。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DESKTOP-14VK3K3% startxfce4</span><br><span class="line">/usr/bin/startxfce4: X server already running on display :0</span><br><span class="line">gpg-agent: a gpg-agent is already running - not starting a new one</span><br><span class="line">Another Window Manager (Weston WM) is already running on screen :0.0</span><br><span class="line">To replace the current window manager, try <span class="string">&quot;--replace&quot;</span></span><br><span class="line"></span><br><span class="line">(xfwm4:1871): xfwm4-WARNING **: 22:49:38.642: Could not find a screen to manage, exiting</span><br><span class="line">xfsettingsd: Another clipboard manager is already running.</span><br><span class="line"></span><br><span class="line">(xfsettingsd:1876): xfsettingsd-WARNING **: 22:49:38.771: Failed to get the _NET_NUMBER_OF_DESKTOPS property.</span><br></pre></td></tr></table></figure><p>像是没有和xserver的服务器连接。</p><p>另一方面，安装wslg的应用并不能完整的体验图形化linux的使用，里面只有分散的图形化程序，并非完全的linux桌面。</p><p>+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++</p><p>​ <strong>以上是分割线</strong></p><p>最近折腾neovim发现自己之前稀里糊涂的安装了<code>zsh</code>作为shell，<code>bash</code>根本就不管事，我还把所有的配置都放在了<code>bashrc</code>里,也难怪没有图形界面没有正常出现。。。。麻烦的是后面还得自己把配置都写进<code>zshrc</code>。。</p>]]></content:encoded>
      
      
      
      <category domain="http://midnightr3d.top/tags/linux/">linux</category>
      
      
      <comments>http://midnightr3d.top/2025/01/06/%E9%85%8D%E7%BD%AEwsl%E5%9B%BE%E5%BD%A2%E7%95%8C%E9%9D%A2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>鹏城杯三道</title>
      <link>http://midnightr3d.top/2024/11/20/PCB/</link>
      <guid>http://midnightr3d.top/2024/11/20/PCB/</guid>
      <pubDate>Tue, 19 Nov 2024 16:00:56 GMT</pubDate>
      
      <description>&lt;p&gt;日常做不出题。。。要是功力有这师傅一半深就好了...orz...</description>
      
      
      
      <content:encoded><![CDATA[<p>日常做不出题。。。要是功力有这师傅一半深就好了...orz...<span id="more"></span></p><h1 id="rafflesia">Rafflesia</h1><p>去花指令后即可得到</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">en = &#x27;H@^jHwpsH)[jH&#123;M/\\tBBK_|-O&#123;W.iJZ7\\)|~zaB^H+Lwv&#123;SS|-j@\\_[Y&#x27;</span><br><span class="line">de = &#x27;&#x27;</span><br><span class="line">for i in range(len(en)):</span><br><span class="line">    de += chr(ord(en[i])^0x18)</span><br><span class="line">print(de)</span><br></pre></td></tr></table></figure><p>PXFrPohkP1CrPcU7DlZZSGd5WcO6qRB/D1dfbyZFP3ToncKKd5rXDGCA</p><p>接着是tls改了表</p><p>HElRNYGmBOMWnbDvUCgcpu1QdPqJIS+iTry39KXse4jLh/x26Ff5Z7Vokt8wzAa0</p><p>赛博厨子解密得到</p><p>flag{8edae458-4tf3-2ph2-9f26-1f8719ec8f8d}</p><h1 id="joyvbs">joyVBS</h1><p>用vbsedit打开，运行即可得到源码，找到</p><p><imgsrc="https://cdn.nlark.com/yuque/0/2024/png/46558077/1731125138500-95762fa3-048f-492e-9743-364b3980fb24.png" /></p><p><imgsrc="https://cdn.nlark.com/yuque/0/2024/png/46558077/1731125126565-879d9897-bfba-4445-94dd-0baa06030a37.png" /></p><p>flag{VB3_1s_S0_e1sY_4_u_r1gh3?btw_1t_iS_a1s0_Us3Fu1_a3D_1nTe3eSt1ng!}</p><h1 id="re5">RE5</h1><p><imgsrc="https://cdn.nlark.com/yuque/0/2024/png/46558077/1731141933542-86ef607f-e6f2-4cb2-b420-23367470b04a.png" /></p><p>主要加密函数</p><p><imgsrc="https://cdn.nlark.com/yuque/0/2024/png/46558077/1731142088937-85e64989-443d-4705-9339-6cf35fe43a06.png" /></p><p>发现是魔改的tea。</p><p>我们尝试进行解密，钥匙为1 2 3 4</p><p>但是不对，猜测有tls，继续找</p><p><imgsrc="https://cdn.nlark.com/yuque/0/2024/png/46558077/1731142336341-f5ace0a6-c960-4b5b-af5c-4d71c5d696c1.png" /></p><p>函数挺少的，我们直接在函数窗口一个一个找</p><p>然后发现这个</p><p><imgsrc="https://cdn.nlark.com/yuque/0/2024/png/46558077/1731142370389-136926e2-a4e5-4dae-986a-5fb7fafe77e3.png" /></p><p>我们发现他用0作为种子给到srand里面，用rand进行传值</p><p><imgsrc="https://cdn.nlark.com/yuque/0/2024/png/46558077/1731142701105-229c5eb2-cbf1-4acd-b69c-93962d16684b.png" /></p><p>第二次定位</p><p><imgsrc="https://cdn.nlark.com/yuque/0/2024/png/46558077/1731143145758-a1a502a6-e6e6-4c4c-be10-6c0fc8ffd2da.png" /></p><p>我们动调发现了</p><p>我们打印一下rand值：</p><p><imgsrc="https://cdn.nlark.com/yuque/0/2024/png/46558077/1731142866562-ec8e2a61-0624-4678-8262-6e5aafc79950.png" /></p><p><imgsrc="https://cdn.nlark.com/yuque/0/2024/png/46558077/1731143109489-6dbcb043-5448-4a32-8198-52dcd983d860.png" /></p><p>就是delta加上rand</p><p>直接写个tea解密脚本就好</p><p>这个其实还是不对，我们用初始值进行查看发现key被改为了2 2 3 3</p><p><imgsrc="https://cdn.nlark.com/yuque/0/2024/png/46558077/1731144171539-851513ab-e301-49d9-9ee2-c15fefd25cf1.png" /></p><p>是通过异常来控制的</p><p>这下对了</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">tea</span><span class="params">(<span class="type">uint32_t</span>* v)</span> &#123;</span><br><span class="line">    <span class="type">uint32_t</span> v6 = v[<span class="number">0</span>], v5 = v[<span class="number">1</span>], i;</span><br><span class="line">    <span class="type">uint32_t</span> v4 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">uint32_t</span> rand1[<span class="number">64</span>] = &#123;&#125;;</span><br><span class="line">    <span class="type">uint32_t</span> a2[<span class="number">4</span>] = &#123;</span><br><span class="line">        <span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        rand1[i] = rand();</span><br><span class="line">        <span class="comment">//printf(&quot;0x%x,&quot;, randnum[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        v4 += randnum[i];</span><br><span class="line">        <span class="comment">//printf(&quot;0x%x,&quot;, v4);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        v5 -= (a2[<span class="number">3</span>] + (v6 &gt;&gt; <span class="number">5</span>)) ^ (v4 + v6) ^ (a2[<span class="number">2</span>] + <span class="number">16</span> * v6);</span><br><span class="line">        v6 -= (a2[<span class="number">1</span>] + (v5 &gt;&gt; <span class="number">5</span>)) ^ (v4 + v5) ^ (a2[<span class="number">0</span>] + <span class="number">16</span> * v5);</span><br><span class="line">        v4 -= randnum[<span class="number">32</span><span class="number">-1</span>-i];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    v[<span class="number">0</span>] = v6; v[<span class="number">1</span>] = v5;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">uint32_t</span> data[<span class="number">8</span>] = &#123; <span class="number">0x0EA2063F8</span>,<span class="number">0x8F66F252</span>,<span class="number">0x902A72EF</span>,<span class="number">0x411FDA74</span>,<span class="number">0x19590d4d</span>, <span class="number">0xcae74317</span>, <span class="number">0x63870f3f</span>, <span class="number">0xd753ae61</span> &#125;;</span><br><span class="line">    <span class="type">uint32_t</span> temp[<span class="number">2</span>] = &#123; <span class="number">0</span>,<span class="number">0</span> &#125;;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    srand(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">8</span>; i += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        temp[<span class="number">0</span>] = data[i];</span><br><span class="line">        temp[<span class="number">1</span>] = data[i + <span class="number">1</span>];</span><br><span class="line">        tea(temp);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c%c%c%c%c%c%c%c&quot;</span>, *((<span class="type">char</span>*)&amp;temp[<span class="number">0</span>] + <span class="number">0</span>), *((<span class="type">char</span>*)&amp;temp[<span class="number">0</span>] + <span class="number">1</span>), *((<span class="type">char</span>*)&amp;temp[<span class="number">0</span>] + <span class="number">2</span>), *((<span class="type">char</span>*)&amp;temp[<span class="number">0</span>] + <span class="number">3</span>), *((<span class="type">char</span>*)&amp;temp[<span class="number">1</span>] + <span class="number">0</span>), *((<span class="type">char</span>*)&amp;temp[<span class="number">1</span>] + <span class="number">1</span>), *((<span class="type">char</span>*)&amp;temp[<span class="number">1</span>] + <span class="number">2</span>), *((<span class="type">char</span>*)&amp;temp[<span class="number">1</span>] + <span class="number">3</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>d555ce75ec293c8ed232d83dffb0ff82</p>]]></content:encoded>
      
      
      
      <category domain="http://midnightr3d.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</category>
      
      <category domain="http://midnightr3d.top/tags/CTF/">CTF</category>
      
      
      <comments>http://midnightr3d.top/2024/11/20/PCB/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Compute 101</title>
      <link>http://midnightr3d.top/2024/11/11/Compute%20101%20record/</link>
      <guid>http://midnightr3d.top/2024/11/11/Compute%20101%20record/</guid>
      <pubDate>Sun, 10 Nov 2024 16:00:01 GMT</pubDate>
      
      <description>&lt;p&gt;记录在pwncollege里的一些学习笔记</description>
      
      
      
      <content:encoded><![CDATA[<p>记录在pwncollege里的一些学习笔记<span id="more"></span></p><h2 id="tracing-syscalls">Tracing Syscalls</h2><p>As you write larger and larger programs, you (yes, even you!) mightmake mistakes when implementing certain functionality, introducing<em>bugs</em> into your programs. Throughout this module, we'll go overa few tools and techniques for <em>debugging</em> your program. Thefirst one is pretty simple: the <strong>s</strong>yscall<strong>trace</strong>r, <code>strace</code>.</p><p>Given a program to run, <code>strace</code> will use functionality ofthe Linux operating system to introspect and record every system callthat the program invokes, and its result. For example, let's look at ourprogram from the previous challenge:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">hacker@dojo:~$ strace /tmp/your-program</span><br><span class="line">execve(&quot;/tmp/your-program&quot;, [&quot;/tmp/your-program&quot;], 0x7ffd48ae28b0 /* 53 vars */) = 0</span><br><span class="line">exit(42)                                 = ?</span><br><span class="line">+++ exited with 42 +++</span><br><span class="line">hacker@dojo:~$</span><br></pre></td></tr></table></figure><p>As you can see, <code>strace</code> reports what system calls aretriggered, what parameters were passed to them, and what data theyreturned. The syntax used here for output is<code>system_call(parameter, parameter, parameter, ...)</code>. Thissyntax is borrowed from a programming language called C, but we don'thave to worry about that yet. Just keep in mind how to read thisspecific syntax.</p><p>In this example, <code>strace</code> reports two system calls: thesecond is the <code>exit</code> system call that your program uses torequest its own termination, and you can see the parameter you passed toit (42). The first is an <code>execve</code> system call. We'll learnabout this system call later, but it's somewhat of a yin to<code>exit</code>'s yang: it starts a new program (in this case,<code>your-program</code>). It's not actually invoked by<code>your-program</code> in this case: its detection by<code>strace</code> is a weird artifact of how <code>strace</code>works, that we'll investigate later.</p><p>In the final line, you can see the result of <code>exit(42)</code>,which is that the program exits with an exit code of<code>42</code>!</p><p>Now, the <code>exit</code> syscall is easy to introspect withoutusing <code>strace</code> --- after all, part of the point of<code>exit</code> is to give you an exit code that you can access. Butother system calls are less visible. For example, the <code>alarm</code>system call (syscall number 37!) will set a timer in the operatingsystem, and when that many seconds pass, Linux will terminate theprogram. The point of <code>alarm</code> is to, e.g., kill the programwhen it's frozen, but in this case, we'll use <code>alarm</code> topractice our <code>strace</code> snooping!</p><p>In this challenge, you must <code>strace</code> the<code>/challenge/trace-me</code> program to figure out what value itpasses as a parameter to the <code>alarm</code> system call, then call<code>/challenge/submit-number</code> with the number you've retrievedas the argument. Good luck!</p><p>总结：</p><ol type="1"><li>使用strace跟踪/challenge/trace-me程序。</li><li>观察并记录alarm系统调用的参数值。</li><li>调用/challenge/submit-number，将上一步中找到的数字作为参数传递。</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">hacker@your<span class="literal">-first-program</span>~tracing<span class="literal">-syscalls</span>:/challenge<span class="variable">$</span> strace  ./<span class="built_in">trace-me</span> </span><br><span class="line">execve(<span class="string">&quot;./trace-me&quot;</span>, [<span class="string">&quot;./trace-me&quot;</span>], <span class="number">0</span>x7ffd869ca7f0 /* <span class="number">28</span> vars */) = <span class="number">0</span></span><br><span class="line">alarm(<span class="number">18759</span>)                            = <span class="number">0</span></span><br><span class="line"><span class="keyword">exit</span>(<span class="number">0</span>)                                 = ?</span><br><span class="line">+++ exited with <span class="number">0</span> +++</span><br><span class="line"><span class="comment"># 提交数字即可</span></span><br></pre></td></tr></table></figure><h2 id="moving-betweening-registers">moving betweening registers</h2><p>Okay, let's learn about one more register: <code>rsi</code>! Like<code>rdi</code>, <code>rsi</code> is a place you can park some data.For example:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov rsi, 42</span><br></pre></td></tr></table></figure><p>Of course, you can also move data around between registers!Watch:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mov rsi, 42</span><br><span class="line">mov rdi, rsi</span><br></pre></td></tr></table></figure><p>Just like the first line there moves <code>42</code> into<code>rsi</code>, the second like moves the value in <code>rsi</code> to<code>rdi</code>. Here, we have to mention one complication: by<em>move</em>, we really mean <em>set</em>. After the snippet above,<code>rsi</code> <em>and</em> <code>rdi</code> will be <code>42</code>.It's a mystery as to why the <code>mov</code> was chosen rather thansomething reasonable like <code>set</code> (even very knowledgeablepeople resort to <ahref="https://retrocomputing.stackexchange.com/questions/12968/why-is-the-processor-instruction-called-move-not-copy">diversespeculation</a> when asked), but it was, and here we are.</p><p>Anyways, on to the challenge! In this challenge, we will store asecret value in the <code>rsi</code> register, and your program mustexit with that value as the return code. Since <code>exit</code> usesthe value stored in <code>rdi</code> as the return code, you'll need tomove the secret value in <code>rsi</code> into <code>rdi</code>. Goodluck!</p><p>总结：</p><ol type="1"><li>在rsi寄存器中存储一个秘密值。</li><li>编写一个程序，该程序需要将rsi寄存器中的秘密值移动到rdi寄存器中。</li><li>程序必须使用exit函数退出，并且退出时的返回码应为rsi寄存器中存储的秘密值（此时已移动到rdi中，因为exit函数使用rdi的值作为返回码）。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rdi, rsi</span><br><span class="line">mov rax,60 ;设置syscall号为exit（60）</span><br><span class="line">syscall </span><br><span class="line">;调用check即可</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="loading-from-memory">loading from memory</h2><p>As seen by your program, computer memory is a huge place where datais housed. Like houses on a street, every part of memory has a numeric<em>address</em>, and like houses on a street, these numbers are(mostly) sequential. Modern computers have enormous amounts of memory,and the view of memory of a typical modern program actually has largegaps (think: a portion of the street that hasn't had houses built on it,and so those addresses are skipped). But these are all details: thepoint is, computers store data, mostly sequentially, in memory.</p><p>In this level, we will practice accessing data stored in memory. Howmight we do this? Recall that to move a value into a register, we didsomething like:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov rdi, 31337</span><br></pre></td></tr></table></figure><p>After this, the value of is . Cool. Well, we can use the sameinstruction to access memory! There is another format of the commandthat, instead, uses the second parameter as an address to access memory!Consider that our memory looks like this:<code>rdi``31337</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  Address │ Contents</span><br><span class="line">+────────────────────+</span><br><span class="line">│ 31337   │ 42       │</span><br><span class="line">+────────────────────+</span><br></pre></td></tr></table></figure><p>To access the memory contents at memory address 31337, you would cando:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov rdi, [31337]</span><br></pre></td></tr></table></figure><p>When the CPU executes this instruction, it of course understands thatis an <em>address</em>, not a raw value. If you think of the instructionas a person telling the CPU what to do, and we stick with our "houses ona street" analogy, then instead of just handing the CPU data, theinstruction/person <em>points at a house on the street</em>. The CPUwill then go to that address, ring its doorbell, open its front door,drag the data that's in there out, and put it into . Thus, the in thiscontext is the <em>memory address</em> and serves to <em>point to</em>the data stored at that memory address. After this instruction executes,the value stored in will be !<code>31337``rdi``31337``rdi``42</code></p><p>Let's put this into practice! I've stored a secret number at memoryaddress , as so:<code>133700</code></p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  Address │ Contents</span><br><span class="line">+────────────────────+</span><br><span class="line">│ 133700  │ ???      │</span><br><span class="line">+────────────────────+</span><br></pre></td></tr></table></figure><p>You must retrieve this secret number and use it as the exit code foryour program. To do this, you must read it into , whose value, if yourecall, is the first parameter to and is used as the exit code. Goodluck!<code>rdi``exit</code></p><p>总结:</p><ol type="1"><li>访问地址133700处的数据</li><li>把该地址的数据读取到rdi中</li><li>使用这个数据作为退出参数</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rdi ,[133700] <span class="comment">#记住地址的表示</span></span><br><span class="line">mov rax ,60</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="dereferencing-pointers">dereferencing pointers</h2><p>Did you prefer to access memory at <code>133700</code> or at<code>123400</code>? Your answer might say something about yourpersonality, but it's not super relevant from a technical perspective.In fact, in most cases, you don't deal with actual memory addresses whenwriting programs at all!</p><p>How is this possible? Well, typically, memory addresses are stored inregisters, and we use the values in the registers to point to data inmemory! Let's start with this memory configuration:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  Address │ Contents</span><br><span class="line">+────────────────────+</span><br><span class="line">│ 133700  │ 42       │</span><br><span class="line">+────────────────────+</span><br></pre></td></tr></table></figure><p>And consider this assembly snippet:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov rdi, 133700</span><br></pre></td></tr></table></figure><p>Now, what you have is the following situation:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">  Address │ Contents</span><br><span class="line">+────────────────────+</span><br><span class="line">│ 133700  │ 42       │◂┐</span><br><span class="line">+────────────────────+ │</span><br><span class="line">                       │</span><br><span class="line"> Register │ Contents   │</span><br><span class="line">+────────────────────+ │</span><br><span class="line">│ rdi     │ 133700   │─┘</span><br><span class="line">+────────────────────+</span><br></pre></td></tr></table></figure><p><code>rdi</code> now holds a value that corresponds with the addressof the data that want to load! Let's load it:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov rdi, [rax]</span><br></pre></td></tr></table></figure><p>Here, we are accessing memory, but instead of specifying a fixedaddress like <code>133700</code> for the memory read, we're using thevalue stored in <code>rax</code> as the memory address. By containingthe memory address, <code>rax</code> is a <em>pointer</em> that<em>points to</em> the data we want to access! When we use<code>rax</code> in lieu of directly specifying the address that itstores to access the memory address that it references, we call this<em>dereferencing</em> the pointer. In the above example, we<em>dereference</em> <code>rax</code> to load the data it points to (thevalue <code>42</code> at address <code>133700</code>) into<code>rdi</code>. Neat!</p><p>This also drives home another point: these registers are <em>generalpurpose</em>! Just because we've been using <code>rax</code> as thesyscall index in our challenges so far doesn't mean that it can't haveother uses as well. Here, it's used as a pointer to our secret data inmemory.</p><p>Similarly, the <em>data</em> in the registers doesn't have animplicit purpose. If <code>rax</code> contains the value<code>133700</code> and we write <code>mov rdi, [rax]</code>, the CPUuses the value as a memory address to dereference. But if we write<code>mov rdi, rax</code> in the same conditions, the CPU just happilyputs <code>133700</code> into <code>rdi</code>. To the CPU, data isdata; it only becomes differentiated when it's used in differentways.</p><p>In this challenge, we've initialized <code>rax</code> to contain theaddress of the secret data we've stored in memory. Dereference<code>rax</code> to the secret data into <code>rdi</code> and use it asthe exit code of the program to get the flag!</p><p>讲了个类似C语言中指针的用法。第一次做成了这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov rdi, [rax]</span><br><span class="line">mov eax, rdi</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">;报错：Your assembly did not assemble cleanly. The errors:</span><br><span class="line">;Error: unsupported instruction `mov&#x27;</span><br></pre></td></tr></table></figure><p>后来发现<code>mov eax, rdi</code>的问题。<code>eax</code> 是 32位寄存器，而 <code>rdi</code> 是 64位寄存器，不能直接传参,而且没搞懂程序的运行原理。修改为以下后通过：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rdi,[rax];rdi 负责传参</span><br><span class="line">mov rax,60 ;rax负责调起exit()</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>补充：<code>60</code> -&gt; <code>exit</code>：退出程序</p><p>​ <code>1</code> -&gt; <code>write</code>：写数据</p><p>​ <code>3</code> -&gt; <code>read</code>：读数据</p><p>​ <code>9</code> -&gt; <code>mmap</code>：内存映射</p><p>等等。</p><h2 id="dereferencing-with-offsets">dereferencing with offsets</h2><p>So now you can dereference pointers in memory like a pro! Butpointers don't always point directly at the data you need. Sometimes,for example, a pointer might point to a collection of data (say, anentire book), and you'll need to reference partway into this collectionfor the specific data you need.</p><p>For example, if your pointer (say, <code>rdi</code>) points to asequence of numbers in memory, as so:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  Address │ Contents</span><br><span class="line">+────────────────────+</span><br><span class="line">│ 133700  │ 50       │◂┐</span><br><span class="line">│ 133701  │ 42       │ │</span><br><span class="line">│ 133702  │ 99       │ │</span><br><span class="line">│ 133703  │ 14       │ │</span><br><span class="line">+────────────────────+ │</span><br><span class="line">                       │</span><br><span class="line"> Register │ Contents   │</span><br><span class="line">+────────────────────+ │</span><br><span class="line">│ rdi     │ 133700   │─┘</span><br><span class="line">+────────────────────+</span><br></pre></td></tr></table></figure><p>If you want the second number of that sequence, you could do:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [rdi+1]</span><br></pre></td></tr></table></figure><p>Wow, super simple! In memory terms, we call these number slots<em>bytes</em>: each memory address represents a specific byte ofmemory. The above example is accessing memory 1 byte after the memoryaddress pointed to by <code>rax</code>. In memory terms, we call this 1byte difference an <em>offset</em>, so in this example, there is anoffset of 1 from the address pointed to by <code>rdi</code>.</p><p>Let's practice this concept. As before, we will initialize<code>rdi</code> to point at the secret value, but not <em>directly</em>at it. This time, the secret value will have an offset of 8 bytes fromwhere <code>rdi</code> points, something analogous to this:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  Address │ Contents</span><br><span class="line">+────────────────────+</span><br><span class="line">│ 31337   │ 0        │◂┐</span><br><span class="line">│ 31337+1 │ 0        │ │</span><br><span class="line">│ 31337+2 │ 0        │ │</span><br><span class="line">│ 31337+3 │ 0        │ │</span><br><span class="line">│ 31337+4 │ 0        │ │</span><br><span class="line">│ 31337+5 │ 0        │ │</span><br><span class="line">│ 31337+6 │ 0        │ │</span><br><span class="line">│ 31337+7 │ 0        │ │</span><br><span class="line">│ 31337+8 │ ???      │ │</span><br><span class="line">+────────────────────+ │</span><br><span class="line">                       │</span><br><span class="line"> Register │ Contents   │</span><br><span class="line">+────────────────────+ │</span><br><span class="line">│ rdi     │ 31337    │─┘</span><br><span class="line">+────────────────────+</span><br></pre></td></tr></table></figure><p>Of course, the actual memory address is not <code>31337</code>. We'llchoose it randomly, and store it in <code>rdi</code>. Go dereference<code>rdi</code> with offset <code>8</code> and get the flag!</p><p>仍然是类似指针的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rdi,[rdi+8]</span><br><span class="line">mov rax ,60</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="double-dereference">double dereference</h2><p>In the last few levels, you have:</p><ul><li>Used an address that we told you (in one level, <code>133700</code>,and in another, <code>123400</code>) to load a secret value frommemory.</li><li>Used an address that we put into <code>rax</code> for you to load asecret value from memory.</li><li>Used an address that we told you (in the last level,<code>567800</code>) to load <em>the address</em> of a secret value frommemory into a register, then used that register as a pointer to retrievethe secret value from memory!</li></ul><p>Let's put those last two together. In this challenge, we stored our<code>SECRET_VALUE</code> in memory at the address<code>SECRET_LOCATION_1</code>, then stored<code>SECRET_LOCATION_1</code> in memory at the address<code>SECRET_LOCATION_2</code>. Then, we put<code>SECRET_ADDRESS_2</code> into <code>rax</code>! The result lookssomething like this, using <code>133700</code> for<code>SECRET_LOCATION_1</code> and 123400 for<code>SECRET_LOCATION_2</code> (not, in the real challenge, these valueswill be different and hidden from you!):</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    Address │ Contents</span><br><span class="line">  +────────────────────+</span><br><span class="line">┌─│ 133700  │ 123400   │◂┐</span><br><span class="line">│ +────────────────────+ │</span><br><span class="line">└▸│ 123400  │ 42       │ │</span><br><span class="line">  +────────────────────+ │</span><br><span class="line">                         │</span><br><span class="line">                         │</span><br><span class="line">                         │</span><br><span class="line">   Register │ Contents   │</span><br><span class="line">  +────────────────────+ │</span><br><span class="line">  │ rdi     │ 133700   │─┘</span><br><span class="line">  +────────────────────+</span><br></pre></td></tr></table></figure><p>Here, you will need to perform two memory reads: one dereferencing<code>rax</code> to read <code>SECRET_LOCATION_1</code> from thelocation that <code>rax</code> is pointing to (which is<code>SECRET_LOCATION_2</code>), and the second one dereferencingwhatever register now holds <code>SECRET_LOCATION_1</code> to read<code>SECRET_VALUE</code> into <code>rdi</code>, so you can use it asthe exit code!</p><p>That sounds like a lot, but you've done basically all of thisalready. Go put it together!</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rax, [rax]    ; 第一步：通过rax指向的地址读取SECRET_LOCATION_1（第二层地址）</span><br><span class="line">mov rdi, [rax]    ; 第二步：通过rax指向的地址读取SECRET_VALUE</span><br><span class="line">mov rax, 60       </span><br><span class="line">syscall           </span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 x86-64架构中，系统调用的参数是通过寄存器传递的。根据系统调用的约定：</p><ul><li><code>rdi</code> 用于传递第一个参数。</li><li><code>rsi</code> 用于传递第二个参数。</li></ul><h2 id="triple-dereference">triple dereference</h2><p>Okay, let's stretch that to one more depth! We've added an additionallevel of indirection in this challenge, so now you'll need<em>three</em> dereferences to find the secret value. Something likethis:</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">    Address │ Contents</span><br><span class="line">  +────────────────────+</span><br><span class="line">┌─│ 133700  │ 123400   │◂──┐</span><br><span class="line">│ +────────────────────+   │</span><br><span class="line">└▸│ 123400  │ 100000   │─┐ │</span><br><span class="line">  +────────────────────+ │ │</span><br><span class="line">  │ 100000  │ 42       │◂┘ │</span><br><span class="line">  +────────────────────+   │</span><br><span class="line">                           │</span><br><span class="line">                           │</span><br><span class="line">   Register │ Contents     │</span><br><span class="line">  +────────────────────+   │</span><br><span class="line">  │ rdi     │ 133700   │───┘</span><br><span class="line">  +────────────────────+</span><br></pre></td></tr></table></figure><p>As you can see, we'll place the first address that you mustdereference into rdi. Go get the value!</p><p>类似的操作</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">mov rdi,[rdi]</span><br><span class="line">mov rax,[rdi]</span><br><span class="line">mov rdi,[rax]</span><br><span class="line">mov rax,60</span><br><span class="line">syscall</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>rsi</code> 是用于传递参数的寄存器，而<strong><code>rdi</code></strong>才是系统调用时的退出代码传递寄存器。</p><h2 id="writing-output">writing output</h2><p>Let's learn to write text!</p><p>Unsurprisingly, your program writes text to the screen by invoking asystem call. Specifically, this is the <code>write</code> system call,and its syscall number is <code>1</code>. However, the write system callalso needs to specify, via its parameters, <em>what</em> data to writeand <em>where</em> to write it to.</p><p>You may remember, from the <ahref="https://pwn.college/linux-luminarium/piping">Practicing Piping</a>module of the <a href="https://pwn.college/linux-luminarium">LinuxLuminarium</a> dojo, the concept of <em>File Descriptors</em> (FDs). Asa reminder, each process starts out with three FDs:</p><ul><li><strong>FD 0:</strong> Standard <em>Input</em> is the channelthrough which the process takes input. For example, your shell usesStandard Input to read the commands that you input.</li><li><strong>FD 1:</strong> Standard <em>Output</em> is the channelthrough which processes output normal data, such as the flag when it isprinted to you in previous challenges or the output of utilities such as<code>ls</code>.</li><li><strong>FD 2:</strong> Standard <em>Error</em> is the channelthrough which processes output error details. For example, if youmistype a command, the shell will output, over standard error, that thiscommand does not exist.</li></ul><p>It turns out that, in your <code>write</code> system call, this ishow you specify <em>where</em> to write the data to! The first (andonly) parameter to your <code>exit</code> system call was your exit code(<code>mov rdi, 42</code>), and the first (but, in this case, not only!)parameter to <code>write</code> is the file descriptor. If you want towrite to standard output, you would set <code>rdi</code> to 1. If youwant to write to standard error, you would set <code>rdi</code> to 2.Super simple!</p><p>This leaves us with <em>what</em> to write. Now, you could imagine aworld where we specify what to write through yet another registerparameter to the <code>write</code> system call. But these registersdon't fit a ton of data, and to write out a long story like thischallenge description, you'd need to invoke the <code>write</code>system call multiple times. Relatively speaking, this has a lot ofperformance cost --- the CPU needs to switch from executing theinstructions of your program to executing the instructions of Linuxitself, do a bunch of housekeeping computation, interact with yourhardware to get the actual pixels to show up on your screen, and thenswitch back. This is slow, and so we try to minimize the number of timeswe invoke system calls.</p><p>Of course, the solution to this is to write multiple characters atthe same time. The <code>write</code> system call does this by taking<em>two</em> parameters for the "what": a <em>where</em> (in memory) tostart writing from and a <em>how many</em> characters to write. Theseparameters are passed as the second and third parameter to<code>write</code>. In the kinda-C syntax that we learned from<code>strace</code>, this would be:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write(file_descriptor, memory_address, number_of_characters_to_write)</span><br></pre></td></tr></table></figure><p>For a more concrete example, if you wanted to write 10 charactersfrom memory address 1337000 to standard output (file descriptor 1), thiswould be:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">write(<span class="number">1</span>, <span class="number">1337000</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><p>Wow, that's simple! Now, how do we actually specify theseparameters?</p><ol type="1"><li>We'll pass the first parameter of a system call, as we reviewedabove, in the <code>rdi</code> register.</li><li>We'll pass the second parameter via the <code>rsi</code> register.The agreed-upon convention in Linux is that <code>rsi</code> is used asthe second parameter to system calls.</li><li>We'll pass the third parameter via the <code>rdx</code> register.This is the most confusing part of this entire module: <code>rdi</code>(the register holding the first parameter) has such a similar name to<code>rdx</code> that it's really easy to mix up and, unfortunately, thenaming is this way for historic reasons and is here to stay. Oh well...It's just something we have to be careful about. Maybe a mnemonic like"<code>rdi</code> is the <strong>i</strong>nitial parameter while<code>rdx</code> is the <strong>x</strong>tra parameter"? Or just thinkof it as having to keep track of different friends with similar names,and you'll be fine.</li></ol><p>And, of course, the <code>write</code> syscall index into<code>rax</code> itself: <code>1</code>. Other than the <code>rdi</code>vs <code>rdx</code> confusion, this is really easy!</p><p>Now, you know how to point a register at a memory address (from the<a href="https://pwn.college/computing-101/memory">Memory</a> module!),and yo know how to set the system call number, and how to set the restof the registers. So, this should be cake!</p><p>Similar to before, we wrote a single secret character value intomemory at address <code>1337000</code>. Call <code>write</code> to thatsingle character (for now! We'll do multiple-character writes later)value onto standard out, and we'll give you the flag!</p><p>如何输出某个地址上的数值？？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mov rax,1</span><br><span class="line">mov rdi,1</span><br><span class="line">mov rsi,1337000</span><br><span class="line">mov rdx,1</span><br><span class="line">syscall</span><br></pre></td></tr></table></figure><p><strong><code>rax</code></strong>：存储系统调用号，<code>1</code>对应于 <code>write</code>。</p><p><strong><code>rdi</code></strong>：存储文件描述符，<code>1</code>是标准输出。</p><p><strong><code>rsi</code></strong>：存储要写的数据的内存地址，这里假设数据存储在地址<code>0x1337000</code>。</p><p><strong><code>rdx</code></strong>：存储要写入的字节数，这里是 1个字节。</p><p><strong><code>syscall</code></strong>：执行系统调用，将前面设置的寄存器参数传递给内核。</p><p>依据x86_64 架构下的调用约定，即系统调用时，前四个参数分别通过<code>rdi</code>, <code>rsi</code>, <code>rdx</code>, 和<code>r10</code> 等寄存器传递。<code>rax</code>存储系统调用编号，后面的寄存器则用来传递具体的参数值。</p><h2 id="chaining-syscalls">chaining syscalls</h2><p>Okay, our previous solution wrote output but then crashed. In thislevel, you will write output, and then <em>not</em> crash!</p><p>We'll do this by invoking the system call, and then invoking thesystem call to cleanly exit the program. How do we invoke two systemcalls? Just like you invoke two instructions! First, you set up thenecessary registers and invoke , then you set up the necessary registersand invoke <code>exit!</code>write<code>exit</code>write`</p><p>Your previous solution had 5 instructions (setting , setting ,setting , setting , and ). This one should have those 5, plus three morefor (setting to the exit code, setting to syscall index 60, and ). Forthis level, let's exit with exit code!<code>rdi``rsi``rdx``rax``syscall``exit``rdi``rax``syscall``42</code></p><p>为了避免程序崩溃，需要调用exit（）退出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">mov rax,1</span><br><span class="line">mov rdi,1</span><br><span class="line">mov rsi,1337000</span><br><span class="line">mov rdx,1</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line">mov rdi,42</span><br><span class="line">mov rax,60</span><br><span class="line">syscall</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ol type="1"><li><strong>第一步（<code>write</code>）</strong>：<ul><li>将 <code>rax</code> 设置为 <code>1</code>，表示调用<code>write</code> 系统调用。</li><li>将 <code>rdi</code> 设置为<code>1</code>，表示目标文件描述符是标准输出（stdout）。</li><li>将 <code>rsi</code> 设置为<code>0x1337000</code>，这是要输出的数据的内存地址。</li><li>将 <code>rdx</code> 设置为 <code>1</code>，表示只写入 1个字节。</li><li>使用 <code>syscall</code> 执行 <code>write</code>。</li></ul></li><li><strong>第二步（<code>exit</code>）</strong>：<ul><li>将 <code>rdi</code> 设置为 <code>42</code>，表示退出码为 42。</li><li>将 <code>rax</code> 设置为 <code>60</code>，表示调用<code>exit</code> 系统调用。</li><li>使用 <code>syscall</code> 执行 <code>exit</code>。</li></ul></li></ol><p>==为什么要有 <code>exit</code>？==</p><p>如果程序没有显式调用<code>exit</code>，程序运行结束后可能会因为未定义的行为导致崩溃。调用<code>exit</code>是为了让内核知道程序已经正常终止，同时提供一个退出码供外部程序使用。</p><p><strong><code>write</code> 系统调用</strong>：</p><ul><li><strong>编号：1</strong></li><li>该系统调用用于将数据写入到文件描述符指定的文件中，通常用于输出到屏幕（标准输出）。</li></ul><p><strong><code>write</code> 的参数</strong>：</p><ol type="1"><li><strong><code>rdi</code></strong>：目标文件描述符（filedescriptor）。<code>1</code> 表示标准输出（stdout）。</li><li><strong><code>rsi</code></strong>：要写入的内存地址。即你要输出的数据所在的位置。</li><li><strong><code>rdx</code></strong>：要写入的字节数，表示你希望写入多少数据。</li></ol><p><strong><code>write</code> 系统调用流程</strong>：</p><ol type="1"><li>设置 <strong><code>rax</code></strong> 为系统调用编号<code>1</code>（表示调用 <code>write</code>）。</li><li>设置 <strong><code>rdi</code></strong> 为文件描述符<code>1</code>（标准输出）。</li><li>设置 <strong><code>rsi</code></strong>为包含要输出数据的内存地址。</li><li>设置 <strong><code>rdx</code></strong>为数据的字节数，通常是你希望输出的字符数。</li><li>执行 <code>syscall</code> 指令发起系统调用。</li></ol><p><code>寄存器顺序</code>：</p><p>在 Linux x86_64架构中，系统调用的参数需要按照一定的顺序存放在寄存器中，这些寄存器会被传递到内核：</p><ol type="1"><li><strong><code>rdi</code></strong>：第一个参数</li><li><strong><code>rsi</code></strong>：第二个参数</li><li><strong><code>rdx</code></strong>：第三个参数</li><li><strong><code>r10</code></strong>：第四个参数</li><li><strong><code>r8</code></strong>：第五个参数</li><li><strong><code>r9</code></strong>：第六个参数</li></ol>]]></content:encoded>
      
      
      
      <category domain="http://midnightr3d.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</category>
      
      <category domain="http://midnightr3d.top/tags/%E7%BD%91%E5%AE%89/">网安</category>
      
      
      <comments>http://midnightr3d.top/2024/11/11/Compute%20101%20record/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>递归小谈</title>
      <link>http://midnightr3d.top/2024/09/28/%E9%80%92%E5%BD%92%E5%B0%8F%E8%B0%88/</link>
      <guid>http://midnightr3d.top/2024/09/28/%E9%80%92%E5%BD%92%E5%B0%8F%E8%B0%88/</guid>
      <pubDate>Sat, 28 Sep 2024 13:46:02 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;递归小谈&quot;&gt;递归小谈&lt;/h1&gt;
&lt;p&gt;考虑以下的递归公式：&lt;/p&gt;
&lt;p&gt;​ &lt;span class=&quot;math display&quot;&gt;&#92;[ n! =  &#92;begin{cases} 1 &amp;amp; &#92;text{if }
n = 0 &#92;&#92; n &#92;times (n - 1)! &amp;amp; &#92;text{otherwise} &#92;end{cases}
&#92;]&lt;/span&gt;&lt;/p&gt;
&lt;p&gt;用C语言表示如下：</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="递归小谈">递归小谈</h1><p>考虑以下的递归公式：</p><p>​ <span class="math display">\[ n! =  \begin{cases} 1 &amp; \text{if }n = 0 \\ n \times (n - 1)! &amp; \text{otherwise} \end{cases}\]</span></p><p>用C语言表示如下：<span id="more"></span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">factorial</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line"> <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span> </span><br><span class="line"> &#123;</span><br><span class="line"> <span class="keyword">return</span> n * <span class="built_in">factorial</span>(n - <span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="递归思维">递归思维</h2><p>用递归解决问题需要两个步骤： 首先，确定如何解决简单情况的问题。</p><p>● 这称为基本情况（base case）。其次，确定如何将较大情况分解为较小的实例。</p><p>● 这称为递归步骤（recursive step）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (问题非常简单) &#123;</span><br><span class="line">    <span class="comment"># 直接解决问题</span></span><br><span class="line">    <span class="keyword">return</span> 解决方案;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment"># 将问题分解为一个或多个与原问题结构相同的子问题</span></span><br><span class="line">    <span class="comment"># 解决每个子问题</span></span><br><span class="line">    <span class="comment"># 将结果合并以得到整体解决方案</span></span><br><span class="line">    <span class="keyword">return</span> 整体解决方案;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在试试把以下代码改写成递归的形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sumOfDigitsOf</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">result += (n % <span class="number">10</span>);</span><br><span class="line">n /= <span class="number">10</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">sumOfDigitsOf</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基本情况：如果 n 为 0，返回 0</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归步骤：取出最低位 (n % 10) + 剩余部分的递归结果 (n / 10)</span></span><br><span class="line">    <span class="keyword">return</span> (n % <span class="number">10</span>) + <span class="built_in">sumOfDigitsOf</span>(n / <span class="number">10</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="数根问题">数根问题</h2><p>数根是指通过反复将数字的各位数相加，直到得到一个个位数为止。</p><p>5 的数根是什么？ 5 已经是一个个位数，所以答案是 5。</p><p>27 的数根是什么？ 2 + 7 = 9。 答案是 9。</p><p>137 的数根是什么？用代码来解决。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">digitalRoot</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基本情况：如果 n 是个位数，直接返回 n</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">10</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 递归步骤：将各个位数相加，继续递归调用</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">digitalRoot</span>(n % <span class="number">10</span> + <span class="built_in">digitalRoot</span>(n / <span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>现在尝试利用递归来逆转字符串：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归函数，用于逆转字符串</span></span><br><span class="line"><span class="function">string <span class="title">reverseString</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 基本情况：如果字符串为空或者只有一个字符，则直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">empty</span>() || s.<span class="built_in">length</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 递归步骤：将第一个字符放在最后，其余部分递归处理</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">reverseString</span>(s.<span class="built_in">substr</span>(<span class="number">1</span>)) + s[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取输入字符串</span></span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出原始字符串的长度</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">length</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出原始字符串，每个字符用空格分隔</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> fw : s) &#123;</span><br><span class="line">        cout &lt;&lt; fw &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用递归函数，输出逆转后的字符串</span></span><br><span class="line">    cout &lt;&lt; <span class="built_in">reverseString</span>(s) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>用标准库的做法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span> <span class="comment">// 包含 reverse 函数</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取输入字符串</span></span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出字符串长度</span></span><br><span class="line">    cout &lt;&lt; s.<span class="built_in">length</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历并输出原始字符串的每个字符，字符之间用空格分隔</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> fw : s) &#123;</span><br><span class="line">        cout &lt;&lt; fw &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 逆转字符串</span></span><br><span class="line">    <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出逆转后的字符串</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> fw : s) &#123;</span><br><span class="line">        cout &lt;&lt; fw;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="http://midnightr3d.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</category>
      
      <category domain="http://midnightr3d.top/tags/C/">C++</category>
      
      
      <comments>http://midnightr3d.top/2024/09/28/%E9%80%92%E5%BD%92%E5%B0%8F%E8%B0%88/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>初识数据库</title>
      <link>http://midnightr3d.top/2024/09/16/1.%20%E6%95%B0%E6%8D%AE%E5%BA%93/</link>
      <guid>http://midnightr3d.top/2024/09/16/1.%20%E6%95%B0%E6%8D%AE%E5%BA%93/</guid>
      <pubDate>Mon, 16 Sep 2024 06:45:29 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;数据库&quot;&gt;数据库&lt;/h2&gt;
&lt;p&gt;数据库是一个有组织的、相互关联的数据集合，用来模拟现实世界中的某些方面（例如，模拟班级中的学生或数字音乐商店）。人们常常将“数据库”和“数据库管理系统”（例如
MySQL、Oracle、MongoDB）混为一谈。数据库管理系统（DBMS）是用于管理数据库的软件。&lt;/p&gt;
&lt;p&gt;考虑一个模拟数字音乐商店（例如
Spotify）的数据库。假设这个数据库存储了关于艺术家及其发行的专辑的信息。</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="数据库">数据库</h2><p>数据库是一个有组织的、相互关联的数据集合，用来模拟现实世界中的某些方面（例如，模拟班级中的学生或数字音乐商店）。人们常常将“数据库”和“数据库管理系统”（例如MySQL、Oracle、MongoDB）混为一谈。数据库管理系统（DBMS）是用于管理数据库的软件。</p><p>考虑一个模拟数字音乐商店（例如Spotify）的数据库。假设这个数据库存储了关于艺术家及其发行的专辑的信息。<span id="more"></span></p><h2 id="平面文件模型">平面文件模型</h2><p>数据库可以存储为逗号分隔值（CSV）文件，并由数据库管理系统管理。每个实体会存储在独立的文件中。当应用程序需要读取或更新记录时，必须每次都解析这些文件。每个实体有自己的一组属性，因此在每个文件中，不同的记录通过换行符分隔，而每个记录的属性则通过逗号分隔。</p><p>继续以数字音乐商店为例，可能有两个文件：一个存储艺术家信息，另一个存储专辑信息。艺术家可能有姓名、出生年份和国家等属性，而专辑则有名称、艺术家和年份等属性。</p><p><strong>平面文件的问题</strong></p><ul><li><strong>数据完整性</strong>：<ul><li>如何确保每张专辑的艺术家信息一致？</li><li>如果有人将专辑年份覆盖为无效的字符串怎么办？</li><li>如何存储一张专辑中有多个艺术家的情况？</li></ul></li><li><strong>实现问题</strong>：<ul><li>如何找到特定的记录？</li><li>如果我们现在想要创建一个新的应用程序使用同一个数据库怎么办？</li><li>如果两个线程同时试图写入同一个文件怎么办？</li></ul></li><li><strong>持久性问题</strong>：<ul><li>如果程序在更新记录时机器崩溃怎么办？</li><li>如果我们希望在多台机器上复制数据库以提高可用性怎么办？</li></ul></li></ul><h2 id="数据库管理系统">数据库管理系统</h2><p>数据库管理系统（DBMS）是一种软件，允许应用程序在数据库中存储和分析信息。</p><p>通用数据库管理系统的设计目的是允许定义、创建、查询、更新和管理数据库。</p><p><strong>早期的数据库管理系统</strong>早期的数据库应用程序很难构建和维护，因为逻辑层和物理层之间紧密耦合。逻辑层定义了数据库中的实体和属性，而物理层则定义了这些实体和属性的存储方式。早期的物理层是在应用程序代码中定义的，因此如果我们想要改变应用程序使用的物理层，就必须修改所有代码以适应新的物理层。</p><h2 id="关系模型">关系模型</h2><p>Ted Codd观察到每次更改物理层时，都会重写数据库管理系统。为了解决这一问题，他在1970年提出了关系模型。关系模型有三个关键点：</p><ol type="1"><li>使用简单的数据结构（关系）存储数据库。</li><li>通过高级语言访问数据。</li><li>物理存储由实现决定。</li></ol><p><strong>数据模型</strong>数据模型是用于描述数据库中数据的概念集合。关系模型就是一种数据模型。</p><p><strong>模式（Schema）</strong>模式是使用给定数据模型对特定数据集合的描述。</p><p><strong>关系数据模型的三大概念</strong>：</p><ul><li><strong>结构</strong>：定义关系及其内容。这包括关系的属性及其属性可以包含的值。</li><li><strong>完整性</strong>：确保数据库的内容满足一定的约束。例如，年份属性的值必须是数字。</li><li><strong>操作</strong>：如何访问和修改数据库内容。</li></ul><p><strong>关系（Relation）</strong>关系是一个无序集合，包含表示实体的属性关系。由于关系是无序的，数据库管理系统可以以任何它想要的方式存储它们，从而允许进行优化。</p><p><strong>元组（Tuple）</strong>元组是关系中属性值的集合（也称为域）。最初，值必须是原子（atomic）或标量（scalar），但现在值可以是列表或嵌套的数据结构。每个属性可以有一个特殊值<code>NULL</code>，表示对于给定元组，属性是未定义的。</p><p>一个有 n 个属性的关系被称为 n 元关系（n-ary relation）。</p><p><strong>键（Keys）</strong> 关系的主键（PrimaryKey）唯一标识一个元组。如果你不定义主键，一些数据库管理系统会自动创建一个内部主键。许多数据库管理系统支持自动生成键，因此应用程序不必手动增加键。</p><p>外键（ForeignKey）指定一个关系中的属性必须映射到另一个关系中的元组。</p><h2 id="数据操作语言dmls">数据操作语言（DMLs）</h2><p>数据操作语言用于存储和检索数据库中的信息。DMLs 分为两类：</p><ul><li><strong>过程式（Procedural）</strong>：查询指定数据库管理系统应该如何找到所需的结果（高层策略）。</li><li><strong>非过程式（Non-Procedural）</strong>：查询只指定所需的数据，而不指定如何查找它。</li></ul><h2 id="关系代数relational-algebra">关系代数（Relational Algebra）</h2><p>关系代数是一组用于检索和操作关系中元组的基本操作。每个操作符接受一个或多个关系作为输入，并输出一个新的关系。我们可以将这些操作符“链接”起来，创建更复杂的操作。</p><ul><li><p><strong>选择（Selection）</strong>选择操作符从关系中输出满足条件的元组子集。谓词（Predicate）充当过滤器，我们可以使用逻辑运算符（如与、或）结合多个谓词。</p><p>语法：<code>σ_&#123;谓词&#125;(R)</code></p></li><li><p><strong>投影（Projection）</strong>投影操作符从关系中输出只包含指定属性的元组。你可以重新排列输入关系中属性的顺序，并且可以操作这些值。</p><p>语法：<code>π_&#123;A1,A2,...,An&#125;(R)</code></p></li><li><p><strong>并集（Union）</strong>并集操作符接受两个关系，输出至少出现在一个输入关系中的所有元组。注意：两个输入关系必须具有完全相同的属性。</p><p>语法：<code>(R ∪ S)</code></p></li><li><p><strong>交集（Intersection）</strong>交集操作符接受两个关系，输出同时出现在两个输入关系中的所有元组。注意：两个输入关系必须具有完全相同的属性。</p><p>语法：<code>(R ∩ S)</code></p></li><li><p><strong>差集（Difference）</strong>差集操作符接受两个关系，输出出现在第一个关系中但不在第二个关系中的元组。注意：两个输入关系必须具有完全相同的属性。</p><p>语法：<code>(R - S)</code></p></li><li><p><strong>乘积（Product）</strong>乘积操作符接受两个关系，输出输入关系中元组的所有可能组合。</p><p>语法：<code>(R × S)</code></p></li><li><p><strong>连接（Join）</strong>连接操作符接受两个关系，输出元组组合。对于每个共享的属性，元组中的值必须相同。</p><p>语法：<code>(R ⨝ S)</code></p></li></ul><h2 id="关系代数操作示例">关系代数操作示例</h2><h4 id="数据库示例">数据库示例：</h4><p>假设我们有以下两个关系：</p><ol type="1"><li><p><strong>学生表 (Students)</strong>：</p><ul><li><code>ID</code>：学生的唯一标识符</li><li><code>Name</code>：学生的名字</li><li><code>Age</code>：学生的年龄</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Students</span><br><span class="line"><span class="addition">+----+--------+-----+</span></span><br><span class="line">| ID | Name   | Age |</span><br><span class="line"><span class="addition">+----+--------+-----+</span></span><br><span class="line">| 1  | Alice  | 20  |</span><br><span class="line">| 2  | Bob    | 22  |</span><br><span class="line">| 3  | Charlie| 23  |</span><br><span class="line"><span class="addition">+----+--------+-----+</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>课程表 (Courses)</strong>：</p><ul><li><code>CourseID</code>：课程的唯一标识符</li><li><code>CourseName</code>：课程名称</li><li><code>StudentID</code>：学生的ID（外键，指向学生表的<code>ID</code>）</li></ul><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Courses</span><br><span class="line"><span class="addition">+---------+------------+-----------+</span></span><br><span class="line">| CourseID| CourseName | StudentID |</span><br><span class="line"><span class="addition">+---------+------------+-----------+</span></span><br><span class="line">| 101     | Math       | 1         |</span><br><span class="line">| 102     | English    | 2         |</span><br><span class="line">| 103     | History    | 3         |</span><br><span class="line">| 104     | Math       | 2         |</span><br><span class="line"><span class="addition">+---------+------------+-----------+</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p><strong>选择 (Selection)</strong></p></li></ol><p>选择操作从关系中挑选满足特定条件的元组（记录）。例如，我们希望选择所有年龄大于21 岁的学生。</p><p><strong>操作</strong>：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">σ<span class="built_in">_</span>&#123;Age &gt; 21&#125; (Students)</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">plaintext复制代码+----+--------+-----+</span><br><span class="line">| ID | Name   | Age |</span><br><span class="line"><span class="addition">+----+--------+-----+</span></span><br><span class="line">| 2  | Bob    | 22  |</span><br><span class="line">| 3  | Charlie| 23  |</span><br><span class="line"><span class="addition">+----+--------+-----+</span></span><br></pre></td></tr></table></figure><ol start="2" type="1"><li><strong>投影 (Projection)</strong></li></ol><p>投影操作用于选择特定的列。例如，我们只想查看学生的名字和年龄。</p><p><strong>操作</strong>：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">π<span class="built_in">_</span>&#123;Name, Age&#125; (Students)</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+--------+-----+</span></span><br><span class="line">| Name   | Age |</span><br><span class="line"><span class="addition">+--------+-----+</span></span><br><span class="line">| Alice  | 20  |</span><br><span class="line">| Bob    | 22  |</span><br><span class="line">| Charlie| 23  |</span><br><span class="line"><span class="addition">+--------+-----+</span></span><br></pre></td></tr></table></figure><ol start="3" type="1"><li><strong>并集 (Union)</strong></li></ol><p>并集操作用于合并两个关系，输出所有元组。假设我们有两个不同的学生表，分别表示参加数学和英语课程的学生，我们希望找到参加任一课程的学生。</p><p><strong>操作</strong>：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MathStudents ∪ EnglishStudents</span><br></pre></td></tr></table></figure><p>假设两个关系如下：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">MathStudents</span><br><span class="line"><span class="addition">+----+--------+</span></span><br><span class="line">| ID | Name   |</span><br><span class="line"><span class="addition">+----+--------+</span></span><br><span class="line">| 1  | Alice  |</span><br><span class="line">| 2  | Bob    |</span><br><span class="line"><span class="addition">+----+--------+</span></span><br><span class="line"></span><br><span class="line">EnglishStudents</span><br><span class="line"><span class="addition">+----+--------+</span></span><br><span class="line">| ID | Name   |</span><br><span class="line"><span class="addition">+----+--------+</span></span><br><span class="line">| 2  | Bob    |</span><br><span class="line">| 3  | Charlie|</span><br><span class="line"><span class="addition">+----+--------+</span></span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+----+--------+</span></span><br><span class="line">| ID | Name   |</span><br><span class="line"><span class="addition">+----+--------+</span></span><br><span class="line">| 1  | Alice  |</span><br><span class="line">| 2  | Bob    |</span><br><span class="line">| 3  | Charlie|</span><br><span class="line"><span class="addition">+----+--------+</span></span><br></pre></td></tr></table></figure><ol start="4" type="1"><li><strong>交集 (Intersection)</strong></li></ol><p>交集操作用于查找同时出现在两个关系中的元组。例如，我们希望找到既修数学又修英语课程的学生。</p><p><strong>操作</strong>：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MathStudents ∩ EnglishStudents</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+----+--------+</span></span><br><span class="line">| ID | Name   |</span><br><span class="line"><span class="addition">+----+--------+</span></span><br><span class="line">| 2  | Bob    |</span><br><span class="line"><span class="addition">+----+--------+</span></span><br></pre></td></tr></table></figure><ol start="5" type="1"><li><strong>差集 (Difference)</strong></li></ol><p>差集操作返回出现在第一个关系中，但不在第二个关系中的元组。例如，我们希望找到只修数学课程但不修英语课程的学生。</p><p><strong>操作</strong>：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">MathStudents - EnglishStudents</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+----+--------+</span></span><br><span class="line">| ID | Name   |</span><br><span class="line"><span class="addition">+----+--------+</span></span><br><span class="line">| 1  | Alice  |</span><br><span class="line"><span class="addition">+----+--------+</span></span><br></pre></td></tr></table></figure><ol start="6" type="1"><li><strong>笛卡尔积 (Product)</strong></li></ol><p>笛卡尔积用于生成两个关系的所有可能组合。例如，我们希望将每个学生和每门课程进行组合。</p><p><strong>操作</strong>：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Students × Courses</span><br></pre></td></tr></table></figure><p><strong>结果</strong>： （仅显示部分结果）</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+----+--------+-----+---------+------------+-----------+</span></span><br><span class="line">| ID | Name   | Age | CourseID| CourseName | StudentID |</span><br><span class="line"><span class="addition">+----+--------+-----+---------+------------+-----------+</span></span><br><span class="line">| 1  | Alice  | 20  | 101     | Math       | 1         |</span><br><span class="line">| 1  | Alice  | 20  | 102     | English    | 2         |</span><br><span class="line">| 1  | Alice  | 20  | 103     | History    | 3         |</span><br><span class="line">| 1  | Alice  | 20  | 104     | Math       | 2         |</span><br><span class="line">| 2  | Bob    | 22  | 101     | Math       | 1         |</span><br><span class="line">| ...（省略其余组合）</span><br><span class="line"><span class="addition">+----+--------+-----+---------+------------+-----------+</span></span><br></pre></td></tr></table></figure><ol start="7" type="1"><li><strong>连接 (Join)</strong></li></ol><p>连接操作用于将两个关系组合在一起，其中共享属性的值必须相同。例如，我们希望找到每个学生修的课程信息。</p><p><strong>操作</strong>：</p><figure class="highlight latex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Students ⨝ Courses</span><br></pre></td></tr></table></figure><p><strong>结果</strong>：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+----+--------+-----+---------+------------+</span></span><br><span class="line">| ID | Name   | Age | CourseID| CourseName |</span><br><span class="line"><span class="addition">+----+--------+-----+---------+------------+</span></span><br><span class="line">| 1  | Alice  | 20  | 101     | Math       |</span><br><span class="line">| 2  | Bob    | 22  | 102     | English    |</span><br><span class="line">| 2  | Bob    | 22  | 104     | Math       |</span><br><span class="line">| 3  | Charlie| 23  | 103     | History    |</span><br><span class="line"><span class="addition">+----+--------+-----+---------+------------+</span></span><br></pre></td></tr></table></figure>]]></content:encoded>
      
      
      
      <category domain="http://midnightr3d.top/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/">数据库</category>
      
      <category domain="http://midnightr3d.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</category>
      
      
      <comments>http://midnightr3d.top/2024/09/16/1.%20%E6%95%B0%E6%8D%AE%E5%BA%93/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>与学习相关的技巧</title>
      <link>http://midnightr3d.top/2024/07/24/%E4%B8%8E%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E7%9A%84%E6%8A%80%E5%B7%A7/</link>
      <guid>http://midnightr3d.top/2024/07/24/%E4%B8%8E%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E7%9A%84%E6%8A%80%E5%B7%A7/</guid>
      <pubDate>Tue, 23 Jul 2024 16:00:01 GMT</pubDate>
      
      <description>&lt;p&gt;本节设计神经网络的学习中的一些重要的观点。主题有寻找最优权重参数的优化方法，权重参数的初始值，超参数的设定方法等。为了应对过拟合（神经网络在训练样本中表现过于优越，导致在验证数据集和测试数据集中表现不佳），还会介绍权值衰减，Dropout等正则化方法。</description>
      
      
      
      <content:encoded><![CDATA[<p>本节设计神经网络的学习中的一些重要的观点。主题有寻找最优权重参数的优化方法，权重参数的初始值，超参数的设定方法等。为了应对过拟合（神经网络在训练样本中表现过于优越，导致在验证数据集和测试数据集中表现不佳），还会介绍权值衰减，Dropout等正则化方法。<span id="more"></span></p><h2 id="参数的更新">参数的更新</h2><p>神经网络的学习的目的是找到使损失函数的值尽可能小的参数，这个过程被称作“最优化”。参数空间非常复杂，且深度神经网络中，参数的数目十分庞大，导致了最优化问题非常复杂。</p><p>我们之前使用了随机梯度下降法（stochastic gradientdescent）来更新参数。SGD虽然是简单的方法，但是比起无目的的在参数空间中乱逛，无疑是有效的。接下来我们复习SGD。</p><p>用数学式可以把SGD写成如下的式子： <span class="math display">\[W  \leftarrow W \leftarrow η \frac{\partial L}{\partial W}\]</span>需要更新的权重为w，η代表学习率，通常会实现设定好为0.1或者0.01等。箭头代表更新左边的值。</p><p>我们将SGD实现为一个名为SGD的类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SGD</span>:</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,lr = <span class="number">0.01</span></span>):</span><br><span class="line">self.lr = lr</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self,params,grads</span>):</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> params.keys():</span><br><span class="line">            params[key] -= self.lr * grads[key]</span><br></pre></td></tr></table></figure><p>虽然SGD简单且容易实现，但在面对非均向（anisotropic），比如延伸状，搜索的路径路径就会十分低效。因此，我们需要比单纯梯度方向前进的SGD更聪明的方法。SGD低效的根本原因是，梯度的方向并没有指向最小值的方向。</p><p>为了改正SGD的缺点，我们将会介绍Momentum，AdaGrad,Adam这三种方法来取代SGD。</p><h2 id="momentum">Momentum</h2><p>用数学式来表示Momentum方法： <span class="math display">\[v \leftarrow α \,- η \frac{\partial L}{\partial W} \\W \leftarrow W + v\]</span>W代表要更新的权重参数，η为学习率，分数是表示损失函数关于W的梯度。这里的新变量v对应物理上的速度。这两个式子表示了物体在梯度方向上受力，在这个力作用下，物体的速度增加这一个物理法则。下面是Momentum的代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Momentum</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,lr = <span class="number">0.01</span> , momentum = <span class="number">0</span></span>):</span><br><span class="line">        self.lr = lr</span><br><span class="line">        self.momentum = momentum</span><br><span class="line">        self.v = none</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self,params,grads</span>):</span><br><span class="line">        <span class="keyword">if</span> self.v <span class="keyword">is</span> none:</span><br><span class="line">            self.v = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> key, val <span class="keyword">in</span> params.items():</span><br><span class="line">                self.v[key] = np.zeros_like(val)</span><br><span class="line">                </span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> params.keys():</span><br><span class="line">        self.v[key] = self.momentum * self.v[key] - self.lr * grads[key]</span><br><span class="line">        params[key] += self.v[key]</span><br></pre></td></tr></table></figure><h2 id="adagrad">Adagrad</h2><p>在神经网络的学习中，学习率（数学式中的η）的值很重要，学习率过小，会导致学习花费太多时间；学习率过大，会导致学习发散而不能正确进行。在有关学习率的有效技巧中，有一种被称为<strong>学习率衰减（learningratedecay）</strong>的方法。即随着学习的进行，使学习率逐渐减小。实际上，一开始“多”学，然后逐渐“少”学的方法在神经网络的学习中经常被使用。</p><p>逐渐减少学习率的想法，相当于将“全体”参数的学习率值一起降低，而AdaGrad进一步发展了这个想法，针对“一个一个”的参数，赋予其“定制”的值。Adagrad会为每个元素适当的调整学习率，与此同时进行学习。下面是用数学式表示的AdaGrad的更新方法：<span class="math display">\[h \leftarrow h \,+\frac{\partial L}{\partial W}\,\odot\frac{\partialL}{\partial W}\\W \leftarrow W -\, η\frac{1}{\sqrt{h}}\frac{\partial L}{\partial W}\]</span> 实现方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AdaGrad</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, lr=<span class="number">0.01</span></span>):</span><br><span class="line">        self.lr = lr</span><br><span class="line">        self.h = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, params, grads</span>):</span><br><span class="line">        <span class="keyword">if</span> self.h <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.h = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> key, val <span class="keyword">in</span> params.items():</span><br><span class="line">                self.h[key] = np.zeros_like(val)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> params.keys():</span><br><span class="line">            self.h[key] += grads[key] * grads[key]</span><br><span class="line">            params[key] -= self.lr * grads[key] / (np.sqrt(self.h[key]) + <span class="number">1e-7</span>)</span><br><span class="line">            </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RMSprop</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, lr=<span class="number">0.01</span>, decay_rate = <span class="number">0.99</span></span>):</span><br><span class="line">        self.lr = lr</span><br><span class="line">        self.decay_rate = decay_rate</span><br><span class="line">        self.h = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, params, grads</span>):</span><br><span class="line">        <span class="keyword">if</span> self.h <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.h = &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> key, val <span class="keyword">in</span> params.items():</span><br><span class="line">                self.h[key] = np.zeros_like(val)</span><br><span class="line">            </span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> params.keys():</span><br><span class="line">            self.h[key] *= self.decay_rate</span><br><span class="line">            self.h[key] += (<span class="number">1</span> - self.decay_rate) * grads[key] * grads[key]</span><br><span class="line">            params[key] -= self.lr * grads[key] / (np.sqrt(self.h[key]) + <span class="number">1e-7</span>)</span><br></pre></td></tr></table></figure><p>同时，AdaGrad会记录过去所有梯度的平方和。因此，学习越深入，更新的幅度就越小。实际上，如果无止境地学习，更新量就会变为0，完全不再更新。为了改善这个问题，可以使用RMSProp方法。RMSProp方法并不是将过去所有的梯度一视同仁地相加，而是逐渐地遗忘过去的梯度，在做加法运算时将新梯度的信息更多地反映出来。这种操作从专业上讲，称为“指数移动平均”，呈指数函数式地减小过去的梯度的尺度。</p><p>最后一行的1e-7是为了防止当self.h[key]中有0时将0用作除数的情况。</p><h2 id="adam">Adam</h2><p>Momentum参照小球在碗中滚动的物理规则进行移动，AdaGrad为参数的每个元素适当地调整更新步伐。将这两个思路融合在一起就是Adam方法的基本思路。</p><p>adam会设置三个参数，一个是学习率，另外两个分别是一次momentum参数<spanclass="math inline">\(β_1\)</span>和二次Monmouth参数<spanclass="math inline">\(β_2\)</span></p><p>作为2015年提出的方法，他的理论有些复杂。这里不给出数学式，只给出python的实现方式,详细内容参考链接中的论文：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Adam</span>:</span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;&quot;&quot;Adam (http://arxiv.org/abs/1412.6980v8)&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, lr=<span class="number">0.001</span>, beta1=<span class="number">0.9</span>, beta2=<span class="number">0.999</span></span>):</span><br><span class="line">        self.lr = lr</span><br><span class="line">        self.beta1 = beta1</span><br><span class="line">        self.beta2 = beta2</span><br><span class="line">        self.<span class="built_in">iter</span> = <span class="number">0</span></span><br><span class="line">        self.m = <span class="literal">None</span></span><br><span class="line">        self.v = <span class="literal">None</span></span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, params, grads</span>):</span><br><span class="line">        <span class="keyword">if</span> self.m <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            self.m, self.v = &#123;&#125;, &#123;&#125;</span><br><span class="line">            <span class="keyword">for</span> key, val <span class="keyword">in</span> params.items():</span><br><span class="line">                self.m[key] = np.zeros_like(val)</span><br><span class="line">                self.v[key] = np.zeros_like(val)</span><br><span class="line">        </span><br><span class="line">        self.<span class="built_in">iter</span> += <span class="number">1</span></span><br><span class="line">        lr_t  = self.lr * np.sqrt(<span class="number">1.0</span> - self.beta2**self.<span class="built_in">iter</span>) / (<span class="number">1.0</span> - self.beta1**self.<span class="built_in">iter</span>)         </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> params.keys():</span><br><span class="line">            <span class="comment">#self.m[key] = self.beta1*self.m[key] + (1-self.beta1)*grads[key]</span></span><br><span class="line">            <span class="comment">#self.v[key] = self.beta2*self.v[key] + (1-self.beta2)*(grads[key]**2)</span></span><br><span class="line">            self.m[key] += (<span class="number">1</span> - self.beta1) * (grads[key] - self.m[key])</span><br><span class="line">            self.v[key] += (<span class="number">1</span> - self.beta2) * (grads[key]**<span class="number">2</span> - self.v[key])</span><br><span class="line">            </span><br><span class="line">            params[key] -= lr_t * self.m[key] / (np.sqrt(self.v[key]) + <span class="number">1e-7</span>)</span><br><span class="line">            </span><br><span class="line">            <span class="comment">#unbias_m += (1 - self.beta1) * (grads[key] - self.m[key]) # correct bias</span></span><br><span class="line">            <span class="comment">#unbisa_b += (1 - self.beta2) * (grads[key]*grads[key] - self.v[key]) # correct bias</span></span><br><span class="line">            <span class="comment">#params[key] += self.lr * unbias_m / (np.sqrt(unbisa_b) + 1e-7)</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="batch-normalization">Batch Normalization</h2><p>batch normalization,简称batchnorm是2015年提出的方法，它有以下优点：</p><ul><li>可以使机器学习快速进行（可以增大学习率）</li><li>不那么依赖初始值（对于初始值不那么神经质）</li><li>抑制过拟合（降低Dropout等的必要性）</li></ul><p>Batch的思路是调整各层的激活值分布使其拥有适当的广度，为此要向神经网络中插入对数据分布进行正规化的层，也即BatchNormalization层。</p><p>batchnorm，顾名思义，以进行学习时的mini-batch为单位，按mini-batch进行正规化，具体而言，就是使数据分布的均值为0，方差为1的正规化。用数学式表达如下：<span class="math display">\[\mu_B \leftarrow \, \frac{1}{m}\sum_{i=1}^{m}x_i \\\sigma_B ^2 \leftarrow \, \frac{1}{m}\sum_{i=1}^{m}(x_i - \mu_B)^2\\\hat{x_i}\leftarrow \, \frac{x_i-\mu_B}{\sqrt{\sigma_B^2\,+\,\epsilon}}\]</span> 这里对mini-batch的m个输入数据的集合<strong>B={<spanclass="math inline">\(x_1\)</span>,<spanclass="math inline">\(x_2\)</span>,……,<spanclass="math inline">\(x_m\)</span>}</strong>求均值<spanclass="math inline">\(\mu_B\)</span>和方差<spanclass="math inline">\(\sigma_B^2\)</span>,然后，对输入数据进行均值为0，方差为1（任意合适的分布）的正规化。第三个式子中的<spanclass="math inline">\(\epsilon\)</span>是一个极小值，防止出现除以0的情况。这三个式子所做的是将mini-batch中的输入数据变化为均值为0，方差为1的数据（正规化）。通过将这个处理插入到激活函数的前面或者后面，可以减小数据分布的偏向。之后，BatchNorm层会对正规化后的数据进行缩放和平移的变换，用数学式表达如下： <spanclass="math display">\[y_i\,\leftarrow\,\gamma \hat{x_i}\,+\,\beta\]</span> 一开始，γ为1，β为0，之后再通过学习调整到合适的值。</p><h2 id="正则化">正则化</h2><h3 id="过拟合">过拟合</h3><p>机器学习的问题中，过拟合是一个很常见的问题。过拟合指的是只能拟合训练数据，但不能很好地拟合不包含在训练数据中的其他数据的状态。机器学习的目标是提高泛化能力，即便是没有包含在训练数据里的未观测数据，也希望模型可以进行正确的识别。我们可以制作复杂的、表现力强的模型，</p><p>发生过拟合的原因有两个：</p><ul><li>模型拥有大量参数，表现力强</li><li>训练数据少</li></ul><p>“表现力强”是指模型的复杂程度以及其在数据拟合方面的能力。表现力强的模型能够捕捉并表示复杂的模式和细节。具体来说：</p><p>表现力强的含义：</p><ol type="1"><li><strong>大量参数</strong>：<ul><li>表现力强的模型通常拥有大量参数（例如深度神经网络中的权重和偏置）。这些参数赋予模型更大的灵活性，使其能够学习和拟合数据中的复杂关系和细节。</li><li>例如，简单的线性回归模型只有少量参数，只能拟合直线，而深度神经网络具有大量参数，可以拟合高度非线性的关系。</li></ul></li><li><strong>复杂结构</strong>：<ul><li>复杂的模型结构（例如多层神经网络、决策树的深层树结构）使模型能够处理多维特征并捕捉复杂的模式。</li><li>例如，卷积神经网络（CNN）中的卷积层和池化层能够捕捉图像数据中的空间特征和模式。</li></ul></li><li><strong>高阶特征</strong>：<ul><li>表现力强的模型能够自动生成高阶特征或复杂特征组合，这些特征能够更好地描述数据中的模式和关系。</li><li>例如，在自然语言处理任务中，基于注意力机制的Transformer模型能够捕捉句子中不同单词之间的复杂关系。</li></ul></li></ol><p>当模型具有很强的表现力时，它能够很好地拟合训练数据中的细节，包括噪声和异常值。然而，这种过度拟合训练数据的行为会导致模型在未见过的数据上表现不佳，因为模型没有学会数据的真正模式，而是记住了训练数据的细节。</p><h3 id="权值衰减">权值衰减</h3><p>权值衰减是一直以来经常被用作的一种抑制过拟合的方法。该方法通过在学习的过程中对大的权重进行乘法来抑制过拟合。很多过拟合正是由于权重参数取值过大才发生的。</p><p>对于所有权重，权值衰减方法都会为损失函数加上<spanclass="math inline">\(\frac{1}{2}\lambdaW^2\)</span>。因此，在求权重梯度的计算中，要为之前的误差反向传播法的结果加上正则化的导数λW。</p><h3 id="dropout">Dropout</h3><p>作为抑制过拟合的方法，前面我们介绍了为损失函数加上权重的L2范数的权值衰减方法。该方法可以简单地实现，在某种程度上能够抑制过拟合。但是，如果网络的模型变得很复杂，只用权值衰减就难以应对了。在这种情况下，我们经常会使用Dropout方法。Dropout是一种在学习的过程中随机删除神经元的方法。训练时，随机选出隐藏层的神经元，然后将其删除。被删除的神经元不再进行信号的传递.训练时，每传递一次数据，就会随机选择要删除的神经元。热后，测试时，虽然会传递所有的神经元信号，但是对于各个神经元的输出，要乘上训练时的删除比例后再输出。</p>]]></content:encoded>
      
      
      
      <category domain="http://midnightr3d.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</category>
      
      <category domain="http://midnightr3d.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</category>
      
      
      <comments>http://midnightr3d.top/2024/07/24/%E4%B8%8E%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3%E7%9A%84%E6%8A%80%E5%B7%A7/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>误差反向传播法</title>
      <link>http://midnightr3d.top/2024/07/18/%E8%AF%AF%E5%B7%AE%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E6%B3%95/</link>
      <guid>http://midnightr3d.top/2024/07/18/%E8%AF%AF%E5%B7%AE%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E6%B3%95/</guid>
      <pubDate>Wed, 17 Jul 2024 16:02:48 GMT</pubDate>
      
      <description>&lt;p&gt;误差反向传播法是一种能高效计算权重参数梯度的方法。要理解它一般有两种方法，一种是基于数学式，另一种是基于&lt;strong&gt;计算图&lt;/strong&gt;（computational
graph）。接下来会补充讲解计算图的理解方法。&lt;/p&gt;
&lt;h2 id=&quot;计算图&quot;&gt;计算图&lt;/h2&gt;
&lt;p&gt;计算图会将计算过程用图表现出来。这里的图形是数据结构图，通过多个节点和边来表示。</description>
      
      
      
      <content:encoded><![CDATA[<p>误差反向传播法是一种能高效计算权重参数梯度的方法。要理解它一般有两种方法，一种是基于数学式，另一种是基于<strong>计算图</strong>（computationalgraph）。接下来会补充讲解计算图的理解方法。</p><h2 id="计算图">计算图</h2><p>计算图会将计算过程用图表现出来。这里的图形是数据结构图，通过多个节点和边来表示。<span id="more"></span></p><p>计算图通过节点和箭头表示计算过程，节点用 ⚪ 表示，⚪中是计算的内容。将计算的结果写在箭头的上方，表示各个节点的计算结果从左到右传递。计算时就像电流从左到右流动，计算结果从左向右传递。到达最右边的计算结果后，计算过程就结束了。</p><p>使用计算图计算的流程一般是</p><ol type="1"><li>构建计算图</li><li>在计算图上从左到右计算</li></ol><p>这里的“从左到右”传播被称为正向传播（forwardpropagation），后面我们还会遇见反向传播（backward propagation）</p><p>计算图的特征之一是通过“局部计算”来获得最终结果，无论全局发生了什么，都只能根据和自己相关的信息来输出结果。在计算图的全局来看，这就像是工厂的流水线，每个工人所承担的都是简化过的工作，将每项工人的成果传递给下一个工人就可完成整个任务。计算图就是通过传递每个局部计算的计算结果得到的全局复杂计算的结果。</p><p>并且，通过反向传播可以高效计算导数。</p><h2 id="链式法则">链式法则</h2><p>反向传播会将局部导数向正方向的反方向（从右到左）传递，传递这个局部导数的原理是基于<strong>链式法则</strong>（chainrule）的。下面是关于链式法则的解释。</p><p>假设存在 y = f(x)的计算，这个计算的反向传播如图所示：</p><figure><img src="/images/IMG_20240717_215331.jpg" alt="IMG_20240717_215331" /><figcaption aria-hidden="true">IMG_20240717_215331</figcaption></figure><p>在反向传播里，加法的是将上游的值赋予下游的值；乘法的则为 <spanclass="math inline">\(\frac{\partial z}{\partial x} \,+ \,y\)</span>或者<span class="math inline">\(\frac{\partial z}{\partial y} \,+\,x\)</span></p><h2 id="简单层的实现">简单层的实现</h2><p>接下来我们将会把实现的计算图的乘法节点称为“乘法层”（Mullayer）,加法节点称作“加法层”（Addlayer）。习惯上，我们会把实现神经网络的“层”实现为一个类，这里的“层”指的是神经网络中功能的单位。如负责sigmoid函数的Sigmoid，负责矩阵乘积的Affine等。</p><p>乘法层会初始化x和y来保存正向传播时的输入。backward()方法会将上游传下来的导数乘正向传播的翻转值，然后传给下游。</p><p>加法层不需要刻意进行初始化。其中的forward（）方法会接受两个参数相加后输出，backward（）方法则会将上游传下的导数原封不动输出。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Mullayer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.x = <span class="literal">None</span></span><br><span class="line">        self.y = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        out = x * y</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self, dout</span>):</span><br><span class="line">        dx = dout * self.y</span><br><span class="line">        dy = dout * self.x</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dx, dy</span><br><span class="line">    </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Addlayer</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x,y</span>):</span><br><span class="line">        out = x + y</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self,x,y,dout</span>):</span><br><span class="line">        dx = dout *<span class="number">1</span></span><br><span class="line">        dy = dout *<span class="number">1</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dx,dy</span><br><span class="line">        </span><br></pre></td></tr></table></figure><h2 id="激活函数层的实现">激活函数层的实现</h2><p>激活函数ReLU(Rectified Linear Unit),如下式： <spanclass="math display">\[\text{ReLU}(x) = \begin{cases}0 &amp; \text{if } x &lt; 0 \\x &amp; \text{if } x \geq 0\end{cases}\]</span> 求出导数为（假如是x）： <span class="math display">\[\frac{\partial f}{\partial x} =\begin{cases}0 &amp; \text{if } x &lt; 0 \\1 &amp; \text{if } x \geq 0\end{cases}\]</span>在神经网络层的实现中，一般假定<code>forward()</code>和<code>backward()</code>的参数是NumPy数组。</p><p>ReLU函数的作用就像电路中的开关，正向传播时，假如有电流通过，那就把开关设为on，否则设为off;当反向传播时，开关为on电流会直接通过，反之为off时就不会有任何电流通过。</p><p>激活函数Sigmoid如下： <span class="math display">\[\sigma(x) = \frac{1}{1 + e^{-x}}\]</span>正向传播时输出保存在了实例变量out中，反向传播时使用该变量out进行计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ReLu</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">        self.mask = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self,x</span>):</span><br><span class="line">        self.mask = (x &lt;=<span class="number">0</span> )</span><br><span class="line">        out = x.copy()</span><br><span class="line">        out[self.mask] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self,dout</span>):</span><br><span class="line">        dout[self.mask] = <span class="number">0</span></span><br><span class="line">        dx = dout</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dx</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Sigmoid</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.out = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        out = <span class="number">1</span> / (<span class="number">1</span> + np.exp(-x))</span><br><span class="line">        self.out = out</span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self, dout</span>):</span><br><span class="line">        dx = dout * (<span class="number">1.0</span> - self.out) * self.out</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dx</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>附上ReLu和Sigmoid的计算图</p><figure><img src="/images/IMG_20240717_232529.jpg" alt="IMG_20240717_232529" /><figcaption aria-hidden="true">IMG_20240717_232529</figcaption></figure><figure><img src="assets\IMG_20240717_232516.jpg" alt="IMG_20240717_232516" /><figcaption aria-hidden="true">IMG_20240717_232516</figcaption></figure><h2 id="affinesoftmax层的实现">Affine/Softmax层的实现</h2><p>神经网络的正向传播中，为了计算加权信号的总和，使用了乘积运算。</p><figure><img src="/images/IMG_20240717_233625.jpg" alt="IMG_20240717_233625" /><figcaption aria-hidden="true">IMG_20240717_233625</figcaption></figure><p>当输入X为单个变量的计算图。</p><p>当N个数据一起输入时计算图变为：</p><figure><img src="assets\IMG_20240717_233909.jpg" alt="IMG_20240717_233909" /><figcaption aria-hidden="true">IMG_20240717_233909</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Affine</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, W, b</span>):</span><br><span class="line">       self.w = W</span><br><span class="line">       self.b = b</span><br><span class="line">       self.x = <span class="literal">None</span></span><br><span class="line">       self.dw = <span class="literal">None</span></span><br><span class="line">       self.db = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x</span>):</span><br><span class="line">        self.x = x </span><br><span class="line">        out = np.dot(x, self.w) + self.b</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> out</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self, dout</span>):</span><br><span class="line">        dx = np.dot(dout, self.w.T)</span><br><span class="line">        self.dw = np.dot(self.x.T, dout)</span><br><span class="line">        self.db = np.<span class="built_in">sum</span>(dout, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dx</span><br></pre></td></tr></table></figure><h2 id="softmax-with-loss层">Softmax-with-Loss层</h2><p>softmax函数会将输入全部正规化后输出。由于这里也包含作为损失函数的交叉熵误差（crossentropyerror），所以称为"Softmax-with-Loss"层。softmax层的计算图有些复杂，这里给出一个简化版的：</p><figure><img src="/images/IMG_20240717_234920.jpg" alt="IMG_20240717_234920" /><figcaption aria-hidden="true">IMG_20240717_234920</figcaption></figure><p>图中要注意的是反向传播的结果。Softmax层的反向传播得到了(y_1-t_1,y_2-t_2,y_3-t_3)这样“漂亮”的结果。由于（y_1，y_2，y_3）是Softmax层的出、（t_1，t2,t_3)是监督数据，所以（y_1-t_1，y_2-t_2，y_3-t_3）是Softmax层的输出和监督标签的差分。神经网络的反向传播会把这个差分表示的误差传递给前面的层，这是神经网络学习中的重要性质。神经网络学习的目的就是通过调整权重参数，使神经网络的输出（Softmax的输出）接近监督标签。因此，必须将神经网络的输出与监督标签的误差高效地传递给前面的层。刚刚的(y_1-t_1,y_2-t_2,y_3-t_3)正是Softmax层的输出与监督标签的差，直截了当地表示了当前神经网络的输出与监督标签的误差。这里考虑一个具体的例子，比如思考监督标签是（0,1,0)，Softmax层的输出是（0.3,0.2,0.5)的情形。因为正确解标签处的概率是0.2（20%），这个时候的神经网络未能进行正确的识别。此时，Softmax层的反向传播传递的是（0.3,-0.8,0.5)这样一个大的误差。因为这个大的误差会向前面的层传播，所以Softmax层前面的层会从这个大的误差中学习到“大”的内容。</p><p>以下是层的实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SoftmaxWithLoss</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.loss = <span class="literal">None</span></span><br><span class="line">        self.y = <span class="literal">None</span> <span class="comment"># softmax的输出</span></span><br><span class="line">        self.t = <span class="literal">None</span> <span class="comment"># 监督数据</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, x, t</span>):</span><br><span class="line">        self.t = t</span><br><span class="line">        self.y = softmax(x)</span><br><span class="line">        self.loss = cross_entropy_error(self.y, self.t)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> self.loss</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backward</span>(<span class="params">self, dout=<span class="number">1</span></span>):</span><br><span class="line">        batch_size = self.t.shape[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> self.t.size == self.y.size: <span class="comment"># 监督数据是one-hot-vector的情况</span></span><br><span class="line">            dx = (self.y - self.t) / batch_size</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            dx = self.y.copy()</span><br><span class="line">            dx[np.arange(batch_size), self.t] -= <span class="number">1</span></span><br><span class="line">            dx = dx / batch_size</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dx</span><br></pre></td></tr></table></figure><h2 id="误差反向传播法的实现">误差反向传播法的实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line">sys.path.append(<span class="string">&quot;E:\\Deep_learn\\ORIGAINAL&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> common.layers <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> common.gradient <span class="keyword">import</span> numerical_gradient</span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> OrderedDict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TwoLayerNet</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_size, hidden_size, output_size, weight_init_std = <span class="number">0.01</span></span>):</span><br><span class="line">        <span class="comment"># 初始化权重</span></span><br><span class="line">        self.params = &#123;&#125;</span><br><span class="line">        self.params[<span class="string">&#x27;W1&#x27;</span>] = weight_init_std * np.random.randn(input_size, hidden_size)</span><br><span class="line">        self.params[<span class="string">&#x27;b1&#x27;</span>] = np.zeros(hidden_size)</span><br><span class="line">        self.params[<span class="string">&#x27;W2&#x27;</span>] = weight_init_std * np.random.randn(hidden_size, output_size) </span><br><span class="line">        self.params[<span class="string">&#x27;b2&#x27;</span>] = np.zeros(output_size)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 生成层</span></span><br><span class="line">        self.layers = OrderedDict()</span><br><span class="line">        self.layers[<span class="string">&#x27;Affine1&#x27;</span>] = Affine(self.params[<span class="string">&#x27;W1&#x27;</span>], self.params[<span class="string">&#x27;b1&#x27;</span>])</span><br><span class="line">        self.layers[<span class="string">&#x27;Relu1&#x27;</span>] = Relu()</span><br><span class="line">        self.layers[<span class="string">&#x27;Affine2&#x27;</span>] = Affine(self.params[<span class="string">&#x27;W2&#x27;</span>], self.params[<span class="string">&#x27;b2&#x27;</span>])</span><br><span class="line"></span><br><span class="line">        self.lastLayer = SoftmaxWithLoss()</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> self.layers.values():</span><br><span class="line">            x = layer.forward(x)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> x</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># x:输入数据, t:监督数据</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">loss</span>(<span class="params">self, x, t</span>):</span><br><span class="line">        y = self.predict(x)</span><br><span class="line">        <span class="keyword">return</span> self.lastLayer.forward(y, t)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">self, x, t</span>):</span><br><span class="line">        y = self.predict(x)</span><br><span class="line">        y = np.argmax(y, axis=<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> t.ndim != <span class="number">1</span> : t = np.argmax(t, axis=<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        accuracy = np.<span class="built_in">sum</span>(y == t) / <span class="built_in">float</span>(x.shape[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> accuracy</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># x:输入数据, t:监督数据</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numerical_gradient</span>(<span class="params">self, x, t</span>):</span><br><span class="line">        loss_W = <span class="keyword">lambda</span> W: self.loss(x, t)</span><br><span class="line">        </span><br><span class="line">        grads = &#123;&#125;</span><br><span class="line">        grads[<span class="string">&#x27;W1&#x27;</span>] = numerical_gradient(loss_W, self.params[<span class="string">&#x27;W1&#x27;</span>])</span><br><span class="line">        grads[<span class="string">&#x27;b1&#x27;</span>] = numerical_gradient(loss_W, self.params[<span class="string">&#x27;b1&#x27;</span>])</span><br><span class="line">        grads[<span class="string">&#x27;W2&#x27;</span>] = numerical_gradient(loss_W, self.params[<span class="string">&#x27;W2&#x27;</span>])</span><br><span class="line">        grads[<span class="string">&#x27;b2&#x27;</span>] = numerical_gradient(loss_W, self.params[<span class="string">&#x27;b2&#x27;</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> grads</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gradient</span>(<span class="params">self, x, t</span>):</span><br><span class="line">        <span class="comment"># forward</span></span><br><span class="line">        self.loss(x, t)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># backward</span></span><br><span class="line">        dout = <span class="number">1</span></span><br><span class="line">        dout = self.lastLayer.backward(dout)</span><br><span class="line">        </span><br><span class="line">        layers = <span class="built_in">list</span>(self.layers.values())</span><br><span class="line">        layers.reverse()</span><br><span class="line">        <span class="keyword">for</span> layer <span class="keyword">in</span> layers:</span><br><span class="line">            dout = layer.backward(dout)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 设定</span></span><br><span class="line">        grads = &#123;&#125;</span><br><span class="line">        grads[<span class="string">&#x27;W1&#x27;</span>], grads[<span class="string">&#x27;b1&#x27;</span>] = self.layers[<span class="string">&#x27;Affine1&#x27;</span>].dW, self.layers[<span class="string">&#x27;Affine1&#x27;</span>].db</span><br><span class="line">        grads[<span class="string">&#x27;W2&#x27;</span>], grads[<span class="string">&#x27;b2&#x27;</span>] = self.layers[<span class="string">&#x27;Affine2&#x27;</span>].dW, self.layers[<span class="string">&#x27;Affine2&#x27;</span>].db</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> grads</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过将神经网络的组成元素用层的方式实现，可以轻松的构建不同的神经网络。</p><p>由于数值微分的实现简单，所以一般用数值微分来比较误差反向传播法的结果来验证误差反向传播法的实现是否正确。这个操作被称作<strong>梯度确认</strong>。</p>]]></content:encoded>
      
      
      
      <category domain="http://midnightr3d.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</category>
      
      <category domain="http://midnightr3d.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</category>
      
      
      <comments>http://midnightr3d.top/2024/07/18/%E8%AF%AF%E5%B7%AE%E5%8F%8D%E5%90%91%E4%BC%A0%E6%92%AD%E6%B3%95/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>神经网络的学习</title>
      <link>http://midnightr3d.top/2024/07/15/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AD%A6%E4%B9%A0/</link>
      <guid>http://midnightr3d.top/2024/07/15/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Mon, 15 Jul 2024 08:55:29 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;从数据中学习&quot;&gt;从数据中学习&lt;/h2&gt;
&lt;p&gt;神经网络的学习指的是从数据参数中自动获取最优权重参数的值。在实际的神经网络之中，权重的数量成千上万，随着层数的递进，这个数量还在继续增加。想要人工决定这些数值的大小是不可能的。我们需要让神经网络来根据数值自动决定参数值。通过引入损失函数能够有效的获取最有的权重参数。</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="从数据中学习">从数据中学习</h2><p>神经网络的学习指的是从数据参数中自动获取最优权重参数的值。在实际的神经网络之中，权重的数量成千上万，随着层数的递进，这个数量还在继续增加。想要人工决定这些数值的大小是不可能的。我们需要让神经网络来根据数值自动决定参数值。通过引入损失函数能够有效的获取最有的权重参数。<span id="more"></span></p><p>比如如何用算法实现数字“5”图像的识别？。人可以简单的识别出5，但也没法明确说出是基于何种规律——同时每个人书写5的方式还可能不同，想要找出规律是非常难的。预期从零开始想出识别5的算法，不如通过已有的数据来解决，一种方案是，先从图像中提取特征量，在用机器学习的技术学习特征量的模式（如计算机视觉领域的SIFT.SURF,HOG等）。在机器学习的方法中，由机械搜集到的数据中找出规律性能更高效的解决问题。但将图像转换为特征量的算法仍然是人设计的，对于不同的问题，需要设计不同的特征量，才能有效解决。而神经网络（深度学习）则会直接学习图像本身，深度学习中连特征量都是由机器来学习的。</p><p>神经网络的优点在于对于所有的问题都可以用同一个流程来解决，不管是识别数字5还是识别红绿灯，都可以通过不断学习提供的数据来尝试得到研究问题的模式。</p><p>在深度学习中，一般是把数据分为训练数据和测试数据，先用训练数据寻找最优参数，再用测试数据来得到模型的实际能力，这能正确的评估模型的泛化能力。</p><h2 id="损失函数">损失函数</h2><p>神经网络的学习通过某个指标来寻找最优权重参数，而这个指标通常是<strong>损失函数</strong>，理论上这个函数可以使用任意的，但通常采用均方误差和交叉熵误差。</p><h3 id="均方误差">均方误差</h3><p>均方误差如下式所示： <span class="math display">\[E = \frac{1}{2} \sum_{k}(y_k \,-\, t_k) ^2\]</span>y<sub>k</sub>表示神经网络的输出，t<sub>k</sub>表示监督数据，k为数据的维数。这会求出神经网络的输出和监督数据之差的平方和再相加，用python实现如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mean_squared_error</span>(<span class="params">y,t</span>):</span><br><span class="line"><span class="keyword">return</span> <span class="number">0.5</span>* np.<span class="built_in">sum</span>((y-t) ** <span class="number">2</span>)</span><br></pre></td></tr></table></figure><h3 id="交叉熵误差">交叉熵误差</h3><p>交叉熵误差如下所示： <span class="math display">\[E  = -\sum_{k} t_k\,\, log \,\,y_k\]</span>其中y<sub>k</sub>表示神经网络的输出，t<sub>k</sub>表示监督数据，k为数据的维数，log为以e为底数的自然对数。并且可以看出，交叉熵误差的值，是由正确解标签所对应的输出结果所决定的。</p><p>python实现如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">cross_entropy_error</span>(<span class="params">y,t</span>):</span><br><span class="line">delta = 1e -<span class="number">7</span></span><br><span class="line"><span class="keyword">return</span> -np.<span class="built_in">sum</span>(t * np.log(y + delta ))</span><br></pre></td></tr></table></figure><p>这里的y和t是NumPy数组。函数内部在计算np.log时，加上了一个极小量，这可以避免当np.log(0)时导致的计算错误。</p><h2 id="mini-batch学习">mini-batch学习</h2><p>机器学习使用数据进行学习。使用数据进行学习的本质是通过训练数据来计算损失函数的值，通过选择参数来使这个值不断减小来获得最优参数。所以计算损失函数时必须计算所有的训练数据作为对象。</p><p>但仅以MNIST数据集为例，内涵60000多个训练数据，假如以所有的数据作为训练对象，那花费的时间将是巨大的，况且有些训练数据的数量上百万甚至千万，将他们全部放入损失函数内进行计算是不现实的，因此，我们应当从全部数据中选出一部分作为训练数据，作为全体数据的近似。神经网络通常也是从所有数据中选出一批数据，分别对每个mini-batch进行学习。</p><h2 id="为何要设定损失函数">为何要设定损失函数</h2><p>可能有人要问：“为什么要导入损失函数呢？”以数字识别任务为例，我们想获得的是能提高识别精度的参数，特意再导入一个损失函数不是有些重复劳动吗？也就是说，既然我们的目标是获得使识别精度尽可能高的神经网络，那不是应该把识别精度作为指标吗？对于这一疑问，我们可以根据“导数”在神经网络学习中的作用来回答。下一节中会详细说到，在神经网络的学习中，寻找最优参数(权重和偏置）时，要寻找使损失函数的值尽可能小的参数。为了找到使损失函数的值尽可能小的地方，需要计算参数的导数（确切地讲是梯度)，然后以这个导数为指引，逐步更新参数的值。假设有一个神经网络，现在我们来关注这个神经网络中的某一个权重参数。此时，对该权重参数的损失函数求导，表示的是“如果稍微改变这个权重参数的值，损失函数的值会如何变化”。如果导数的值为负，通过使该权重参数向正方向改变，可以减小损失函数的值；反过来，如果导数的值为正,则通过使该权重参数向负方向改变，可以减小损失函数的值。不过，当导数的值为0时，无论权重参数向哪个方向变化，损失函数的值都不会改变，此时该权重参数的更新会停在此处。之所以不能用识别精度作为指标，是因为这样一来绝大多数地方的导数都会变为0，导致参数无法更新。话说得有点多了，我们来总结一下上面的内容。</p><p>​<strong>在进行神经网络的学习时，不能将识别精度作为指标。因为如果以识别精度为指标，则参数的导数在绝大多数地方都会变为0。</strong></p><p>为什么用识别精度作为指标时，参数的导数在绝大多数地方都会变成0呢？为了回答这个问题，我们来思考另一个具体例子。假设某个神经网络正确识别出了100笔训练数据中的32笔，此时识别精度为32%。如果以识别精度为指标，即使稍微改变权重参数的值，识别精度也仍将保持在32%，不会出现变化。也就是说，仅仅微调参数，是无法改善识别精度的。即便识别精度有所改善，它的值也不会像32.0123….%这样连续变化，而是变为33%、34%这样的不连续的、离散的值。而如果把损失函数作为指标，则当前损失函数的值可以表示为0.92543…··这样的值。并且，如果稍微改变一下参数的值，对应的损失函数也会像0.93432···这样发生连续性的变化。识别精度对微小的参数变化基本上没有什么反应，即便有反应，它的值也是不连续地、突然地变化。作为激活函数的阶跃函数也有同样的情况。出于相同的原因，如果使用阶跃函数作为激活函数，神经网络的学习将无法进行。阶跃函数的导数在绝大多数地方（除了0以外的地方）均为0。也就是说，如果使用了阶跃函数，那么即便将损失函数作为指标，参数的微小变化也会被阶跃函数抹杀，导致损失函数的值不会产生任何变化。阶跃函数就像“竹筒敲石”一样，只在某个瞬间产生变化。而sigmoid函数，不仅函数的输出（竖轴的值）是连续变化的，曲线的斜率（导数）也是连续变化的。也就是说，sigmoid函数的导数在任何地方都不为0。这对神经网络的学习非常重要。得益于这个斜率不会为0的性质，神经网络的学习得以正确进行。</p>]]></content:encoded>
      
      
      
      <category domain="http://midnightr3d.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</category>
      
      <category domain="http://midnightr3d.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</category>
      
      
      <comments>http://midnightr3d.top/2024/07/15/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E7%9A%84%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>简单学习算法的实现</title>
      <link>http://midnightr3d.top/2024/07/01/%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</link>
      <guid>http://midnightr3d.top/2024/07/01/%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/</guid>
      <pubDate>Sun, 30 Jun 2024 16:22:36 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;神经网络的学习步骤&quot;&gt;神经网络的学习步骤&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;前提&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;神经网络存在合适的权重和偏置，调整权重和偏置的过程以便拟合训练数据的过程称为“学习”。神经网络的学习分成以下四个步骤。</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="神经网络的学习步骤">神经网络的学习步骤</h2><p><strong>前提</strong></p><p>神经网络存在合适的权重和偏置，调整权重和偏置的过程以便拟合训练数据的过程称为“学习”。神经网络的学习分成以下四个步骤。<span id="more"></span></p><h3 id="选出mini-batch">选出mini-batch</h3><p>从训练数据中随机选出一部分数据作为mini-batch,我们的目的是尽量减少mini-batch的损失函数的值。</p><h3 id="计算梯度">计算梯度</h3><p>为了减少mini-batch损失函数的值，需要求出各个权重参数的梯度。梯度表示损失函数的值减少最多的方向。</p><h3 id="更新参数">更新参数</h3><p>将权重参数沿梯度方向进行更新</p><h3 id="重复">重复</h3><p>重复前三个步骤</p><h2 id="构建神经网络">构建神经网络</h2><p>接下来我们以两层神经网络为对象（隐藏层为一层），使用MNIST数据集进行学习。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys, os</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加mnist.py所在的目录到Python路径</span></span><br><span class="line">sys.path.append(<span class="string">&quot;E:\\deap_learning\\ORIGAINAL&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot; # 确认common是个文件夹并包含__init__.py文件</span></span><br><span class="line"><span class="string">if not os.path.exists(&quot;E:\\deap_learning\\ORIGAINAL\\common\\__init__.py&quot;):</span></span><br><span class="line"><span class="string">    open(&quot;E:\\deap_learning\\ORIGAINAL\\common\\__init__.py&quot;, &#x27;a&#x27;).close() &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> common.functions <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> common.gradient <span class="keyword">import</span> numerical_gradient</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TwoLayerNet</span>:</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_size, hidden_size, output_size, weight_init_std=<span class="number">0.01</span></span>):</span><br><span class="line">        <span class="comment"># 初始化权重</span></span><br><span class="line">        self.params = &#123;&#125;</span><br><span class="line">        self.params[<span class="string">&#x27;W1&#x27;</span>] = weight_init_std * np.random.randn(input_size, hidden_size)</span><br><span class="line">        self.params[<span class="string">&#x27;b1&#x27;</span>] = np.zeros(hidden_size)</span><br><span class="line">        self.params[<span class="string">&#x27;W2&#x27;</span>] = weight_init_std * np.random.randn(hidden_size, output_size)</span><br><span class="line">        self.params[<span class="string">&#x27;b2&#x27;</span>] = np.zeros(output_size)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, x</span>):</span><br><span class="line">        W1, W2 = self.params[<span class="string">&#x27;W1&#x27;</span>], self.params[<span class="string">&#x27;W2&#x27;</span>]</span><br><span class="line">        b1, b2 = self.params[<span class="string">&#x27;b1&#x27;</span>], self.params[<span class="string">&#x27;b2&#x27;</span>]</span><br><span class="line">    </span><br><span class="line">        a1 = np.dot(x, W1) + b1</span><br><span class="line">        z1 = sigmoid(a1)</span><br><span class="line">        a2 = np.dot(z1, W2) + b2</span><br><span class="line">        y = softmax(a2)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> y</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># x:输入数据, t:监督数据</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">loss</span>(<span class="params">self, x, t</span>):</span><br><span class="line">        y = self.predict(x)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> cross_entropy_error(y, t)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">accuracy</span>(<span class="params">self, x, t</span>):</span><br><span class="line">        y = self.predict(x)</span><br><span class="line">        y = np.argmax(y, axis=<span class="number">1</span>)</span><br><span class="line">        t = np.argmax(t, axis=<span class="number">1</span>)</span><br><span class="line">        </span><br><span class="line">        accuracy = np.<span class="built_in">sum</span>(y == t) / <span class="built_in">float</span>(x.shape[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> accuracy</span><br><span class="line">        </span><br><span class="line">    <span class="comment"># x:输入数据, t:监督数据</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">numerical_gradient</span>(<span class="params">self, x, t</span>):</span><br><span class="line">        loss_W = <span class="keyword">lambda</span> W: self.loss(x, t)</span><br><span class="line">        </span><br><span class="line">        grads = &#123;&#125;</span><br><span class="line">        grads[<span class="string">&#x27;W1&#x27;</span>] = numerical_gradient(loss_W, self.params[<span class="string">&#x27;W1&#x27;</span>])</span><br><span class="line">        grads[<span class="string">&#x27;b1&#x27;</span>] = numerical_gradient(loss_W, self.params[<span class="string">&#x27;b1&#x27;</span>])</span><br><span class="line">        grads[<span class="string">&#x27;W2&#x27;</span>] = numerical_gradient(loss_W, self.params[<span class="string">&#x27;W2&#x27;</span>])</span><br><span class="line">        grads[<span class="string">&#x27;b2&#x27;</span>] = numerical_gradient(loss_W, self.params[<span class="string">&#x27;b2&#x27;</span>])</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> grads</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gradient</span>(<span class="params">self, x, t</span>):</span><br><span class="line">        W1, W2 = self.params[<span class="string">&#x27;W1&#x27;</span>], self.params[<span class="string">&#x27;W2&#x27;</span>]</span><br><span class="line">        b1, b2 = self.params[<span class="string">&#x27;b1&#x27;</span>], self.params[<span class="string">&#x27;b2&#x27;</span>]</span><br><span class="line">        grads = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">        batch_num = x.shape[<span class="number">0</span>]</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># forward</span></span><br><span class="line">        a1 = np.dot(x, W1) + b1</span><br><span class="line">        z1 = sigmoid(a1)</span><br><span class="line">        a2 = np.dot(z1, W2) + b2</span><br><span class="line">        y = softmax(a2)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># backward</span></span><br><span class="line">        dy = (y - t) / batch_num</span><br><span class="line">        grads[<span class="string">&#x27;W2&#x27;</span>] = np.dot(z1.T, dy)</span><br><span class="line">        grads[<span class="string">&#x27;b2&#x27;</span>] = np.<span class="built_in">sum</span>(dy, axis=<span class="number">0</span>)</span><br><span class="line">        </span><br><span class="line">        da1 = np.dot(dy, W2.T)</span><br><span class="line">        dz1 = sigmoid_grad(a1) * da1</span><br><span class="line">        grads[<span class="string">&#x27;W1&#x27;</span>] = np.dot(x.T, dz1)</span><br><span class="line">        grads[<span class="string">&#x27;b1&#x27;</span>] = np.<span class="built_in">sum</span>(dz1, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> grads</span><br></pre></td></tr></table></figure><p>twolayernet类有两个字典型实列变量——params和grads。params内保存了权重参数，并且其中的权重参数会用在推理处理内。而grads内保存了各个参数的梯度。使用<code>numberical_gradient()</code>方法计算梯度后，梯度的信息会保存在grads变量中。随后我们来看下twolayernet方法的实现。</p><p>首先是__init__(self,input_size, hiddensize，output_size）方法，它是类的初始化方法（所谓初始化方法，就是生成TwoLayerNet实例时被调用的方法）。从第1个参数开始，依次表示输入层的神经元数、隐藏层的神经元数、输出层的神经元数。另外，因为进行手写数字识别时，输入图像的大小是784(28×28），输出为10个类别，所以指定参数input_size=784、output_size=10，将隐藏层的个数hidden_size设置为一个合适的值即可。此外，这个初始化方法会对权重参数进行初始化。如何设置权重参数的初始值这个问题是关系到神经网络能否成功学习的重要问题。后面我们会详细讨论权重参数的初始化，这里只需要知道，权重使用符合高斯分布的随机数进行初始化，偏置使用0进行初始化。predict(self，x）和accuracy(self，x，t)的实现和上一章的神经网络的推理处理基本一样。如果仍有不明白的地方，请再回顾一下上一章的内容。另外，loss(self，x，t)是计算损失函数值的方法。这个方法会基于predict(）的结果和正确解标签计算交叉熵误差。剩下的numerical_gradient(self，x，t）方法会计算各个参数的梯度。根据数值微分，计算各个参数相对于损失函数的梯度。另外，gradient(self，x，t)是之后要实现的方法，该方法使用误差反向传播法高效地计算梯度。</p><h2 id="mini-batch的实现">mini-batch的实现</h2><p>在这里的代码中，mini-batch的大小是100，每次需要从60000个训练数据中随机取出100个数据作为mini-batch求梯度，使用随机梯度算法更新参数。随着学习的进行，损失函数的值会逐渐减小，这说明神经网络的权重参数正在逐渐拟合数据，正在向最优参数靠近。</p><h2 id="代码实现">代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> mnist <span class="keyword">import</span> load_mnist</span><br><span class="line"><span class="keyword">from</span> two_layer_net <span class="keyword">import</span> TwoLayerNet</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置本地数据集路径</span></span><br><span class="line">mnist_path = <span class="string">&quot;E:\\deap_learning\\resource&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 读入数据</span></span><br><span class="line">(x_train, t_train), (x_test, t_test) = load_mnist(normalize=<span class="literal">True</span>, one_hot_label=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">network = TwoLayerNet(input_size=<span class="number">784</span>, hidden_size=<span class="number">50</span>, output_size=<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">iters_num = <span class="number">10000</span>  <span class="comment"># 适当设定循环的次数</span></span><br><span class="line">train_size = x_train.shape[<span class="number">0</span>]</span><br><span class="line">batch_size = <span class="number">100</span></span><br><span class="line">learning_rate = <span class="number">0.1</span></span><br><span class="line"></span><br><span class="line">train_loss_list = []</span><br><span class="line">train_acc_list = []</span><br><span class="line">test_acc_list = []</span><br><span class="line"></span><br><span class="line">iter_per_epoch = <span class="built_in">max</span>(train_size / batch_size, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(iters_num):</span><br><span class="line">    batch_mask = np.random.choice(train_size, batch_size)</span><br><span class="line">    x_batch = x_train[batch_mask]</span><br><span class="line">    t_batch = t_train[batch_mask]</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 计算梯度</span></span><br><span class="line">    <span class="comment">#grad = network.numerical_gradient(x_batch, t_batch)</span></span><br><span class="line">    grad = network.gradient(x_batch, t_batch)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 更新参数</span></span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> (<span class="string">&#x27;W1&#x27;</span>, <span class="string">&#x27;b1&#x27;</span>, <span class="string">&#x27;W2&#x27;</span>, <span class="string">&#x27;b2&#x27;</span>):</span><br><span class="line">        network.params[key] -= learning_rate * grad[key]</span><br><span class="line">    </span><br><span class="line">    loss = network.loss(x_batch, t_batch)</span><br><span class="line">    train_loss_list.append(loss)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> i % iter_per_epoch == <span class="number">0</span>:</span><br><span class="line">        train_acc = network.accuracy(x_train, t_train)</span><br><span class="line">        test_acc = network.accuracy(x_test, t_test)</span><br><span class="line">        train_acc_list.append(train_acc)</span><br><span class="line">        test_acc_list.append(test_acc)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;train acc, test acc | &quot;</span> + <span class="built_in">str</span>(train_acc) + <span class="string">&quot;, &quot;</span> + <span class="built_in">str</span>(test_acc))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制图形</span></span><br><span class="line">markers = &#123;<span class="string">&#x27;train&#x27;</span>: <span class="string">&#x27;o&#x27;</span>, <span class="string">&#x27;test&#x27;</span>: <span class="string">&#x27;s&#x27;</span>&#125;</span><br><span class="line">x = np.arange(<span class="built_in">len</span>(train_acc_list))</span><br><span class="line">plt.plot(x, train_acc_list, label=<span class="string">&#x27;train acc&#x27;</span>)</span><br><span class="line">plt.plot(x, test_acc_list, label=<span class="string">&#x27;test acc&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;epochs&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;accuracy&quot;</span>)</span><br><span class="line">plt.ylim(<span class="number">0</span>, <span class="number">1.0</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;lower right&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>附上mnist（本地数据）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> gzip</span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_mnist</span>(<span class="params">normalize=<span class="literal">True</span>, flatten=<span class="literal">True</span>, one_hot_label=<span class="literal">False</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;读入MNIST数据集</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Parameters</span></span><br><span class="line"><span class="string">    ----------</span></span><br><span class="line"><span class="string">    normalize : 将图像的像素值正规化为0.0~1.0</span></span><br><span class="line"><span class="string">    one_hot_label : </span></span><br><span class="line"><span class="string">        one_hot_label为True的情况下，标签作为one-hot数组返回</span></span><br><span class="line"><span class="string">        one-hot数组是指[0,0,1,0,0,0,0,0,0,0]这样的数组</span></span><br><span class="line"><span class="string">    flatten : 是否将图像展开为一维数组</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    Returns</span></span><br><span class="line"><span class="string">    -------</span></span><br><span class="line"><span class="string">    (训练图像, 训练标签), (测试图像, 测试标签)</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    mnist_path = <span class="string">&quot;E:\\deap_learning\\resource&quot;</span></span><br><span class="line"></span><br><span class="line">    dataset = &#123;</span><br><span class="line">        <span class="string">&#x27;train_img&#x27;</span>: load_images(os.path.join(mnist_path, <span class="string">&#x27;train-images-idx3-ubyte.gz&#x27;</span>)),</span><br><span class="line">        <span class="string">&#x27;train_label&#x27;</span>: load_labels(os.path.join(mnist_path, <span class="string">&#x27;train-labels-idx1-ubyte.gz&#x27;</span>)),</span><br><span class="line">        <span class="string">&#x27;test_img&#x27;</span>: load_images(os.path.join(mnist_path, <span class="string">&#x27;t10k-images-idx3-ubyte.gz&#x27;</span>)),</span><br><span class="line">        <span class="string">&#x27;test_label&#x27;</span>: load_labels(os.path.join(mnist_path, <span class="string">&#x27;t10k-labels-idx1-ubyte.gz&#x27;</span>))</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> normalize:</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> (<span class="string">&#x27;train_img&#x27;</span>, <span class="string">&#x27;test_img&#x27;</span>):</span><br><span class="line">            dataset[key] = dataset[key].astype(np.float32)</span><br><span class="line">            dataset[key] /= <span class="number">255.0</span></span><br><span class="line">            </span><br><span class="line">    <span class="keyword">if</span> one_hot_label:</span><br><span class="line">        dataset[<span class="string">&#x27;train_label&#x27;</span>] = _change_one_hot_label(dataset[<span class="string">&#x27;train_label&#x27;</span>])</span><br><span class="line">        dataset[<span class="string">&#x27;test_label&#x27;</span>] = _change_one_hot_label(dataset[<span class="string">&#x27;test_label&#x27;</span>])</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> flatten:</span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> (<span class="string">&#x27;train_img&#x27;</span>, <span class="string">&#x27;test_img&#x27;</span>):</span><br><span class="line">            dataset[key] = dataset[key].reshape(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">28</span>, <span class="number">28</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (dataset[<span class="string">&#x27;train_img&#x27;</span>], dataset[<span class="string">&#x27;train_label&#x27;</span>]), (dataset[<span class="string">&#x27;test_img&#x27;</span>], dataset[<span class="string">&#x27;test_label&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_images</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="keyword">with</span> gzip.<span class="built_in">open</span>(file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = np.frombuffer(f.read(), np.uint8, offset=<span class="number">16</span>)</span><br><span class="line">    <span class="keyword">return</span> data.reshape(-<span class="number">1</span>, <span class="number">784</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">load_labels</span>(<span class="params">file_path</span>):</span><br><span class="line">    <span class="keyword">with</span> gzip.<span class="built_in">open</span>(file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        data = np.frombuffer(f.read(), np.uint8, offset=<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_change_one_hot_label</span>(<span class="params">X</span>):</span><br><span class="line">    T = np.zeros((X.size, <span class="number">10</span>))</span><br><span class="line">    <span class="keyword">for</span> idx, row <span class="keyword">in</span> <span class="built_in">enumerate</span>(T):</span><br><span class="line">        row[X[idx]] = <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> T</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  </span><br></pre></td></tr></table></figure><p>在代码中出现了epoch作为学习时的次数单位。</p><h3 id="什么是-epoch">什么是 <code>epoch</code>？</h3><p>在机器学习和深度学习中，<code>epoch</code>是一个重要的概念。<code>epoch</code>表示整个训练数据集通过神经网络一次。简单来说，一个 <code>epoch</code>就是将所有的训练数据都用来更新模型参数一次。</p><h3 id="epoch-在神经网络中的作用"><code>epoch</code>在神经网络中的作用</h3><p>在训练神经网络时，我们通常不会一次性将整个训练数据集都输入到模型中进行训练，而是将数据集分成多个小批次（batch），然后依次输入模型。这样做的原因包括：</p><ol type="1"><li><strong>内存限制</strong>：一次性处理整个数据集可能会导致内存不足，尤其是当数据集非常大时。</li><li><strong>更稳定的梯度更新</strong>：使用小批次数据可以使梯度更新更加平稳，并能有效避免一些局部最优解。</li></ol><p>在每个 <code>epoch</code> 中，模型会经历以下过程：</p><ol type="1"><li>将训练数据集分成若干个批次（batches）。</li><li>对每个批次进行前向传播、计算损失、后向传播、更新模型参数。</li><li>一个 <code>epoch</code>结束后，通常会进行一次验证，检查模型在验证集上的表现，以判断模型是否在训练中取得进展。</li></ol><h2 id="总结">总结</h2><p>我们以损失函数为基准，找出了使神经网络的值达到最小的权重参数，也就是神经网络学习的目标。为了尽可能找到小的损失函数值，我们使用了函数斜率的梯度法。</p>]]></content:encoded>
      
      
      
      <category domain="http://midnightr3d.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</category>
      
      <category domain="http://midnightr3d.top/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/">深度学习</category>
      
      
      <comments>http://midnightr3d.top/2024/07/01/%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E7%9A%84%E5%AE%9E%E7%8E%B0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>类的优化学习</title>
      <link>http://midnightr3d.top/2024/05/07/2024-05-07-%E7%B1%BB%E7%9A%84%E4%BC%98%E5%8C%96%E5%AD%A6%E4%B9%A0/</link>
      <guid>http://midnightr3d.top/2024/05/07/2024-05-07-%E7%B1%BB%E7%9A%84%E4%BC%98%E5%8C%96%E5%AD%A6%E4%B9%A0/</guid>
      <pubDate>Tue, 07 May 2024 15:25:21 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;类模板&quot;&gt;类模板&lt;/h2&gt;
&lt;p&gt;当你决定你正在编写的类最适合通过某种任意类型进行参数化时，你可以使用&lt;code&gt;template&lt;/code&gt;关键字并指定模板应该参数化的类型来告诉C++，你正在定义一个模板类。</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="类模板">类模板</h2><p>当你决定你正在编写的类最适合通过某种任意类型进行参数化时，你可以使用<code>template</code>关键字并指定模板应该参数化的类型来告诉C++，你正在定义一个模板类。<span id="more"></span>让我们以定义自己版本的STL中使用的pair结构体为例来说明。如果我们想要将这个结构体命名为MyPair，并使其参数化两种类型，我们可以编写如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FirstType, <span class="keyword">typename</span> SecondType&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyPair</span> &#123;</span><br><span class="line">    FirstType first;</span><br><span class="line">    SecondType second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里的语法<code>template &lt;typename FirstType, typename SecondType&gt;</code>告诉C++，接下来是一个类模板，它是根据两种类型参数化的，一个叫做<code>FirstType</code>，一个叫做<code>SecondType</code>。在许多方面，类模板的类型参数与C++函数的常规参数相似。例如，对于客户端而言，参数的实际名称并不重要，就像对函数的参数实际名称也不重要一样。上述定义在功能上等同于下面的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> One, <span class="keyword">typename</span> Two&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyPair</span> &#123;</span><br><span class="line">    One first;</span><br><span class="line">    Two second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在类模板的主体内部，我们可以使用名称<code>One</code>和<code>Two</code>（或<code>FirstType</code>和<code>SecondType</code>）来引用客户端在实例化<code>MyPair</code>时指定的类型，就像函数内部的参数与调用者传递给函数的值相对应一样。</p><p>在上述示例中，我们使用了<code>typename</code>关键字来引入类模板的类型参数。如果你在其他的C++代码库中工作，你可能会看到上面的类模板写成如下形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">FirstType</span>, <span class="keyword">class</span> <span class="title class_">SecondType</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyPair</span> &#123;</span><br><span class="line">    FirstType first;</span><br><span class="line">    SecondType second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这种情况下，<code>typename</code>和<code>class</code>是完全等价的。然而，我认为使用<code>class</code>是误导的，因为它错误地暗示参数必须是类类型。事实并非如此——你仍然可以用<code>class</code>实例化使用原始类型如<code>int</code>或<code>double</code>作为参数的模板。从现在开始，我们将使用<code>typename</code>而不是<code>class</code>。</p><p>要理解这种语法的作用和实现，让我们来看一个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MyWrapper</span> &#123;</span><br><span class="line">    T data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里我们定义了一个模板结构体<code>MyWrapper</code>，它包装了一个数据成员<code>data</code>，类型为模板参数<code>T</code>。这意味着我们可以将<code>MyWrapper</code>实例化为不同类型的包装器，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MyWrapper&lt;<span class="type">int</span>&gt; intWrapper;</span><br><span class="line">MyWrapper&lt;<span class="type">double</span>&gt; doubleWrapper;</span><br></pre></td></tr></table></figure><p>通过这种方式，我们可以在编写代码时灵活地定义通用的数据结构，以便处理不同类型的数据，而不需要为每种数据类型编写不同的代码。</p><p>为了创建特定类型的<code>MyPair</code>实例，我们需要使用类模板的名称，并在尖括号中指定类型参数。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MyPair&lt;<span class="type">int</span>, string&gt; one; <span class="comment">// 一个int和一个string组成的pair</span></span><br><span class="line">one.first = <span class="number">137</span>;</span><br><span class="line">one.second = <span class="string">&quot;Templates are cool!&quot;</span>;</span><br></pre></td></tr></table></figure><p>这种语法应该是从STL中很熟悉的。</p><p>接下来，我们想将<code>MyPair</code>结构体转换为一个具有完全封装性的类，即使用访问器方法和构造函数，而不是暴露数据成员。我们可以开始声明<code>MyPair</code>类，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FirstType, <span class="keyword">typename</span> SecondType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPair</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FirstType first;</span><br><span class="line">    SecondType second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后，我们需要决定为<code>MyPair</code>类定义哪些函数。理想情况下，我们希望有一种方式可以访问存储在pair中的元素，因此我们将定义一对函数<code>getFirst</code>和<code>setFirst</code>，以及一个等效的<code>getSecond</code>和<code>setSecond</code>。这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FirstType, <span class="keyword">typename</span> SecondType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPair</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">FirstType <span class="title">getFirst</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFirst</span><span class="params">(FirstType newValue)</span></span>;</span><br><span class="line">    <span class="function">SecondType <span class="title">getSecond</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSecond</span><span class="params">(SecondType newValue)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FirstType first;</span><br><span class="line">    SecondType second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的是，我们在这里使用模板参数<code>FirstType</code>和<code>SecondType</code>来代表客户端参数化<code>MyPair</code>时的任何类型。我们不需要指示<code>FirstType</code>和<code>SecondType</code>与其他类型（如int或string）有任何不同，因为C++编译器已经从模板声明中知道了这一点。实际上，一旦你定义了一个模板参数，除了一些小的限制之外，你可以在任何可以使用实际类型的地方使用它，C++会理解你的意思。</p><p>现在，我们已经声明了这些函数，接下来应该按照直觉的方式实现它们。如果<code>MyPair</code>不是一个模板类，我们可以写成这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">FirstType <span class="title">MyPair::getFirst</span><span class="params">()</span> </span>&#123; <span class="comment">// 问题：不合法的语法</span></span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但问题是<code>MyPair</code>是一个类模板，而不是一个实际的类。如果我们不告诉C++我们正在尝试为一个类模板实现成员函数，编译器就无法理解我们的意思。因此，正确的方式是这样实现这个成员函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FirstType, <span class="keyword">typename</span> SecondType&gt;</span><br><span class="line">FirstType MyPair&lt;FirstType, SecondType&gt;::<span class="built_in">getFirst</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里，我们明确地在<code>getFirst</code>的实现前加上了一个模板声明，并标记我们正在实现的成员函数是针对<code>MyPair&lt;FirstType, SecondType&gt;</code>的。模板声明对于C++来说是必要的，以便弄清楚这里的<code>FirstType</code>和<code>SecondType</code>是什么意思，因为如果没有这些信息，编译器会认为<code>FirstType</code>和<code>SecondType</code>是实际的类型，而不是类型的占位符。另外，我们提到这个函数是在<code>MyPair&lt;FirstType, SecondType&gt;</code>内部而不仅仅是<code>MyPair</code>内部是必要的，因为实际上并没有一个真正的<code>MyPair</code>类——毕竟，<code>MyPair</code>是一个类模板，而不是一个实际的类。</p><p>其他成员函数可以类似地实现。例如，这里有一个<code>setSecond</code>的实现示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FirstType, <span class="keyword">typename</span> SecondType&gt;</span><br><span class="line"><span class="type">void</span> MyPair&lt;FirstType, SecondType&gt;::<span class="built_in">setSecond</span>(SecondType newValue) &#123;</span><br><span class="line">    second = newValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当为模板类实现成员函数时，在模板类的主体内定义函数时，不需要重复模板定义。因此，以下代码是完全合法的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FirstType, <span class="keyword">typename</span> SecondType&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPair</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">FirstType <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFirst</span><span class="params">(FirstType newValue)</span> </span>&#123;</span><br><span class="line">        first = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">SecondType <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSecond</span><span class="params">(SecondType newValue)</span> </span>&#123;</span><br><span class="line">        second = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FirstType first;</span><br><span class="line">    SecondType second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在类模板的内部，编译器已经知道<code>FirstType</code>和<code>SecondType</code>是模板参数，因此不需要再次提醒。所以即使<code>MyPair</code>是一个参数化了两个参数的模板类，在模板类定义的主体内，我们可以使用名称<code>MyPair</code>，而不必提及它是<code>MyPair&lt;FirstType, SecondType&gt;</code>。这是合法的C++语法，并且在后面几章讨论复制行为时会更加常见。</p><p>现在，假设我们想要定义一个名为<code>swap</code>的成员函数，它接受另一个<code>MyPair</code>类的引用作为输入，并将该<code>MyPair</code>中的元素与接收对象中的元素进行交换。那么我们可以像这样定义该函数的原型：</p><p><spanstyle="text-emphasis:filled red; border:1px solid #330000; background:#0000CC; font-weight:bold;">#这章绝大部分都是在GPT4辅助下学习的，有点过于烧脑筋（悲），希望自己掌握的足够扎实吧。</span></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FirstType, <span class="keyword">typename</span> SecondType&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPair</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">FirstType <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFirst</span><span class="params">(FirstType newValue)</span> </span>&#123;</span><br><span class="line">        first = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">SecondType <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSecond</span><span class="params">(SecondType newValue)</span> </span>&#123;</span><br><span class="line">        second = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(MyPair&amp; other)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FirstType first;</span><br><span class="line">    SecondType second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>尽管<code>MyPair</code>是一个参数化了两个参数的模板类，但在模板类定义的主体内，我们可以使用名称<code>MyPair</code>，而不必提及它是<code>MyPair&lt;FirstType, SecondType&gt;</code>。</p><p>最后让我们来实现<code>swap</code>函数。这个函数接受另一个<code>MyPair</code>对象的引用作为参数，并将其成员变量与当前对象的成员变量进行交换。下面是一个可能的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FirstType, <span class="keyword">typename</span> SecondType&gt;</span><br><span class="line"><span class="type">void</span> MyPair&lt;FirstType, SecondType&gt;::<span class="built_in">swap</span>(MyPair&amp; other) &#123;</span><br><span class="line">    <span class="comment">// 交换第一个成员变量</span></span><br><span class="line">    FirstType tempFirst = first;</span><br><span class="line">    first = other.first;</span><br><span class="line">    other.first = tempFirst;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换第二个成员变量</span></span><br><span class="line">    SecondType tempSecond = second;</span><br><span class="line">    second = other.second;</span><br><span class="line">    other.second = tempSecond;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实现首先创建了临时变量，然后将当前对象和另一个对象的成员变量互换，从而实现了交换操作</p><h2 id="为模板类编写.cpp与.h">为模板类编写.cpp与.h</h2><p>在 C++ 编程中，通常我们会将类的声明放在 <code>.h</code>文件中，而实现部分则放在 <code>.cpp</code> 文件中。这种方式使得 C++编译器可以单独编译 <code>.cpp</code>文件中的代码，并在需要时将其链接到其他程序部分。但是，对于模板类来说，这种分离的做法会导致链接错误。下面将一步步解释为什么会出现这种情况，并展示如何正确处理模板类的定义和实现。</p><h3id="为什么模板类不能像普通类那样分离定义和实现">为什么模板类不能像普通类那样分离定义和实现？</h3><p>模板类在 C++中是一种代码生成工具。当你使用模板类时，实际上你是在创建一个框架，编译器会根据你提供的模板参数来生成具体的类定义。例如，如果你定义了一个模板类<code>MyPair</code>，并用 <code>&lt;int, string&gt;</code>实例化它，编译器将生成一个具体的类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyPair</span>&lt;<span class="type">int</span>, string&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getFirst</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFirst</span><span class="params">(<span class="type">int</span> newValue)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">getSecond</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSecond</span><span class="params">(string newValue)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> first;</span><br><span class="line">    string second;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果编译器在编译过程中没有看到这些成员函数的实现（即<code>.cpp</code>文件中的定义），它将无法为这些函数生成代码。这意味着当你尝试链接程序时，链接器找不到这些函数的定义，导致链接错误。</p><h3 id="如何正确地定义和实现模板类">如何正确地定义和实现模板类？</h3><p>为了避免这种链接问题，模板类的定义和实现通常都放在一个<code>.h</code> 文件中，不单独使用 <code>.cpp</code>文件。这意味着你需要在头文件中包含模板类的全部定义和实现。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> MyPair_Included</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MyPair_Included</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> FirstType, <span class="keyword">typename</span> SecondType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyPair</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">FirstType <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setFirst</span><span class="params">(FirstType newValue)</span> </span>&#123;</span><br><span class="line">        first = newValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">SecondType <span class="title">getSecond</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setSecond</span><span class="params">(SecondType newValue)</span> </span>&#123;</span><br><span class="line">        second = newValue;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    FirstType first;</span><br><span class="line">    SecondType second;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3id="为什么这种做法违背了接口与实现的分离原则">为什么这种做法违背了接口与实现的分离原则？</h3><p>将接口和实现放在同一个文件中似乎违背了接口与实现分离的原则，这个原则旨在通过将实现细节隐藏在不被客户端直接查看的<code>.cpp</code>文件中，从而提供更清晰的接口。然而，在处理模板时，由于模板的特殊性质（即编译时代码生成），通常需要在头文件中提供完整的实现。</p><p>这种做法虽然有些违背传统的代码组织原则，但在模板编程中是必需的，以确保模板实例化时能够正确链接并生成有效的二进制代码。如果不这样做，将导致模板类无法正常使用，因为编译器在实例化模板时需要访问到完整的定义和实现。</p><h2 id="typename-的两个含义">typename 的两个含义</h2><p>在 C++ 编程中，关键字 <code>typename</code> 具有两种不同的含义，这是C++ 语言中较为不幸的特性之一。首先，<code>typename</code>用于声明模板类的类型参数。但除此之外，<code>typename</code>还有另一种用途，如果不特别注意，很容易导致错误。下面我将逐步解释这种用法，并提供相应的代码示例来帮助理解。</p><h3 id="模板类-stack-的定义">模板类 Stack 的定义</h3><p>考虑实现一个类似于 STL <code>stack</code>的后入先出（LIFO）容器，我们通常会将其实现为模板类。这样可以使栈的实现不依赖于元素的具体类型。以下是一个可能的接口定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T value)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    deque&lt;T&gt; elems;  <span class="comment">// 使用 deque 作为内部容器</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个类中，<code>deque&lt;T&gt;</code>被用来作为栈的内部容器。栈的所有操作（如添加或删除元素）都在容器的一端进行，因此使用<code>deque</code> 是合适的选择。</p><h3 id="成员函数的实现">成员函数的实现</h3><p>栈的每个成员函数都可以如下实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">push</span>(T value) &#123;</span><br><span class="line">    elems.<span class="built_in">push_front</span>(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T Stack&lt;T&gt;::<span class="built_in">pop</span>() &#123;</span><br><span class="line">    T result = elems.<span class="built_in">front</span>();</span><br><span class="line">    elems.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">size_t</span> Stack&lt;T&gt;::<span class="built_in">size</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> elems.<span class="built_in">size</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">bool</span> Stack&lt;T&gt;::<span class="built_in">empty</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> elems.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="引入-typename-的必要性">引入 typename 的必要性</h3><p>当我们尝试扩展 <code>Stack</code>类的功能，例如允许类的使用者遍历栈元素时，我们可能会遇到<code>typename</code> 关键字的另一种用途。考虑向 <code>Stack</code>类添加 <code>begin()</code> 和 <code>end()</code>函数，这些函数返回对底层 <code>deque</code> 的迭代器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(T value)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">typename</span> deque&lt;T&gt;::<span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;  <span class="comment">// 正确的语法</span></span><br><span class="line">    <span class="keyword">typename</span> deque&lt;T&gt;::<span class="function">iterator <span class="title">end</span><span class="params">()</span></span>;    <span class="comment">// 正确的语法</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    deque&lt;T&gt; elems;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在模板中，当你需要引用依赖于模板参数的类型时（如<code>deque&lt;T&gt;::iterator</code>），必须在类型前使用<code>typename</code> 关键字。这是因为 <code>deque&lt;T&gt;</code>是一个依赖类型，它的具体形式取决于模板参数 <code>T</code>。在 C++中，当你试图在模板类内部访问一个依赖类型的嵌套类型时，必须使用<code>typename</code> 来明确指出该名称代表一个类型。</p><h3 id="为什么需要-typename-关键字">为什么需要 typename 关键字</h3><p><code>typename</code> 的必要性源于 C++语言的类型解析规则。在模板编程中，编译器在解析模板代码时必须能够区分一个标识符是类型名还是其他类型的名称。由于模板的高度泛化性，直到模板实例化之前，编译器无法确定某个依赖名称是否为类型。因此，<code>typename</code>关键字被用来显式声明一个依赖于模板参数的名称是一个类型。</p><h3 id="实现-begin-和-end-方法">实现 begin() 和 end() 方法</h3><p>给定 <code>Stack</code> 类，实现 <code>begin()</code> 和<code>end()</code> 方法如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> deque&lt;T&gt;::iterator Stack&lt;T&gt;::<span class="built_in">begin</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> elems.<span class="built_in">begin</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> deque&lt;T&gt;::iterator Stack&lt;T&gt;::<span class="built_in">end</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> elems.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些方法提供了访问栈内容的迭代器，允许按照后入先出的顺序遍历元素。例如，如果元素是按照1, 2, 3, 4, 5 的顺序压入栈，那么使用这些迭代器遍历时的顺序将会是 5, 4,3, 2,1。这在调试时非常有用，可以用来检查栈的内容或在元素已经入栈后对它们进行操作。</p><h3 id="总结">总结</h3><p>在 C++ 中，<code>typename</code>关键字的使用有两个场景：一是声明模板参数的类型，二是在模板代码中明确依赖类型的名称是一个类型。虽然这种语法要求在初学者看来可能是冗余的，但它是确保模板代码正确解析和实例化的必要机制。理解并熟悉<code>typename</code> 的使用是每个 C++程序员提升模板编程技能的重要步骤。</p><h2 id="用const来理清接口">用const来理清接口</h2><p>在 C++ 中，<code>const</code>关键字是一种强大的工具，用于限制数据的修改，这对于控制程序状态和防止意外的副作用非常重要。让我们探讨一下<code>const</code>的基本用法以及它如何帮助清晰定义接口，并保护数据不被无意中修改。</p><h3 id="基本用法">基本用法</h3><p><code>const</code> 可以用于多种情况：</p><ol type="1"><li><p><strong>声明常量变量</strong>：当你不希望变量的值在程序中被修改时，可以使用<code>const</code>。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> max_size = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>这里 <code>max_size</code> 被声明为常量，其值不能被更改。</p></li><li><p><strong>修饰函数参数</strong>：在函数参数前加上<code>const</code>可以防止函数内部修改传入的参数，特别是对于引用和指针传递的情况。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">printVector</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : vec) &#123;</span><br><span class="line">        cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// vec.push_back(10); // 这会引发编译错误，因为 vec 是 const</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，尽管 <code>vec</code>是通过引用传递的，但由于它被声明为 <code>const</code>，函数内部不能修改<code>vec</code> 的内容。</p></li><li><p><strong>修饰成员函数</strong>：当你希望保证成员函数不会修改任何成员变量时，可以在成员函数的声明后加上<code>const</code>。这表明该函数不会修改对象的状态：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里，<code>getValue</code> 函数被声明为<code>const</code>，这意味着它不能修改任何成员变量，也不能调用任何非<code>const</code> 的成员函数。</p></li></ol><h3 id="高级用法">高级用法</h3><p><code>const</code> 还可以用在更复杂的场景中，例如：</p><ul><li><p><strong>常量指针和指针常量</strong>：你可以声明指向常量的指针或常量指针，这有助于更精确地控制数据的访问和修改。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span>* ptr1 = &amp;max_size;  <span class="comment">// 指向常量的指针，不能通过 ptr1 修改所指向的值</span></span><br><span class="line"><span class="type">int</span>* <span class="type">const</span> ptr2 = &amp;max_size;  <span class="comment">// 指针常量，ptr2 本身的值不能改变，但可以修改 ptr2 指向的值</span></span><br></pre></td></tr></table></figure></li><li><p><strong>常量成员</strong>：在类中声明成员变量为<code>const</code>，这通常用于那些一旦被构造后就不应更改的属性。</p></li></ul><p><code>const</code>不仅帮助你避免不必要的修改，也是一种声明作者的编程意图的方式，它让代码更加安全和可预测。</p><h2 id="const变量与对象">const变量与对象</h2><p>在 C++ 中，<code>const</code>关键字是一种用于约束变量、对象或成员函数的不可修改性的机制。它的使用可以增加代码的安全性和可预测性，同时有助于设计更加稳定和清晰的接口。下面将详细解释两个示例——<code>const</code>变量和 <code>const</code> 对象，以及如何在实际编程中应用这些概念。</p><h3 id="const-变量"><code>const</code> 变量</h3><p>在前面的讨论中，你已经看到了 <code>const</code>在全局常量中的应用。然而，<code>const</code>不仅限于全局常量，它同样可以用于声明局部变量，以表明这些变量在其作用域内不应被修改。</p><h4 id="优化循环效率的例子">优化循环效率的例子</h4><p>考虑以下代码片段，它通过迭代来处理集合中的一系列元素：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt;::iterator stop = mySet.<span class="built_in">upper_bound</span>(<span class="number">137</span>);</span><br><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator itr = mySet.<span class="built_in">lower_bound</span>(<span class="number">42</span>); itr != stop; ++itr) &#123;</span><br><span class="line">    <span class="comment">/* ... manipulate *itr ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里，我们首先计算了 <code>stop</code>，这是对<code>upper_bound</code>的单次调用结果，然后在循环中使用这个预先计算好的迭代器。这样可以避免在每次循环迭代时重复计算<code>upper_bound</code>，从而提高效率。</p><p>为了确保 <code>stop</code>在循环过程中不被修改（这是一个设计上的决定，因为 <code>stop</code>应当是固定不变的），我们可以将其声明为 <code>const</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> set&lt;<span class="type">int</span>&gt;::iterator stop = mySet.<span class="built_in">upper_bound</span>(<span class="number">137</span>);</span><br><span class="line"><span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator itr = mySet.<span class="built_in">lower_bound</span>(<span class="number">42</span>); itr != stop; ++itr) &#123;</span><br><span class="line">    <span class="comment">/* ... manipulate *itr ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样做的好处是，如果你不小心尝试修改<code>stop</code>，编译器将会报错，从而避免可能的逻辑错误。</p><h3 id="const-对象"><code>const</code> 对象</h3><p>在处理类类型的变量时，<code>const</code>的含义更为复杂。对于基本数据类型，<code>const</code>直接意味着不可修改；但对于对象，我们需要更精细的控制。</p><h4 id="const-成员函数"><code>const</code> 成员函数</h4><p>当你有一个 <code>const</code> 对象时，你只能调用那些被显式标记为<code>const</code>的成员函数。这是因为这些函数保证不会修改对象的状态。例如，考虑以下<code>Point</code> 类：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Point</span>(<span class="type">double</span> x, <span class="type">double</span> y);</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getX</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">getY</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setX</span><span class="params">(<span class="type">double</span> newX)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">setY</span><span class="params">(<span class="type">double</span> newY)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">double</span> x, y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，<code>getX()</code> 和 <code>getY()</code> 被声明为<code>const</code>，这意味着它们不会修改对象。这样设计是为了让这些函数可以安全地被<code>const</code>对象调用，同时也表明这些函数不应该改变任何对象状态。</p><h4 id="实现-const-成员函数">实现 <code>const</code> 成员函数</h4><p>当实现一个 <code>const</code> 成员函数时，你需要在函数实现中也使用<code>const</code> 关键字。例如，<code>Point</code> 类中的<code>getX()</code> 可以这样实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">Point::getX</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结">小结</h3><p>通过使用<code>const</code>，可以设计出更稳健、更安全的程序。它不仅防止了数据被无意中修改，还强制程序员在编写代码前就考虑数据的可变性，从而帮助建立更清晰、更可维护的代码结构。</p><h2 id="const引用">const引用</h2><p>在 C++ 中，使用 <code>const</code>引用（或引用到常量）是一种结合效率与安全性的优秀编程技巧。<code>const</code>引用允许你以引用方式传递对象，以避免昂贵的复制操作，同时保证这些对象在函数调用中不会被修改。这有助于清晰地定义函数的行为，增加代码的可读性和可维护性。</p><h3 id="const-引用的优势"><code>const</code> 引用的优势</h3><h4 id="避免副作用">避免副作用</h4><p>当函数参数以非 <code>const</code>引用传递时，函数内部可能会修改传入的参数。这会造成副作用，使得在不查看函数实现的情况下难以推断程序行为。例如，如果你有一个函数<code>void DoSomething(vector&lt;int&gt;&amp; vec);</code>，你无法仅从声明中判断出<code>DoSomething</code> 是否会修改 <code>vec</code>。</p><h4 id="提高效率">提高效率</h4><p>相比于传值，使用引用传递可以避免复制大型数据结构，如<code>vector</code> 或<code>map</code>，从而提高程序的运行效率。但这种方法的缺点是它可能会引起调用者对数据安全的担忧。</p><h4 id="const-引用解决方案"><code>const</code> 引用解决方案</h4><p>使用 <code>const</code>引用可以同时解决上述两个问题。它保证了函数不会修改传入的参数，从而使函数的行为更加明确，同时保留了引用传递的效率优势。</p><h3 id="const-引用的工作方式"><code>const</code> 引用的工作方式</h3><p>让我们通过一个具体的例子来看看 <code>const</code>引用在实际中是如何工作的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintVector</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; vec.<span class="built_in">size</span>(); ++k)</span><br><span class="line">        cout &lt;&lt; vec[k] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数 <code>PrintVector</code> 接收一个常量引用到<code>vector&lt;int&gt;</code>。这意味着 <code>vec</code> 在<code>PrintVector</code> 函数内被视为常量，不能被修改。因此，即使原始<code>vector</code> 不是常量，它在函数内部也会被当作常量对待。</p><h3 id="const-引用的一般性原理"><code>const</code> 引用的一般性原理</h3><p>每个对象的公共接口可以分为两部分：一个常量接口（不改变对象状态的操作）和一个非常量接口（改变对象状态的操作）。当对象被声明为常量时，只能访问其常量接口。</p><h3 id="使用-const-引用的建议">使用 <code>const</code> 引用的建议</h3><p>当你需要编写一个函数，该函数需要查看数据但不修改数据时，应该考虑使用常量引用作为参数。这不仅提高了效率，还保证了数据的不可变性。</p><h3 id="const-引用与非常量参数"><code>const</code> 引用与非常量参数</h3><p>尽管 <code>const</code>引用主要用于保护数据不被修改，但它们也可以接受非常量对象作为参数。这种情况下，非常量对象在函数内部被当作常量处理，这为编程提供了灵活性，允许同一函数既能处理常量又能处理非常量数据。</p><h2 id="const与指针">const与指针</h2><p>在 C++ 中，混合使用 <code>const</code>和指针时可能会产生一些混淆，因为 <code>const</code>可以以多种方式与指针结合，影响指针和指向的数据的修改权限。这里我们将探讨两种主要的<code>const</code>指针类型：指向常量的指针（pointer-to-const）和常量指针（constpointer），以及如何将它们正确地应用在程序中。</p><h3id="指向常量的指针pointer-to-const">指向常量的指针（Pointer-to-const）</h3><p>指向常量的指针意味着指针指向的数据不能被修改，但你可以改变指针本身指向的地址。这对于保护数据不被函数意外修改非常有用，特别是当你想通过指针传递大型数据结构以提高效率，但又不想在函数中修改这些数据时。</p><p><strong>声明指向常量的指针</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Type* myPointer;</span><br><span class="line">Type <span class="type">const</span>* myPointer;</span><br></pre></td></tr></table></figure><p>这两种声明方式都表示 <code>myPointer</code> 是一个指向<code>Type</code> 类型常量的指针，你不能通过这个指针修改<code>Type</code> 数据，但可以将 <code>myPointer</code>指向另一个地址。</p><h3 id="常量指针const-pointer">常量指针（Const Pointer）</h3><p>常量指针则是指针本身的值（即它指向的地址）不能被修改，但你可以修改它指向地址的数据内容。这适用于当你需要保持指针指向固定位置，但又需要修改该位置数据时的情况。</p><p><strong>声明常量指针</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Type* <span class="type">const</span> myConstPointer;</span><br></pre></td></tr></table></figure><p>这表示 <code>myConstPointer</code> 是一个常量指针，指向<code>Type</code> 类型的数据。你可以修改 <code>myConstPointer</code>指向的数据，但不能改变指针本身的值（即它指向的地址）。</p><h3 id="常量指针到常量const-pointer-to-const">常量指针到常量（ConstPointer-to-Const）</h3><p>如果你需要一个既不能修改指针指向的地址也不能通过指针修改数据的指针，你可以使用常量指针到常量。</p><p><strong>声明常量指针到常量</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> Type* <span class="type">const</span> myPtr;</span><br><span class="line">Type <span class="type">const</span>* <span class="type">const</span> myPtr;</span><br></pre></td></tr></table></figure><p>这里，<code>myPtr</code>是一个常量指针到一个常量数据。这意味着你既不能改变指针<code>myPtr</code> 指向的地址，也不能通过 <code>myPtr</code>修改数据。</p><h3 id="示例声明全局-c-字符串常量">示例：声明全局 C 字符串常量</h3><p>对于想要声明一个全局的 C 字符串常量的情况，正确的声明方式应该是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">char</span>* <span class="type">const</span> kGlobalString = <span class="string">&quot;This is a string!&quot;</span>;</span><br></pre></td></tr></table></figure><p>这里使用了两个 <code>const</code>：第一个 <code>const</code>表明你不能通过 <code>kGlobalString</code> 修改字符串内容；第二个<code>const</code> 表明 <code>kGlobalString</code>的值（即它所指向的地址）不能被改变。</p><h3 id="表格总结">表格总结</h3><p>下面的表格总结了各种 <code>const</code> 指针的声明方式及其属性：</p><table><colgroup><col style="width: 37%" /><col style="width: 20%" /><col style="width: 16%" /><col style="width: 25%" /></colgroup><thead><tr><th>声明语法</th><th>名称</th><th>可重新赋值?</th><th>可修改指向的数据?</th></tr></thead><tbody><tr><td><code>const Type* myPtr</code></td><td>指向常量的指针</td><td>是</td><td>否</td></tr><tr><td><code>Type const* myPtr</code></td><td>指向常量的指针</td><td>是</td><td>否</td></tr><tr><td><code>Type* const myPtr</code></td><td>常量指针</td><td>否</td><td>是</td></tr><tr><td><code>const Type* const myPtr</code></td><td>常量指针到常量</td><td>否</td><td>否</td></tr><tr><td><code>Type const* const myPtr</code></td><td>常量指针到常量</td><td>否</td><td>否</td></tr></tbody></table><p>理解这些不同的 <code>const</code> 用法对于写出更安全、更清晰的 C++代码是非常重要的。随着经验的积累，正确地使用这些 <code>const</code>修饰符将变得更自然，帮助你更好地管理数据的访问权限和修改行为。以下是进一步探讨这些概念的重点和实践指导。</p><h3 id="实践中的-const-指针">实践中的 <code>const</code> 指针</h3><p>理解 <code>const</code>修饰符在指针中的应用对于保护函数外部的数据不被意外修改至关重要，尤其是在处理大型数据结构或系统资源时。例如，当你的函数需要接收大型数据但不需要修改它时，使用指向常量的指针可以确保数据的安全性，同时减少复制操作带来的性能开销。</p><h3 id="选择正确的-const-指针类型">选择正确的 <code>const</code>指针类型</h3><p>选择使用指向常量的指针还是常量指针，应基于你希望如何管理数据的访问和修改：</p><ul><li>如果你想要防止数据被修改，同时允许改变指针的指向，那么使用指向常量的指针（<code>const Type*</code>或 <code>Type const*</code>）。</li><li>如果你需要固定指针的指向但允许修改数据，那么使用常量指针（<code>Type* const</code>）。</li><li>如果需要严格限制指针不改变指向且指向的数据也不被修改，使用常量指针到常量（<code>const Type* const</code>或 <code>Type const* const</code>）。</li></ul><h3 id="理解和记忆技巧">理解和记忆技巧</h3><p>理解这些概念可能初看起来复杂，但可以通过从右到左阅读声明来帮助记忆和理解：</p><ul><li><code>const Type* ptr</code> 读作 "ptr is a pointer to a Type thatis const" — 指针指向一个常量 <code>Type</code>。</li><li><code>Type* const ptr</code> 读作 "ptr is a const pointer to a Type"— 指针本身是常量，指向一个可变的 <code>Type</code>。</li></ul><h3 id="const-指针的适用场景"><code>const</code> 指针的适用场景</h3><ul><li><strong>API设计</strong>：当设计接口（API）时，使用<code>const</code>可以明确函数如何与传入的数据交互，提供更稳定的接口。</li><li><strong>多线程安全</strong>：在多线程环境中，使用 <code>const</code>可以防止数据在不同线程间被意外修改，增加代码的线程安全性。</li><li><strong>优化性能</strong>：通过避免不必要的数据复制，使用<code>const</code> 引用或指针可以帮助提升程序的运行效率。</li></ul><h2 id="const与迭代器">const与迭代器</h2><p>在 C++ 中，处理 <code>const</code>容器时，正确使用迭代器是非常关键的。如你所提供的示例中，当试图在一个<code>const</code>容器上使用普通迭代器时，编译器会报错。这是因为普通迭代器允许修改它遍历的元素，这与<code>const</code> 容器的属性相冲突。为了解决这个问题，我们需要使用<code>const_iterator</code>。下面将详细解释 <code>const_iterator</code>的概念和使用。</p><h3 id="const_iterator-的基本概念"><code>const_iterator</code>的基本概念</h3><p>在 STL（Standard Template Library）中，每个容器类如<code>vector</code>、<code>list</code>、<code>map</code>等都提供了两种类型的迭代器：<code>iterator</code> 和<code>const_iterator</code>。<code>const_iterator</code>是一种特殊的迭代器，它不允许修改其指向的元素，即使这个迭代器用于非<code>const</code> 容器。这使得 <code>const_iterator</code>非常适合在需要保护容器内容不被修改的情况下遍历容器。</p><h3 id="使用-const_iterator-的情景">使用 <code>const_iterator</code>的情景</h3><p>如果你有一个 <code>const</code>容器或者你不想在遍历时修改容器中的元素，就应该使用<code>const_iterator</code>。例如，在打印 <code>vector</code>的内容而不修改它时，应该这样写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintVector</span><span class="params">(<span class="type">const</span> vector&lt;string&gt;&amp; myVector)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (vector&lt;string&gt;::const_iterator itr = myVector.<span class="built_in">begin</span>(); itr != myVector.<span class="built_in">end</span>(); ++itr)</span><br><span class="line">        cout &lt;&lt; *itr &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个函数中，使用 <code>const_iterator</code> 确保了即使<code>myVector</code> 被声明为<code>const</code>，我们也能遍历它，且不会有修改其内容的风险。</p><h3 id="const_iterator-和-iterator-的区别"><code>const_iterator</code>和 <code>iterator</code> 的区别</h3><ul><li><strong>修改权限</strong>：<code>iterator</code>允许修改其指向的元素，而 <code>const_iterator</code> 不允许。</li><li><strong>用于 <code>const</code> 容器</strong>：如果容器被声明为<code>const</code>，那么只能使用 <code>const_iterator</code>。</li></ul><h3 id="如何获取-const_iterator">如何获取<code>const_iterator</code></h3><p><code>const</code> 容器和非 <code>const</code> 容器都提供<code>begin()</code> 和 <code>end()</code> 方法返回<code>const_iterator</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">vector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">iterator <span class="title">begin</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">iterator <span class="title">end</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">const_iterator <span class="title">begin</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="function">const_iterator <span class="title">end</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line">    <span class="comment">// 其他成员函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个简化的 <code>vector</code> 接口中，<code>begin()</code> 和<code>end()</code> 根据容器的 <code>const</code> 属性重载。如果容器是<code>const</code>，那么调用的将是返回 <code>const_iterator</code>的版本。</p><h3 id="const-重载技术"><code>const</code> 重载技术</h3><p><code>const</code> 重载是一种允许函数基于对象的 <code>const</code>状态拥有不同行为的技术。这是通过为同一函数提供 <code>const</code> 和非<code>const</code> 两个版本来实现的。当在 <code>const</code>对象上调用这样的函数时，将调用 <code>const</code> 版本，反之亦然。</p><h2 id="const的局限性">const的局限性</h2><p>在 C++ 中，<code>const</code>关键字有助于增加代码的可读性和稳定性，但其实现和理解上存在一些局限性，特别是在涉及指针和<code>const</code>成员函数时。理解<code>const</code>的局限性，尤其是区分<strong>位级常量性</strong>（bitwiseconstness）和<strong>语义常量性</strong>（semanticconstness）非常重要。</p><h3 id="位级常量性-vs.-语义常量性">位级常量性 vs. 语义常量性</h3><p><strong>位级常量性</strong>指的是对象的成员在物理层面上不能被修改。如果成员函数被声明为<code>const</code>，编译器将确保这个函数不会改变对象的任何成员数据。然而，这种保证仅限于直接的成员；如果对象包含指向其他数据的指针，这些数据本身可以被修改，这就是位级常量性的局限。</p><p><strong>语义常量性</strong>更关注于类的行为。从语义上讲，一个<code>const</code>成员函数不应该允许任何操作改变对象的可观状态。然而，C++ 的<code>const</code>系统不强制执行语义常量性，这是由于编译器无法完全理解函数的语义意图。</p><h3 id="const-成员函数和指针"><code>const</code> 成员函数和指针</h3><p>如你的例子所示，如果一个类包含指向数据的指针，仅将成员函数声明为<code>const</code> 并不能防止这些数据被修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">constFunction</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        elems[<span class="number">0</span>] = <span class="number">137</span>; <span class="comment">// 这是合法的，因为它不修改指针本身</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* elems;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里，尽管 <code>constFunction</code> 是一个 <code>const</code>成员函数，它依然可以修改 <code>elems</code> 指向的数据。这表明了<code>const</code> 关键字在指针和对象状态管理方面的局限性。</p><h3 id="解决方案返回指向常量的指针">解决方案：返回指向常量的指针</h3><p>为了确保 <code>const</code>成员函数不会被用来修改它所访问的数据，可以将返回的指针声明为指向常量的指针。这样可以保证通过这些指针不会修改数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">const</span> <span class="type">int</span>* <span class="title">rawElems</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> elems; <span class="comment">// 现在返回的是指向常量的指针</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span>* elems;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种改变确保了即使函数允许访问内部数据，数据本身也不能通过返回的指针被修改。这有助于维护对象的语义常量性，确保<code>const</code>成员函数的行为符合预期，不会导致对象状态的意外改变。</p><h3 id="一般规则">一般规则</h3><ul><li>尽量保证 <code>const</code>成员函数不仅满足位级常量性，也满足语义常量性。</li><li>避免在 <code>const</code> 成员函数中返回非 <code>const</code>指针。</li><li>当需要提供对内部数据的访问时，考虑返回指向常量的指针或引用。</li></ul><h2 id="mutable">mutable</h2><p>在 C++ 中，<code>mutable</code>是一个关键字，它被用来特别标记类的成员变量。标记为 <code>mutable</code>的成员变量可以在类的 <code>const</code>成员函数中被修改。这允许程序员在维护对象的表面常量性（即对象的外部状态看起来不变）的同时，改变那些不影响对象逻辑状态的内部数据。</p><h3 id="用途和意义">用途和意义</h3><p><code>mutable</code>关键字的引入主要是为了解决在对象方法应保持常量但需要修改某些内部状态的情况。这常见于那些需要缓存、延迟加载或其他内部状态优化的设计中。</p><p><code>mutable</code>关键字提供了一种解决语义常量性和位级常量性冲突的方式，尤其适用于那些虽然不应该改变对象逻辑状态但需要修改成员变量的情形。你提供的<code>GroceryList</code>类的例子就是这种情况的一个典型应用，我们来详细探讨这个问题及其解决方案。</p><h3 id="问题描述与初始实现">问题描述与初始实现</h3><p>原始的 <code>GroceryList</code>类设计意图是封装一个不可变的购物列表，但实际实现中需要从文件动态读取数据，这可能导致对象的内部状态发生变化。初步实现中，所有数据一开始就被读入，这在数据量很大时效率极低。</p><h3 id="改进的延迟加载实现">改进的延迟加载实现</h3><p>为了提高效率，你提出了一种延迟加载的实现方法：仅在实际需要某个元素时才从文件中读取这个元素。这种方法被称为<strong>惰性求值</strong>（lazyevaluation），它是一种优化程序效率的常用技术。然而，这种实现改变了<code>getItemAt</code> 函数的常量性，因为它可能会修改对象的成员变量<code>data</code> 和 <code>sourceStream</code>。</p><h3 id="解决常量性冲突使用-mutable">解决常量性冲突：使用<code>mutable</code></h3><p>虽然从实现的角度看，<code>getItemAt</code>函数修改了对象的数据成员，但从语义的角度看，这个函数应当是常量的，因为它不改变购物列表的逻辑内容（即购物清单的内容）。在这种情况下，C++的 <code>mutable</code> 关键字就显得非常有用。通过将 <code>data</code>和 <code>sourceStream</code> 声明为 <code>mutable</code>，我们可以允许<code>getItemAt</code>函数在保持函数外观上的常量性的同时，进行必要的内部状态修改。</p><h3 id="grocerylist-类的新实现"><code>GroceryList</code> 类的新实现</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GroceryList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GroceryList</span>(<span class="type">const</span> string&amp; filename); <span class="comment">// 从文件加载</span></span><br><span class="line">    <span class="function">string <span class="title">getItemAt</span><span class="params">(<span class="type">int</span> index)</span> <span class="type">const</span></span>;   <span class="comment">// 现在标记为 const</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> vector&lt;string&gt; data;         <span class="comment">// 数据成员现在是 mutable</span></span><br><span class="line">    <span class="keyword">mutable</span> ifstream sourceStream;       <span class="comment">// 文件流也是 mutable</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个新的类定义中，即使 <code>getItemAt</code> 函数被标记为<code>const</code>，它也能修改 <code>data</code> 和<code>sourceStream</code>。这允许 <code>getItemAt</code>在不违反其对外的常量承诺的情况下，懒加载所需的数据。</p><h3 id="mutable-使用的注意事项"><code>mutable</code> 使用的注意事项</h3><p>虽然 <code>mutable</code>是解决特定问题的有力工具，但它的使用需要谨慎： -<strong>使用限制</strong>：<code>mutable</code>应当仅用于那些确实需要在常量成员函数中被修改的成员。 -<strong>慎重考虑</strong>：在使用 <code>mutable</code>之前，确保这样做不会破坏你的类的设计原则或引入不必要的复杂性。 -<strong>正确性检查</strong>：使用 <code>mutable</code>可能会降低代码的直观性和可维护性，因此使用时应仔细检查相关代码，确保其逻辑正确。</p><p>总之，<code>mutable</code>关键字解决了一个特定的设计问题，使得可以在不违反语义常量性的前提下，优化实现细节。这种技术使得接口设计与实现细节之间可以更灵活地权衡，从而在保证接口清晰和直观的同时，提高程序的性能和响应性。</p><h2id="const-正确性const-correctness">const-正确性（const-correctness）</h2><blockquote><p><em>“哎，<code>const</code> 写起来真是麻烦，”我听到有些人抱怨，“如果我在一个地方用了它，我就得到处都用。而且，其他人也有跳过不用的，他们的程序照样能运行。我用的一些库也没有做到<code>const</code> 正确。<code>const</code> 真的值得吗？”</em></p><p>我们可以想象一个类似的场景，这次在射击场：“哎，这把枪的安全装置老是得设置，真麻烦。反正也有其他人不用这个功能，他们有的人也没射中自己的脚……”</p><p>安全操作不当的射手在这个世界上活不长。<code>const</code>使用不当的程序员也是一样，不戴安全帽的木匠和不检查电线是否通电的电工也是。没有理由忽视随产品提供的安全机制，特别是没有任何借口可以让程序员因为懒惰而不编写<code>const</code> 正确的代码。</p><p>​ —— Herb Sutter, 《Exceptional C++》作者，资深 C++ 专家。[Sut98]</p></blockquote><p>在 C++中，<code>const</code>-正确性（const-correctness）是一个确保代码安全性、可读性和维护性的重要实践。它涉及几个关键方面：</p><ol type="1"><li><strong>通过引用或指针传递对象</strong>：<ul><li>使用引用到常量（reference-to-const）或指向常量的指针（pointer-to-const）传递对象，避免了不必要的对象复制，并明确指出函数不应修改对象。</li></ul></li><li><strong>常量成员函数</strong>：<ul><li>不改变对象状态的成员函数应该被标记为<code>const</code>。这表明调用这些函数不会改变对象的状态，有助于清晰地定义类的行为。</li></ul></li><li><strong>常量变量</strong>：<ul><li>被设置后不应更改的变量应声明为<code>const</code>。这样做可以防止变量被意外修改，增强代码的可读性和稳定性。</li></ul></li></ol><p><code>const</code>-正确性的实践对于编写高质量的 C++代码至关重要，它不仅帮助开发者避免潜在的错误，还提高了代码的整体质量和可维护性。通过明确哪些函数和变量可以改变程序状态，开发者可以更好地控制和理解代码的行为。此外，这还有助于在多线程和并发编程中安全地管理数据访问，防止数据竞争和其他同步问题。</p><p>总之，虽然实现<code>const</code>-正确性可能在初期需要更多的努力和考虑，但它为长期维护和代码稳定性带来的好处是显而易见的。如同其他任何安全措施一样，<code>const</code>-正确性是保障软件质量和可靠性的基石。</p><h2id="强化代码安全性和可读性正确使用-const-成员函数和变量">强化代码安全性和可读性：正确使用<code>const</code> 成员函数和变量</h2><p>在 C++ 编程中，正确使用 <code>const</code>关键字是保证代码安全性、清晰性和维护性的重要策略。这涉及到两个主要方面：<code>const</code>成员函数和 <code>const</code> 变量。</p><h3 id="const-成员函数-1">1. <code>const</code> 成员函数</h3><p>在设计类时，应当将不改变对象状态的成员函数显式标记为<code>const</code>。这是因为对于 <code>const</code> 实例，C++只允许调用被显式标记为 <code>const</code>的成员函数。如果没有正确标记，即便函数不修改对象状态，也无法在<code>const</code> 对象上调用它。例如，如果你有一个类<code>Vector</code>，并尝试将其作为 <code>const</code>引用传递给一个函数，却发现 <code>Vector</code> 的成员函数都未被标记为<code>const</code>，那么这个 <code>const Vector</code>就无法执行任何操作，变得无用。</p><p>正确标记非变异成员函数为 <code>const</code>不仅符合逻辑，还提高了代码的可用性和功能性。此外，这种做法还意味着所有未标记为<code>const</code>的成员函数都保证会以某种方式修改对象的内部状态，从接口的角度看，这为理解代码提供了极大的便利。</p><h3 id="const-变量-1">2. <code>const</code> 变量</h3><p>将不会改变的变量标记为 <code>const</code>可以显著提高代码的可读性和可维护性。<code>const</code>关键字明确区分了常量和变量，这对于调试和维护代码非常有帮助。如果一个变量被声明为<code>const</code>，你就不能不小心地通过引用或指针传递给可能会修改它的函数，也不会错误地使用赋值操作符<code>=</code> 代替等于操作符<code>==</code>。即使是在多年后，当其他程序员试图解读你的代码时，他们也会因为不需要关注这些变量是否会被修改而感到轻松。</p><h2 id="利用成员初始化列表优化类构造">利用成员初始化列表优化类构造</h2><p>在 C++编程中，成员初始化列表提供了一种更有效、更精确的方式来初始化类的数据成员。这种方法不仅提高了程序的运行效率，还有助于避免一些常见的编程错误。下面，我们将探讨成员初始化列表的重要性和使用方式。</p><h3 id="为什么需要成员初始化列表">为什么需要成员初始化列表</h3><p>在 C++中构造对象时，对象的每个数据成员都会被默认初始化。然而，如果在构造函数体中赋值，这可能导致数据成员被初始化两次——一次是默认构造，一次是在构造函数体中指定的值。这不仅效率低下，也可能引起其他问题，特别是当数据成员包括复杂对象时。</p><p>成员初始化列表允许在构造函数体执行之前直接初始化数据成员，从而避免不必要的默认构造和后续赋值，提高了构造过程的效率和明确性。</p><h3 id="如何使用成员初始化列表">如何使用成员初始化列表</h3><p>成员初始化列表位于构造函数签名之后，构造函数体之前，以冒号<code>:</code>开始，后跟一系列初始化表达式。每个表达式指定一个数据成员和一个用于初始化该成员的值。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SimpleClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SimpleClass</span>() : <span class="built_in">myInt</span>(<span class="number">5</span>), <span class="built_in">myString</span>(<span class="string">&quot;C++!&quot;</span>), <span class="built_in">myVector</span>(<span class="number">10</span>) &#123;</span><br><span class="line">        <span class="comment">// 构造函数体现在为空</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> myInt;</span><br><span class="line">    string myString;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myVector;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>myInt</code>、<code>myString</code> 和<code>myVector</code>都在构造函数被调用前通过初始化列表直接初始化。这样，每个成员只被初始化一次，且直接初始化为期望的值。</p><h3 id="初始化列表的优点">初始化列表的优点</h3><ul><li><strong>效率</strong>：避免了成员的多次初始化，特别是对于那些构造成本较高的对象，如字符串和向量，这一点尤为重要。</li><li><strong>清晰性</strong>：初始化列表清晰地显示了每个成员变量的初始值，提高了代码的可读性和可维护性。</li><li><strong>灵活性</strong>：即使是 <code>const</code>或引用类型的成员变量，也可以被有效地初始化。</li></ul><p>总的来说，成员初始化列表是 C++类设计中的一个强大工具，它提供了一种清晰、高效的方式来初始化类的数据成员。在实际编程中，尽可能利用这一特性来优化你的类构造过程，将有助于你编写出更加健壮和高效的C++ 程序。</p><h3 id="初始化列表的实际应用与必要性">初始化列表的实际应用与必要性</h3><p>在 C++中，成员初始化列表不仅提高了代码的效率，而且在某些情况下是唯一合法的初始化方式。以下讨论了初始化列表的几个关键用途，及其对于确保代码正确性的重要性。</p><h4 id="使用表达式初始化数据成员">使用表达式初始化数据成员</h4><p>虽然常用的成员初始化列表通常指定常量值，但也可以使用表达式来初始化数据成员。这增加了初始化过程的灵活性，允许根据构造函数的参数来设定初始值，如下例所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RationalNumber</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">RationalNumber</span>(<span class="type">int</span> numerator = <span class="number">0</span>, <span class="type">int</span> denominator = <span class="number">1</span>);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> numerator, denominator;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">RationalNumber::<span class="built_in">RationalNumber</span>(<span class="type">int</span> numerator, <span class="type">int</span> denominator) :</span><br><span class="line">    <span class="built_in">numerator</span>(numerator), <span class="built_in">denominator</span>(denominator) &#123;</span><br><span class="line">    <span class="comment">// 空构造函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个例子中，分子和分母通过构造函数的参数动态初始化，有效地避免了在构造函数体内进行赋值带来的额外开销。</p><h4id="初始化列表在特定情况下的必要性">初始化列表在特定情况下的必要性</h4><p>有些情况下，使用成员初始化列表不仅是提高效率的方法，而且是必须的。例如，对于需要初始化<code>const</code>成员变量或者没有默认构造函数的对象成员，成员初始化列表是必需的。</p><h5 id="初始化-const-成员变量">初始化 <code>const</code> 成员变量</h5><p>例如，如果有一个类 <code>Counter</code>需要限制计数器的最大值，而这个最大值在对象的整个生命周期中不应该改变：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Counter</span>(<span class="type">int</span> maxValue);</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">increment</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">decrement</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getValue</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> maximum;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Counter::<span class="built_in">Counter</span>(<span class="type">int</span> maxValue) : <span class="built_in">value</span>(<span class="number">0</span>), <span class="built_in">maximum</span>(maxValue) &#123;</span><br><span class="line">    <span class="comment">// 空构造函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，<code>maximum</code> 被声明为<code>const</code>，必须在成员初始化列表中初始化。如果尝试在构造函数体中赋值，编译器会报错，因为<code>const</code> 变量一旦初始化后就不能再被修改。</p><h5id="初始化没有默认构造函数的对象成员">初始化没有默认构造函数的对象成员</h5><p>如果类中包含的对象成员没有默认构造函数或需要特定的构造参数，也必须使用初始化列表。例如，如果有一个自定义集合需要特定的比较函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SetWrapperClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SetWrapperClass</span>();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Set&lt;customT&gt; mySet;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">SetWrapperClass::<span class="built_in">SetWrapperClass</span>() : <span class="built_in">mySet</span>(MyCallback) &#123;</span><br><span class="line">    <span class="comment">// 空构造函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这种情况下，<code>mySet</code>必须在成员初始化列表中用适当的回调函数初始化，以确保对象被正确构造。</p><h2 id="静态成员的应用和优化">静态成员的应用和优化</h2><p>静态成员在类设计中扮演着独特而重要的角色，无论是数据成员还是成员函数。它们提供了一种方式来共享数据或行为，而不是将它们绑定到类的特定实例。这可以优化资源使用，简化代码逻辑，并提高程序的整体效率。</p><h3 id="静态数据成员">静态数据成员</h3><p>静态数据成员是与类本身相关联的，而不是与类的任何特定实例相关联。例如，如果我们有一个<code>Window</code> 类，我们可能希望所有窗口共享同一个<code>Palette</code>对象，因为每个窗口都可能使用相同的调色板渲染自己。这可以通过声明<code>Palette</code> 为静态数据成员来实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">drawWindow</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> Palette sharedPal;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在类的实现文件中，我们需要定义这个静态成员：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Palette Window::sharedPal;</span><br></pre></td></tr></table></figure><h3 id="静态成员函数">静态成员函数</h3><p>静态成员函数可以访问类的静态数据成员，但它们不处理类的特定实例。这使它们成为实现与对象实例无关的功能的理想选择。例如，如果我们想要统计<code>Window</code>类的实例数量，我们可以使用静态成员函数和静态数据成员来跟踪这个信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Window</span>() &#123; ++numInstances; &#125;</span><br><span class="line">    ~<span class="built_in">Window</span>() &#123; --numInstances; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getRemainingInstances</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> numInstances;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Window::numInstances = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Window::getRemainingInstances</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numInstances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个模式允许我们在不需要具体窗口实例的情况下，查询活动窗口的数量。</p><h3 id="静态成员的优势">静态成员的优势</h3><ol type="1"><li><strong>资源共享</strong>：静态成员允许类的所有实例共享数据或行为，这在许多情况下可以节约资源。</li><li><strong>封装维护</strong>：通过将全局相关的数据或行为封装在类中，静态成员有助于维护代码的封装性，减少全局变量的使用。</li><li><strong>简化接口</strong>：静态成员函数可以提供一个简单的接口来执行与类相关的操作，而不需要创建类的实例。</li></ol><h3 id="使用注意">使用注意</h3><p>使用静态成员时需要注意确保它们的线程安全性，因为它们在多线程环境中共享同一份数据。此外，正确管理静态数据成员的生命周期和访问权限也是保持程序健売性的关键。</p><h2id="const与static的交互以及类常量的优化">Const与Static的交互以及类常量的优化</h2><p>在 C++ 中，<code>const</code> 和 <code>static</code>关键词在使用时需要注意其交互性，尤其是在设计类的成员函数和数据成员时。这些关键词虽然增加了代码的复杂性，但正确使用可以极大地提升代码的安全性和效率。</p><h3id="const成员函数与static数据成员">Const成员函数与Static数据成员</h3><p><code>const</code>成员函数表明该函数不会修改类的任何非静态成员变量。然而，<code>const</code>成员函数是允许修改静态数据成员的，因为静态数据成员不属于类的任何特定实例，而是属于类本身。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ConstStaticClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">constFn</span><span class="params">()</span> <span class="type">const</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> staticData;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ConstStaticClass::staticData = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">ConstStaticClass::constFn</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">    ++staticData; <span class="comment">// 合法的操作，因为staticData是静态成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管 <code>constFn</code> 被声明为<code>const</code>，但它依然可以修改静态成员<code>staticData</code>。这是因为静态成员的改变不会影响到类的任何具体实例的状态。</p><h3 id="静态成员函数与const">静态成员函数与Const</h3><p>静态成员函数不与任何具体的类实例绑定，因此它们没有 <code>this</code>指针，也就不能被声明为<code>const</code>。静态成员函数主要用于操作静态数据成员或执行不依赖于类实例的操作。</p><h3 id="类常量class-constants">类常量（Class Constants）</h3><p>类常量通常是用 <code>static const</code>声明的，这意味着它们不仅是不可变的，而且是与类相关联而非类的实例。对于整数类型的类常量，C++提供了一种简写方式，可以在类内部直接初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassConstantExample</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* Omitted. */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> MyConstant = <span class="number">137</span>; <span class="comment">// 在类定义内初始化</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种方法简洁且在专业代码中常见，但应注意，这种简写只适用于整数类型的静态常量。</p><h3 id="静态成员函数的实用场景">静态成员函数的实用场景</h3><p>静态成员函数也可以用于管理和监控类的状态，例如，计算类的活动实例数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Window</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Window</span>() &#123; ++numInstances; &#125;</span><br><span class="line">    ~<span class="built_in">Window</span>() &#123; --numInstances; &#125;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">int</span> <span class="title">getRemainingInstances</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> numInstances;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> Window::numInstances = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Window::getRemainingInstances</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> numInstances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法可以无需具体实例即可查询类状态，非常适用于资源管理和状态监控。</p><h2 id="使用-explicit-关键字避免隐式类型转换">使用 <code>explicit</code>关键字避免隐式类型转换</h2><p>在 C++ 中，<code>explicit</code>关键字用于防止构造函数被隐式地用作类型转换。这对于提高代码的安全性和预见性非常重要，尤其是在处理单参数构造函数时。</p><h3 id="隐式转换的问题">隐式转换的问题</h3><p>在没有 <code>explicit</code>关键字的情况下，任何接受单一参数的构造函数都可以被编译器用作隐式类型转换函数。这意味着，如以下示例所示，一个整数可以被隐式地转换为一个复杂的对象，有时这并不是我们所希望的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Vector</span>(<span class="type">int</span> sizeHint = <span class="number">10</span>);</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Vector myVector = <span class="number">10</span>; <span class="comment">// 隐式调用 Vector(int)</span></span><br></pre></td></tr></table></figure><p>这种代码虽然有效，但可能导致逻辑上的错误和混淆，因为它隐藏了一个可能重要的类型转换过程。</p><h3 id="explicit-关键字的作用"><code>explicit</code> 关键字的作用</h3><p>当构造函数被声明为 <code>explicit</code>时，它不会被用于任何隐式类型转换。这意味着必须显式地调用构造函数，从而避免了不期望的类型转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ElemType&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vector</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Vector</span><span class="params">(<span class="type">int</span> sizeHint = <span class="number">10</span>)</span></span>; <span class="comment">// 提示 Vector 的大小</span></span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Vector&lt;<span class="type">int</span>&gt; myVector = <span class="number">10</span>; <span class="comment">// 编译错误，阻止隐式转换</span></span><br><span class="line"><span class="function">Vector&lt;<span class="type">int</span>&gt; <span class="title">myVector</span><span class="params">(<span class="number">10</span>)</span></span>;  <span class="comment">// 正确，显式调用构造函数</span></span><br></pre></td></tr></table></figure><p>通过使用 <code>explicit</code>关键字，我们可以确保类型转换是显而易见的，从而减少了由于隐式转换引起的bug和混淆。</p><h3 id="设计时的考虑">设计时的考虑</h3><p>在设计类时，如果你的类有一个不打算用作类型转换的单参数构造函数，你应该将其标记为<code>explicit</code>。这样做虽然会增加编码工作量，但能极大地提高代码的稳定性和安全性。这是一种预防措施，能够帮助维护类的内聚性，确保类的使用方式符合设计意图。</p><h2 id="总结与练习">总结与练习</h2><h3 id="总结-1">总结：</h3><ol type="1"><li><strong>模板（Templates）</strong>：<ul><li>模板可用于定义依赖于任意类型的抽象族，允许类或函数针对不同的数据类型进行操作。</li></ul></li><li><strong><code>typename</code> 关键字</strong>：<ul><li>用于声明模板类中的类型参数。</li><li>在依赖类型内部嵌套类型前使用，以明确指示类型。</li></ul></li><li><strong>模板类的接口和实现</strong>：<ul><li>应将模板类的接口与实现都放置在 <code>.h</code>文件中，避免为模板类创建 <code>.cpp</code>文件，确保模板的正确实例化。</li></ul></li><li><strong><code>const</code> 关键字的使用</strong>：<ul><li>标记变量为 <code>const</code> 可以防止变量在初始化后被修改。</li><li><code>const</code> 成员函数保证不修改类的任何数据成员。</li><li><code>const</code>成员函数通过明确指出哪些函数是读取值，哪些是写入值，从而澄清接口。</li></ul></li><li><strong><code>const</code> 在指针中的应用</strong>：<ul><li><code>const</code> 位置不同，意义亦不同，例如<code>const int*</code>（指向常量的指针）与<code>int* const</code>（常量指针）。</li></ul></li><li><strong>位常量性与语义常量性</strong>：<ul><li>C++ 强制执行位常量性（bitwiseconstness），开发者需要确保类在语义上也是常量（semanticallyconst）。</li></ul></li><li><strong><code>mutable</code> 关键字</strong>：<ul><li>允许在语义上为常量的函数中修改某些被 <code>mutable</code>修饰的非位常量成员。</li></ul></li><li><strong>成员初始化列表</strong>：<ul><li>在构造函数执行前，用于初始化数据成员到特定值，提高效率并避免不必要的构造与赋值。</li></ul></li><li><strong><code>static</code> 关键字</strong>：<ul><li>表明某数据成员或成员函数是属于类本身，而非类的实例。</li><li>静态数据成员在 <code>.h</code> 文件中声明，在 <code>.cpp</code>文件中定义。</li><li>静态成员函数可以通过 <code>ClassName::functionName()</code>形式调用。</li></ul></li><li><strong>类内部的整数常量</strong>：<ul><li>对于整数类型的静态常量，可以在类定义内直接初始化，无需单独定义。</li></ul></li><li><strong>转换构造函数</strong>：<ul><li>允许类通过一个不同类型的值进行初始化，实现类型之间的隐式转换。</li></ul></li><li><strong><code>explicit</code> 关键字</strong>：<ul><li>用于防止构造函数被隐式地用作类型转换，避免可能导致的编程错误。</li></ul></li></ol><h3 id="练习">练习</h3><ol type="1"><li>如何声明一个类模板？</li></ol><p>要声明一个类模板，你需要使用 <code>template</code>关键字，后跟一对尖括号，其中包含类型参数，这些参数可以用<code>typename</code> 或 <code>class</code> 关键字声明。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    T data;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">method</span><span class="params">(T value)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="2" type="1"><li>如何为类模板实现成员函数？</li></ol><p>类模板的成员函数可以在类模板内部直接定义，或者在类外部定义。在类外部定义时，需要在函数定义前加上模板声明，并使用模板类的名字指定该函数属于哪个模板实例。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> MyClass&lt;T&gt;::<span class="built_in">method</span>(T value) &#123;</span><br><span class="line">    <span class="comment">// 函数实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3" type="1"><li>在声明模板参数时，<code>typename</code> 和 <code>class</code>关键字有何区别？</li></ol><p>在声明模板参数时，<code>typename</code> 和 <code>class</code>关键字没有实际区别，它们都可以用来定义类型参数。<code>typename</code>是较新的用法，更能明确表示参数是一个类型。</p><ol start="4" type="1"><li>在类模板中何时需要在类型前加 <code>typename</code> 关键字？</li></ol><p>在模板类中，当你需要指定依赖于模板参数的类型时，应该在类型前加<code>typename</code>关键字。这通常出现在模板参数是一个类，且你需要使用该类内定义的类型时。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line">    <span class="keyword">typename</span> T::SubType *ptr; <span class="comment">// 使用 typename 指定 SubType 是一个类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="5" type="1"><li>下面的代码行声明了一个类中的成员函数：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> <span class="title">MyFunction</span><span class="params">(<span class="type">const</span> string&amp; input)</span> <span class="type">const</span></span>;</span><br></pre></td></tr></table></figure><p>解释此语句中每个 <code>const</code> 的含义：</p><ul><li>第一个 <code>const</code>：返回类型为<code>const char *</code>，指的是这个函数返回一个指向常量字符的指针，不能通过这个指针修改字符。</li><li>第二个 <code>const</code>：<code>const</code>修饰返回的指针，意味着指针本身也是常量，不能指向别的地方。</li><li>最后一个<code>const</code>：修饰整个成员函数，表示这个成员函数不会修改任何成员变量的状态，可以安全地在常量对象上调用。</li></ul><ol start="6" type="1"><li>什么是 const-overloading？</li></ol><p><code>const</code>-overloading是指在同一个类中定义两个逻辑上相同但常量性不同的成员函数版本。通常一个版本为常量成员函数，用于只读访问，另一个为非常量版本，用于修改对象。这使得相同的函数可以在常量和非常量对象上使用，但行为会根据对象的常量性有所不同。</p><ol start="7" type="1"><li>语义常量性和位常量性有何区别？</li></ol><ul><li><strong>位常量性（Bitwiseconstness）</strong>：指对象的成员在内存中的值不被修改，即从内存层面上看，对象在函数调用前后保持不变。</li><li><strong>语义常量性（Semanticconstness）</strong>：指对象从逻辑上看不发生变化，即即使成员的位值可能改变，对象表现出的行为和状态不变。</li></ul><ol start="8" type="1"><li>常量指针和指向常量的指针有何不同？</li></ol><ul><li><strong>常量指针(<code>T* const ptr</code>)</strong>：指针本身是常量，不能指向其他地址，但可以修改指针指向的数据。</li><li><strong>指向常量的指针(<code>const T* ptr</code>)</strong>：不能通过指针修改所指向的数据，但指针本身可以改变，指向其他地址。</li></ul><ol start="9" type="1"><li>常量引用和普通引用有何不同？</li></ol><p>常量引用（<code>const T&amp;</code>）不允许通过引用修改其绑定的对象，适用于需要保证输入数据不被修改的情况。普通引用（<code>T&amp;</code>）可以通过引用修改其绑定的对象，提供了一种修改原始数据的方法。使用常量引用还可以避免复制对象，从而提高效率，尤其是在传递大型对象时。</p><ol start="10" type="1"><li><code>mutable</code> 关键字有什么作用？</li></ol><p><code>mutable</code>关键字用于声明即使在一个常量对象中也可以被修改的成员变量。这允许在<code>const</code> 成员函数中修改这些被 <code>mutable</code>修饰的成员变量。这通常用于那些不影响对象外部状态的成员，如缓存、计数器等。</p><ol start="11" type="1"><li>类构造涉及哪些步骤？它们的执行顺序是怎样的？</li></ol><p>类的构造过程涉及以下步骤，按顺序执行： -分配内存：为对象分配内存空间。 -初始化成员：通过构造函数初始化列表初始化成员变量。 -执行构造函数体：执行构造函数中的代码。</p><p>这个过程确保了在构造函数体执行前，所有成员变量都已经被正确初始化。</p><ol start="12" type="1"><li>如何声明初始化列表？</li></ol><p>初始化列表用于在构造函数中初始化成员变量，位于构造函数参数列表后，函数体前，由一个冒号开始，后跟一个或多个初始化表达式，每个表达式包含成员变量名和用圆括号或花括号包围的初始值。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyClass</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyClass</span>(<span class="type">int</span> x, <span class="type">double</span> y) : <span class="built_in">a</span>(x), <span class="built_in">b</span>(y) &#123;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">double</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="13" type="1"><li>静态数据是什么，它与普通成员数据有何不同？</li></ol><p>静态数据是与类关联的数据，而不是与类的特定实例关联。这意味着类的所有实例共享相同的静态数据成员。静态成员在类的所有对象之间不是独立的，而普通成员数据在每个对象实例中都有自己的一份拷贝。</p><ol start="14" type="1"><li>在类中添加静态数据需要哪两个步骤？</li></ol><p>添加静态数据成员到类中需要两个步骤： - 在类定义中声明静态成员，并使用<code>static</code> 关键字。 -在类定义外部定义并初始化静态成员，指定它属于哪个类（使用类名和作用域解析运算符<code>::</code>）。</p><ol start="15" type="1"><li>什么是静态成员函数？如何调用静态成员函数？</li></ol><p>静态成员函数是与类本身相关联而不是与类的特定实例相关联的函数。静态成员函数可以在没有类的实例的情况下调用。调用静态成员函数通常使用类名和作用域解析运算符，例如<code>ClassName::staticFunction();</code>。</p><ol start="16" type="1"><li>什么是转换构造函数？</li></ol><p>转换构造函数是一个接受单一参数的构造函数，允许从一种类型隐式转换为类类型。例如，如果一个类接受一个<code>int</code> 类型的参数，那么这个构造函数允许直接从 <code>int</code>转换为该类对象。</p><ol start="17" type="1"><li><code>explicit</code> 关键字有什么作用？</li></ol><p><code>explicit</code>关键字用于防止构造函数定义的隐式类型转换。当构造函数被声明为<code>explicit</code>时，它不会被用作隐式类型转换，这有助于防止因意外的类型转换而引发的错误。只能通过直接调用或类型转换来使用这样的构造函数，增加了代码的可读性和安全性。</p><ol start="18" type="1"><li>解释对象构造过程中涉及的每个步骤。为什么它们按照这个顺序发生？每个步骤为什么是必要的？</li></ol><p>对象的构造过程主要包括以下步骤： 1.<strong>内存分配</strong>：首先为对象分配内存空间。这是必要的因为在创建任何对象之前，必须有足够的内存来存储其成员变量。2.<strong>成员初始化列表</strong>：在构造函数体执行之前，通过成员初始化列表对成员变量进行初始化。这个步骤是必要的，特别是对于const成员和引用成员，因为这些成员必须在构造函数体执行前初始化。3.<strong>构造函数体执行</strong>：执行构造函数中的代码，这可能包括更复杂的初始化逻辑或其他设置。构造函数体提供了在成员初始化之后进一步定制对象状态的机会。</p><p>这些步骤按照此顺序进行是为了保证在构造函数体内访问任何成员变量时，这些变量已经被适当初始化。这对于保持程序的稳定性和预防错误至关重要。</p><ol start="19" type="1"><li>为什么带有默认值的单参数函数必须为其后的每个参数指定默认值？</li></ol><p>这是因为C++中参数的默认值需要从右向左连续。如果一个函数的中间某个参数有默认值，而后面的参数没有，则在调用时会出现歧义，编译器无法确定哪些参数使用了默认值。这样的规则简化了函数调用的解析，确保了在没有提供足够实参时，所有使用默认值的参数都能正确、清晰地被识别。</p><ol start="20" type="1"><li>鉴于软件正确性和安全性至关重要，描述如何在 <code>AltairModule</code>类中适当使用 <code>const</code>，以确保 <code>parentModule</code>成员变量正确表示其所有权关系。</li></ol><p>根据需求，<code>AltairModule</code> 类应该能修改其所指向的<code>OrionModule</code>，但不能更改指向哪个<code>OrionModule</code>。因此，我们应该将 <code>parentModule</code>成员变量声明为指向可变 <code>OrionModule</code>的常量指针（<code>OrionModule* const</code>）。这样，<code>parentModule</code>就不能被重新指向其他对象，但可以通过这个指针修改<code>OrionModule</code> 对象。构造函数应如下实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AltairModule::<span class="built_in">AltairModule</span>(OrionModule* owner) : <span class="built_in">parentModule</span>(owner) &#123;</span><br><span class="line">    <span class="comment">// 构造函数体，可能包含其他初始化逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的实现确保了 <code>parentModule</code>在对象生命周期内始终指向构造时传入的 <code>OrionModule</code>实例，同时允许通过该指针修改 <code>OrionModule</code>。</p><ol start="21" type="1"><li>解释为什么静态成员函数不能被标记为 <code>const</code>。</li></ol><p>静态成员函数不与类的任何特定实例绑定，因此没有 <code>this</code>指针。由于 <code>const</code> 成员函数的含义是不修改通过<code>this</code> 指针访问的成员数据，而静态成员函数没有<code>this</code> 指针，所以不可能声明一个静态成员函数为<code>const</code>。静态成员函数的行为与常量性无关，因为它们不操作类的实例状态。</p>]]></content:encoded>
      
      
      
      <category domain="http://midnightr3d.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</category>
      
      <category domain="http://midnightr3d.top/tags/C/">C++</category>
      
      
      <comments>http://midnightr3d.top/2024/05/07/2024-05-07-%E7%B1%BB%E7%9A%84%E4%BC%98%E5%8C%96%E5%AD%A6%E4%B9%A0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>抽象记忆点</title>
      <link>http://midnightr3d.top/2024/05/07/2024-5-7-%E6%8A%BD%E8%B1%A1%E5%85%A5%E9%97%A8/</link>
      <guid>http://midnightr3d.top/2024/05/07/2024-5-7-%E6%8A%BD%E8%B1%A1%E5%85%A5%E9%97%A8/</guid>
      <pubDate>Tue, 07 May 2024 14:07:13 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;section&quot;&gt;&lt;/h1&gt;
&lt;h2 id=&quot;小结&quot;&gt;小结&lt;/h2&gt;
&lt;ol type=&quot;1&quot;&gt;
&lt;li&gt;&lt;strong&gt;软件系统通常包含数百万行代码，远远超过即使是最有经验的程序员一次能够完全跟踪的范围。&lt;/strong&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="section"></h1><h2 id="小结">小结</h2><ol type="1"><li><strong>软件系统通常包含数百万行代码，远远超过即使是最有经验的程序员一次能够完全跟踪的范围。</strong><span id="more"></span><ul><li>这表明现代软件的规模和复杂性，需要采取有效的管理和设计方法。</li></ul></li><li><strong>软件系统中的单个错误值可能导致整个系统失败。</strong><ul><li>这凸显了在编写软件时准确性和健壮性的重要性。</li></ul></li><li><strong>软件系统中可能的交互数量随着系统组件数量的增加呈指数增长。</strong><ul><li>这提醒我们，随着系统复杂性的增加，需要考虑和管理其交互。</li></ul></li><li><strong>抽象提供了一种以更简单的术语呈现复杂对象的方法。</strong><ul><li>通过抽象，我们可以隐藏细节，使用户能够更轻松地理解和操作对象。</li></ul></li><li><strong>抽象将用户分为客户端和实现者，每个都有不同的任务。这种分离有时被称为抽象屏障。</strong><ul><li>这种分离使系统的设计更模块化和可维护，同时提供了清晰的界面和实现。</li></ul></li><li><strong>抽象描述了许多可能的实现方式，而封装防止客户端窥视这些实现。</strong><ul><li>封装确保了实现细节的安全性和私密性，使得对象的内部状态可以受到保护。</li></ul></li><li><strong>客户端与对象交互的方式称为该对象的接口。</strong><ul><li>接口定义了对象可用的方法和操作，隐藏了实现的细节。</li></ul></li><li><strong>抽象减少了软件系统中的组件数量，降低了系统的最大复杂性。</strong><ul><li>通过抽象，我们可以简化系统的设计和实现，减少潜在的错误和复杂度。</li></ul></li><li><strong>C++的结构体缺乏封装性，因为它们的实现即为接口。</strong><ul><li>这强调了使用类而不是结构体的重要性，以实现更好的封装和抽象。</li></ul></li><li><strong>C++类的概念是接口与实现的实现。</strong><ul><li>类提供了一种结构化的方法来组织代码和数据，同时隐藏了实现的细节。</li></ul></li><li><strong>类中列为public的成员形成了该类的接口，并对任何人可见。</strong><ul><li>这强调了设计良好的接口的重要性，以促进代码的重用和可维护性。</li></ul></li><li><strong>类中列为private的成员属于类的实现部分，只能被该类的成员函数查看。</strong><ul><li>封装私有成员确保了对实现细节的访问限制，提高了代码的安全性和可靠性。</li></ul></li><li><strong>构造函数允许实现者从类被创建的那一刻开始强制执行不变量。</strong><ul><li>构造函数确保了对象的有效初始化，并在创建对象时执行必要的设置和验证。</li></ul></li><li><strong>私有成员函数允许实现者在不暴露实现细节给客户端的情况下分解代码。</strong><ul><li>私有成员函数提供了一种将代码组织成更小、更易管理的部分的方法，同时保持了接口的简洁性和清晰性。</li></ul></li><li><strong>类的实现通常分为包含类定义的.h文件和包含类实现的.cpp文件。</strong><ul><li>这种文件分区方法有助于组织代码，并使其更易于维护和理解。</li></ul></li><li><strong>在实现之前设计类接口，以避免过度专门化接口。</strong><ul><li>这强调了设计良好的接口对于软件系统的灵活性和可维护性的重要性。</li></ul></li></ol><h2 id="练习">练习</h2><ol type="1"><li><strong>在我们讨论抽象时，我们谈到接口和模块化如何指数地降低了系统的最大复杂性。你能想到现实世界中引入间接性如何使得复杂系统更易于管理的例子吗？</strong><ul><li>在现实世界中，一个例子是网络路由器。路由器通过在网络设备之间引入抽象层，如IP地址和路由表，来管理网络流量的路由。这种抽象层使得网络管理员可以轻松地管理和配置网络，而不必直接处理底层硬件和协议细节。</li></ul></li><li><strong>getFrequency和setFrequency等函数的动机是什么，相对于只有一个公有频率数据成员来说？</strong><ul><li>使用getFrequency和setFrequency函数而不是公有频率数据成员的动机在于封装。通过提供访问和修改频率的公共接口，类可以隐藏其内部实现细节，并且可以在必要时对这些操作进行验证和限制，确保数据的一致性和有效性。</li></ul></li><li><strong>构造函数是在什么时候调用的？为什么构造函数有用？</strong><ul><li>构造函数在创建类的新实例时被调用。它用于初始化新对象的状态，确保对象在被使用之前处于一个已知的有效状态。构造函数可以执行必要的设置和验证，以确保对象的一致性和完整性。</li></ul></li><li><strong>公有成员函数和私有成员函数有什么区别？</strong><ul><li>公有成员函数是类的接口的一部分，可以被任何人访问和调用。私有成员函数是类的实现的一部分，只能被类的其他成员函数调用，对外部代码不可见。</li></ul></li><li><strong>类的.h文件中放置什么？.cpp文件中呢？</strong><ul><li>类的.h文件包含类的声明和接口，包括成员变量和公有成员函数的声明。.cpp文件包含类的实现细节，包括构造函数、析构函数和其他私有成员函数的定义。</li></ul></li><li><strong>我们在很大程度上谈论了流库和STL，却没有提及这些库在幕后是如何实现的。解释一下为什么抽象使得可以在不完全了解其工作原理的情况下使用这些库。</strong><ul><li>抽象使得可以在不了解其实现细节的情况下使用这些库，因为它们提供了清晰简洁的接口，隐藏了复杂的内部实现。通过使用这些接口，开发人员可以方便地使用库中提供的功能，而不必担心其底层的实现细节。</li></ul></li><li><strong>假设C++的设计略有不同，即标记为私有的数据成员只能读取但不能写入。也就是说，如果一个名为volume的数据成员被标记为私有，那么客户端可以通过写入myObject.volume来读取值，但不能直接写入volume变量。这将阻止类的客户端错误地修改实现，因为任何可能改变对象数据成员的操作都必须通过公共接口进行。然而，这种设置存在严重的设计缺陷，会使得类的实现变得困难。这个缺陷是什么？（提示：回想一下之前的音量/衰减例子）</strong><ul><li>这种设置的主要设计缺陷在于它破坏了封装性。封装的一个关键原则是将数据和操作放在一起，并确保它们是一致的。如果数据成员只能读取而不能写入，那么类的内部状态可能会在未受控制的情况下被外部修改，这会导致不一致和不可预测的行为，从而破坏了类的封装性和可维护性。</li></ul></li><li>下面是一个表示购物清单的类的接口：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GroceryList</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GroceryList</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addItem</span><span class="params">(string quantity, string item)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeItem</span><span class="params">(string item)</span></span>;</span><br><span class="line">    <span class="function">string <span class="title">itemQuantity</span><span class="params">(string item)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">itemExists</span><span class="params">(string item)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现GroceryList类的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GroceryList</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    map&lt;string, string&gt; items;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">GroceryList</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addItem</span><span class="params">(string quantity, string item)</span> </span>&#123;</span><br><span class="line">        items[item] = quantity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">removeItem</span><span class="params">(string item)</span> </span>&#123;</span><br><span class="line">        items.<span class="built_in">erase</span>(item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">itemQuantity</span><span class="params">(string item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (items.<span class="built_in">find</span>(item) != items.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> items[item];</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">// Return empty string if item not found</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">itemExists</span><span class="params">(string item)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.<span class="built_in">find</span>(item) != items.<span class="built_in">end</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="9" type="1"><li>为什么使用GroceryList类而不只是使用原始的map&lt;string, string&gt;？<ul><li>GroceryList类提供了更高层次的抽象，使得添加、删除和查询商品更加简单和直观。它封装了map的细节，提供了更清晰的接口，使得代码更易于维护和理解。</li></ul></li><li>GroceryList类需要构造函数吗？为什么或为什么不？<ul><li>是的，GroceryList类需要构造函数。构造函数用于初始化类的内部状态，例如清单中包含的商品列表。</li></ul></li><li>给出你在STL中遇到的带参数的构造函数的一个例子。<ul><li>一个例子是vector的构造函数，它接受一个初始大小作为参数：<code>vector&lt;int&gt; vec(10);</code></li></ul></li><li>参数化构造函数有什么用？<ul><li>参数化构造函数允许我们在创建对象时提供初始值，从而初始化对象的状态。这使得对象在创建时可以立即设置为特定的状态，而不需要调用额外的初始化函数。</li></ul></li><li>下面是一个代表Keno游戏的类KenoGame的接口：</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">KenoGame</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">KenoGame</span>();</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNumber</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">numChosen</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">numWinners</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; values)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>实现KenoGame类的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KenoGame</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; chosenNumbers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">KenoGame</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addNumber</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">        chosenNumbers.<span class="built_in">push_back</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">numChosen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> chosenNumbers.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">size_t</span> <span class="title">numWinners</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; values)</span> </span>&#123;</span><br><span class="line">        <span class="type">size_t</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : chosenNumbers) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">find</span>(values.<span class="built_in">begin</span>(), values.<span class="built_in">end</span>(), num) != values.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ol start="14" type="1"><li>参考STL容器章节中Snake的实现。设计并实现一个代表蛇的类。在公共接口中支持哪些操作？如何实现它？<ul><li>蛇类的公共接口可能包括移动、增长、检查碰撞等操作。它可以通过一个链表或数组来存储蛇的身体部分，每次移动时更新身体部分的位置。</li></ul></li></ol>]]></content:encoded>
      
      
      
      <category domain="http://midnightr3d.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</category>
      
      <category domain="http://midnightr3d.top/tags/C/">C++</category>
      
      
      <comments>http://midnightr3d.top/2024/05/07/2024-5-7-%E6%8A%BD%E8%B1%A1%E5%85%A5%E9%97%A8/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>STL运用示例：回文判断</title>
      <link>http://midnightr3d.top/2024/05/01/%E5%9B%9E%E6%96%87%E5%88%A4%E6%96%AD/</link>
      <guid>http://midnightr3d.top/2024/05/01/%E5%9B%9E%E6%96%87%E5%88%A4%E6%96%AD/</guid>
      <pubDate>Wed, 01 May 2024 09:24:34 GMT</pubDate>
      
      <description>&lt;p&gt;是时候用一个简短的例子来结束短暂的STL学习了。&lt;/p&gt;
&lt;h2 id=&quot;回文&quot;&gt;回文&lt;/h2&gt;
&lt;p&gt;回文是向前或向后阅读时相同的单词或短语，例如“racecar”或“Malayalam”。阅读回文时，习惯上会忽略空格、标点符号和大写字母，因此“Mr.
Owl ate my metal worm”和“Go hang a salami! I&#39;m a lasagna
hog。”这两句话将被视为回文。</description>
      
      
      
      <content:encoded><![CDATA[<p>是时候用一个简短的例子来结束短暂的STL学习了。</p><h2 id="回文">回文</h2><p>回文是向前或向后阅读时相同的单词或短语，例如“racecar”或“Malayalam”。阅读回文时，习惯上会忽略空格、标点符号和大写字母，因此“Mr.Owl ate my metal worm”和“Go hang a salami! I'm a lasagnahog。”这两句话将被视为回文。 <span id="more"></span></p><h2 id="判断实现">判断实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsPalindrome</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; input.<span class="built_in">size</span>() / <span class="number">2</span>; ++k)</span><br><span class="line">            <span class="keyword">if</span>(input[k] != input[input.<span class="built_in">length</span>() - <span class="number">1</span> – k])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这种方法只需遍历字符串的前半部分，检查每个字符是否等于字符串另一半上的相应字符。作为一种可能是头一个出现在脑海里的方法，他并没有错，但是太不优雅了。让我们用STL的方法试试。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsPalindrome</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">    string reversed = input;</span><br><span class="line"> <span class="built_in">reverse</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> reversed == input;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这种方法看起来好多了，但需要我们创建字符串的副本，因此效率低于我们的原始实现。我们可以使用迭代器以某种方式模拟初始for 循环的功能吗？答案是肯定的，多亏了reverse_iterators。每个 STL容器类都导出一个类型reverse_iterator，该类型类似于迭代器，只是它向后遍历容器。正如begin 和 end 函数定义容器上的迭代器范围一样，rbegin 和 rend函数定义跨容器的reverse_iterator范围。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isPalindrome</span><span class="params">(string input)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">equal</span>(input.<span class="built_in">begin</span>(),input.<span class="built_in">begin</span>()+ input.<span class="built_in">length</span>()/<span class="number">2</span>,input.<span class="built_in">rbegin</span>()); </span><br><span class="line">    <span class="comment">// rbegin()从end开始向前遍历</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的这个代码一行即可实现判断的功能。</p><p>但这还不能正确处理大写、空格或标点符号。如何改进呢？让我们首先从字符串中剥离除字母字符之外的所有内容。对于此任务，我们可以使用STL remove_if算法，该算法接受迭代器范围和谓词作为输入，然后通过删除谓词返回 true的所有元素来修改范围。与它的伙伴算法 remove 一样，remove_if实际上并没有从序列中删除元素，因此我们需要在之后擦除剩余的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsNotAlpha</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123; <span class="comment">//&lt;cctype&gt;</span></span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isalpha</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsPalindrome</span><span class="params">(string input)</span></span>&#123;</span><br><span class="line">        input.<span class="built_in">erase</span>(<span class="built_in">remove_if</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(), IsNotAlpha),input.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">transform</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(), input.<span class="built_in">begin</span>(), ::toupper);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">equal</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">begin</span>() + input.<span class="built_in">size</span>() / <span class="number">2</span>,input.<span class="built_in">rbegin</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在三行代码中，我们去除了字符串中所有不是字母的字符，将剩下的字符转换为大写，并返回字符串是否向前和向后相同。</p><p>的技术的力量。在结束这个例子之前，让我们考虑回文上的一个变体，我们检查短语中的单词是否向前和向后相同。例如，“Didmom pop? Mom did!”是回文，无论是字母还是文字，而”This isthis“是一个短语，它不是回文，而是回文。与常规回文一样，我们将忽略空格和标点符号，因此“It'san its”算作单词回文，即使它使用了两种不同形式的单词its/it's。我们上面使用的算法适用于整个string，我们可以修改它以逐字工作吗？</p><p>我们仍然要忽略空格、标点符号和大写字母，但现在需要将单词而不是字母视为有意义的单位。有许多可能的算法可以检查此属性，但有一种解决方案特别好。思路如下：</p><p>1.清理输入：去掉除字母和空格以外的所有内容，然后将结果转换为大写。</p><p>2.将输入分解为单词列表。</p><p>3.向前和向后返回列表是否相同</p><p>这是一个完整的代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsNotAlphaOrSpace</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isalpha</span>(ch) &amp;&amp; !<span class="built_in">isspace</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsWordPalindrome</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">        input.<span class="built_in">erase</span>(<span class="built_in">remove_if</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(), IsNotAlphaOrSpace),</span><br><span class="line">                    input.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">transform</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(), input.<span class="built_in">begin</span>(), ::toupper);</span><br><span class="line">        <span class="function">stringstream <span class="title">tokenizer</span><span class="params">(input)</span></span>;</span><br><span class="line">        vector&lt;string&gt; tokens;</span><br><span class="line">        tokens.<span class="built_in">insert</span>(tokens.<span class="built_in">begin</span>(),</span><br><span class="line">                      <span class="built_in">istream_iterator</span>&lt;string&gt;(tokenizer),</span><br><span class="line">                      <span class="built_in">istream_iterator</span>&lt;string&gt;());</span><br><span class="line">        <span class="comment">// 手动检查单词列表是否为回文,书里的equal()可能出现问题，具体https://blog.csdn.net/qq_52828510/article/details/121213451?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171454848816800184139758%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=171454848816800184139758&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-121213451-null-null.142</span></span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> end = input.<span class="built_in">length</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (input[start] != input[end]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string input;</span><br><span class="line">    <span class="built_in">getline</span>(cin,input);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsWordPalindrome</span>(input))&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;no&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="remove的使用介绍">remove的使用介绍</h2><p>代码中，<code>input.erase(...)</code>这一部分是用来清除字符串中不需要的字符。具体来说，它结合了<code>remove_if</code> 函数和 <code>erase</code>方法来实现这个功能。这里是它的工作原理详解：</p><ol type="1"><li><strong><code>remove_if</code> 函数</strong>：<ul><li><code>remove_if</code> 是 C++ STL (Standard Template Library)中的一个函数，用于从一个容器中移除满足特定条件的元素。</li><li>这个函数接受三个参数：容器的开始迭代器、结束迭代器和一个谓词函数（即一个返回布尔值、决定元素是否应被移除的函数）。</li><li>在您的代码中，谓词函数是<code>IsNotAlphaOrSpace</code>，它检查一个字符是否既不是字母也不是空格。如果字符不是字母也不是空格，谓词返回<code>true</code>，表示该字符应被移除。</li><li><code>remove_if</code>实际上并不直接删除元素，而是通过重排容器中的元素，将所有不应被移除的元素移到容器的开始部分，返回一个新的迭代器，指向重排后的最后一个有效元素的下一个位置。</li></ul></li><li><strong><code>erase</code> 方法</strong>：<ul><li>一旦 <code>remove_if</code> 完成了元素的重排，<code>erase</code>方法被用来实际从容器中删除那些不需要的元素。</li><li><code>erase</code> 接受两个迭代器：开始和结束。在这里，它从<code>remove_if</code> 返回的迭代器开始，到字符串的末尾。</li><li>这意味着所有从 <code>remove_if</code>返回的迭代器到容器末尾的元素（即被标记为移除的元素）都将被从字符串中删除。</li></ul></li></ol><p>这样的组合使用<code>remove_if</code> 和 <code>erase</code>被称为“擦除-删除”惯用法（Erase-RemoveIdiom），是一种高效清理容器的方式。</p><h2 id="练习">练习</h2><p><strong>1. 为什么STL算法比手写循环更受推荐？</strong></p><ul><li><strong>性能优化</strong>：STL算法经过严格优化，能够比手写循环提供更好的性能。</li><li><strong>可读性和维护性</strong>：使用STL算法可以使代码更加清晰和易于维护。</li><li><strong>减少错误</strong>：STL算法减少了编程中常见的错误，如边界错误和指针错误。</li></ul><p><strong>2. STL算法中的_if后缀和_n后缀分别表示什么意思？</strong></p><ul><li>**_if后缀**：表示算法版本接受一个谓词（条件函数），用于指定操作的条件。</li><li>**_n后缀**：指算法接受一个额外的数量参数，用于指定操作的元素数量或范围。</li></ul><p><strong>3. STL迭代器有哪五种类别？</strong></p><ul><li><strong>输入迭代器</strong>：仅支持读取序列中的元素。</li><li><strong>输出迭代器</strong>：仅支持写入序列中的元素。</li><li><strong>前向迭代器</strong>：支持读写操作，并能多次遍历序列。</li><li><strong>双向迭代器</strong>：除了前向迭代器的功能外，还可以向后遍历。</li><li><strong>随机访问迭代器</strong>：支持直接访问任何元素，提供最灵活的访问方式。</li></ul><p><strong>4.输入迭代器是否可以在需要前向迭代器的场合使用？反之亦然可以吗？</strong></p><ul><li><strong>输入迭代器用于前向迭代器</strong>：通常不可以，因为输入迭代器不支持多次遍历或双向移动。</li><li><strong>前向迭代器用于输入迭代器</strong>：可以，前向迭代器功能更全。</li></ul><p><strong>5.为什么我们需要back_insert_iterator这类迭代器适配器？</strong></p><p>如果没有这些迭代器适配器，许多STL算法在处理需要动态添加元素到容器的情况时将无法工作，例如在使用<code>copy</code>算法时直接将元素添加到容器尾部。</p><p><strong>6.如何修改代码以计算文件中25到75之间的值的平均数？</strong></p><p>首先使用<code>std::find_if</code>定位值在25到75之间的范围的迭代器，然后使用<code>std::accumulate</code>和<code>std::distance</code>计算这个范围的平均值。如果范围内没有元素，输出相应的消息。</p><p><strong>7.编写一个名为 <code>RemoveShortWords</code>的函数，它接受一个 <code>vector&lt;string&gt;</code>并移除其中所有长度为3或更短的字符串。</strong></p><p>（如果你正确地利用了算法，这个函数可以在两行代码内完成。）</p><p>这个问题可以通过结合使用 STL 的 <code>std::remove_if</code> 和<code>erase</code> 方法解决。这里使用 <code>std::remove_if</code>来标记所有应当被移除的元素，然后用 <code>erase</code>实际移除这些元素。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RemoveShortWords</span><span class="params">(std::vector&lt;std::string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> newEnd = std::<span class="built_in">remove_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">                                 [](<span class="type">const</span> std::string&amp; s) &#123; <span class="keyword">return</span> s.<span class="built_in">length</span>() &lt;= <span class="number">3</span>; &#125;);</span><br><span class="line">    words.<span class="built_in">erase</span>(newEnd, words.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注释</strong>: - <code>remove_if</code> 将遍历<code>words</code> 向量，并应用 lambda 函数到每个字符串。 - Lambda函数检查字符串长度是否小于等于3，返回 <code>true</code>表示该字符串应被移除。 - <code>remove_if</code>将不应被移除的字符串移动到向量的前部，并返回一个新的结束迭代器。 -<code>erase</code>使用这个新的结束迭代器，将所有被标记为移除的字符串从向量中删除。</p><p><strong>8.计算 n 维空间中点到原点的距离</strong></p><p><strong>问题</strong>: 在 n 维空间中，一个点 (x1, x2, x3, ..., xn)到原点的距离是 sqrt(x1^2 + x2^2 + x3^2 + ... + xn^2)。编写一个函数<code>DistanceToOrigin</code>，它接受一个代表空间中点的<code>vector&lt;double&gt;</code>，并返回该点到原点的距离。不要使用任何循环，让算法为你完成繁重的工作。（提示：使用<code>inner_product</code> 算法来计算平方根下的表达式。）</p><p>我们可以使用 <code>std::inner_product</code>算法来计算向量元素的平方和，然后取平方根得到欧几里得距离。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">// For std::inner_product</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">DistanceToOrigin</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt;&amp; point)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">sqrt</span>(std::<span class="built_in">inner_product</span>(point.<span class="built_in">begin</span>(), point.<span class="built_in">end</span>(), point.<span class="built_in">begin</span>(), <span class="number">0.0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注释</strong>: - <code>std::inner_product</code>计算两个序列的点积。这里我们使用同一个向量 <code>point</code>两次，即计算每个维度的平方。 - 初始值 <code>0.0</code>表示累加的起始值。 -最终结果是所有维度平方和的平方根，即从原点到点的距离。</p><ol start="9" type="1"><li><strong>实现一个具有偏好的排序函数 BiasedSort</strong></li></ol><p><strong>问题</strong>: 编写一个名为 <code>BiasedSort</code>的函数，它接受一个引用类型的 <code>vector&lt;string&gt;</code>并按字典顺序对其进行排序，但如果向量中包含字符串 “MeFirst”，则该字符串始终位于排序列表的最前面。</p><p><strong>解决方案</strong>：</p><p>为了解决这个问题，我们可以首先检查是否存在 "Me First"字符串，如果存在，则先将其移至向量的开始位置，然后对剩余的元素进行排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BiasedSort</span><span class="params">(std::vector&lt;std::string&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="string">&quot;Me First&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::<span class="built_in">iter_swap</span>(vec.<span class="built_in">begin</span>(), it);</span><br><span class="line">        std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>() + <span class="number">1</span>, vec.<span class="built_in">end</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注释</strong>: - 使用 <code>std::find</code> 查找 "MeFirst"，如果找到，则与第一个元素交换位置。 - 使用 <code>std::sort</code>对除 "Me First" 外的所有元素进行排序。</p><ol start="10" type="1"><li><strong>编写一个函数 CriticsPick</strong></li></ol><p><strong>问题</strong>: 编写一个函数<code>CriticsPick</code>，该函数接受一个<code>map&lt;string, double&gt;</code>，其中包含电影及其评分（0.0 到10.0之间），并返回一个<code>set&lt;string&gt;</code>，其中包含地图中评分最高的前十部电影的名称。如果map 中的元素少于十个，则结果 set 应包含 map 中的每个字符串。</p><p><strong>解决方案</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::set&lt;std::string&gt; <span class="title">CriticsPick</span><span class="params">(<span class="type">const</span> std::map&lt;std::string, <span class="type">double</span>&gt;&amp; movies)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::pair&lt;std::string, <span class="type">double</span>&gt;&gt; <span class="built_in">sortedMovies</span>(movies.<span class="built_in">begin</span>(), movies.<span class="built_in">end</span>());</span><br><span class="line">    std::<span class="built_in">sort</span>(sortedMovies.<span class="built_in">begin</span>(), sortedMovies.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="keyword">auto</span>&amp; a, <span class="type">const</span> <span class="keyword">auto</span>&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.second &gt; b.second;  <span class="comment">// 降序排序</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    std::set&lt;std::string&gt; topMovies;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; std::<span class="built_in">min</span>(<span class="number">10</span>, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(sortedMovies.<span class="built_in">size</span>())); ++i) &#123;</span><br><span class="line">        topMovies.<span class="built_in">insert</span>(sortedMovies[i].first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> topMovies;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注释</strong>: - 将 map 转换为 vector，以便使用排序算法。 -按评分降序排序电影。 -选取排序后的前10部电影（或者小于10部，如果元素不足的话）。</p><ol start="11" type="1"><li><strong>实现 count 算法</strong></li></ol><p><strong>问题</strong>: 为 <code>vector&lt;int&gt;</code> 实现 count算法。你的函数应该有如下原型：<code>int count(vector&lt;int&gt;::iterator start, vector&lt;int&gt;::iterator stop, int element)</code>，并应该返回区间[start, stop) 中等于 element 的元素数量。</p><p><strong>解决方案</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;::iterator start, std::vector&lt;<span class="type">int</span>&gt;::iterator stop, <span class="type">int</span> element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">count</span>(start, stop, element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注释</strong>: - 直接使用 STL 中的 <code>std::count</code>函数，传递给定的迭代器和元素。</p><ol start="12" type="1"><li><strong>使用 generate_n 和 rand函数填充随机数向量，并计算平均值</strong></li></ol><p><strong>问题</strong>: 使用 <code>generate_n</code>算法、<code>rand</code> 函数和 <code>back_insert_iterator</code>来填充一个向量，指定数量的随机值。然后使用 <code>accumulate</code>计算该范围的平均值。</p><p><strong>解决方案</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span>  <span class="comment">// For rand()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PopulateAndAverage</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line">    std::<span class="built_in">generate_n</span>(std::<span class="built_in">back_inserter</span>(numbers), count, []() &#123; <span class="keyword">return</span> <span class="built_in">rand</span>() % <span class="number">100</span>; &#125;);</span><br><span class="line">    <span class="type">double</span> average = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(std::<span class="built_in">accumulate</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">0</span>)) / numbers.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Average: &quot;</span> &lt;&lt; average &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注释</strong>: - 使用 <code>generate_n</code> 和<code>back_inserter</code> 向量填充随机数。<code>back_inserter</code>创建一个后插迭代器，自动处理向量的大小调整。 - 随机数范围设置为 0 到99。 - 使用 <code>accumulate</code>计算总和，然后除以元素数量得到平均值。</p><ol start="13" type="1"><li><strong>计算一组数据的中位数</strong></li></ol><p><strong>问题</strong>:中位数是指在一组数据中，有一半的数据比它大，另一半数据比它小。对于拥有奇数个元素的数据集，这是排序后的中间元素；对于偶数个元素的数据集，它是两个中间元素的平均值。使用<code>nth_element</code> 算法编写一个计算数据集中位数的函数。</p><p><strong>解决方案</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Median</span><span class="params">(std::vector&lt;<span class="type">double</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> n = data.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line">    std::<span class="built_in">nth_element</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">begin</span>() + n, data.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> data[n];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> max_it = std::<span class="built_in">max_element</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">begin</span>() + n);</span><br><span class="line">        <span class="keyword">return</span> (*max_it + data[n]) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注释</strong>: - 使用 <code>nth_element</code>定位中间元素，该算法可以更快地找到第 n 个位置的元素，而不需要完全排序。-对于偶数元素的数据集，找到前半部分的最大值，与中间位置的下一个元素求平均。</p><ol start="14" type="1"><li><strong>使用 copy、istreambuf_iterator 和 ostreambuf_iterator打开文件并打印其内容</strong></li></ol><p><strong>问题</strong>: 展示如何使用<code>copy</code>、<code>istreambuf_iterator</code> 和<code>ostreambuf_iterator</code> 打开一个文件并将其内容打印到 cout。</p><p><strong>解决方案</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintFileContents</span><span class="params">(<span class="type">const</span> std::string&amp; filename)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(filename)</span></span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(std::<span class="built_in">istreambuf_iterator</span>&lt;<span class="type">char</span>&gt;(file),</span><br><span class="line">              std::<span class="built_in">istreambuf_iterator</span>&lt;<span class="type">char</span>&gt;(),</span><br><span class="line">              std::<span class="built_in">ostreambuf_iterator</span>&lt;<span class="type">char</span>&gt;(std::cout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注释</strong>: - 使用 <code>istreambuf_iterator</code>从文件读取字符。 - 使用 <code>ostreambuf_iterator</code>将字符输出到标准输出。 - <code>copy</code>算法在这两个迭代器之间传输内容，直接从文件流复制到输出流，无需额外缓存。</p><ol start="15" type="1"><li><strong>使用 copy 和迭代器适配器将 STL容器的内容写入文件</strong></li></ol><p><strong>问题</strong>: 展示如何使用 <code>copy</code>和迭代器适配器将 STL容器的内容写入文件，其中每个元素存储在自己的一行上。</p><p><strong>解决方案</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteToFile</span><span class="params">(<span class="type">const</span> std::vector&lt;T&gt;&amp; data, <span class="type">const</span> std::string&amp; filename)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ofstream <span class="title">file</span><span class="params">(filename)</span></span>;</span><br><span class="line">    <span class="function">std::ostream_iterator&lt;T&gt; <span class="title">out_it</span><span class="params">(file, <span class="string">&quot;\n&quot;</span>)</span></span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), out_it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注释</strong>: - 使用 <code>ostream_iterator</code>定义输出到文件的迭代器，并设置每个元素后跟一个换行符。 -<code>copy</code>算法用于从容器复制元素到文件流，每写入一个元素后自动插入一个换行符。</p><ol start="16" type="1"><li><strong>打印两个已排序向量的共同元素</strong></li></ol><p><strong>问题</strong>: 假设你有两个元素已经存储在排序顺序中的<code>vector&lt;int&gt;</code>。展示如何使用一行代码通过<code>set_intersection</code>算法和适当的迭代器适配器打印出这两个向量的共有元素。</p><p><strong>解决方案</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintCommonElements</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; v1, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; v2)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">set_intersection</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(),</span><br><span class="line">                          std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注释</strong>: - 使用 <code>set_intersection</code>算法找出两个排序向量的共同元素。 - <code>ostream_iterator</code>用于将找到的共同元素直接打印到标准输出，每个元素后面跟一个空格。</p><p>这些示例展示了如何有效地利用 STL算法和迭代器来简化常见的编程任务，同时保持代码的简洁和高效。通过这种方式，可以显著提升代码的可读性和维护性，同时利用现代C++ 提供的强大功能来处理复杂的数据结构和算法操作。</p>]]></content:encoded>
      
      
      
      <category domain="http://midnightr3d.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</category>
      
      <category domain="http://midnightr3d.top/tags/C/">C++</category>
      
      
      <comments>http://midnightr3d.top/2024/05/01/%E5%9B%9E%E6%96%87%E5%88%A4%E6%96%AD/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>XYCTF_WP</title>
      <link>http://midnightr3d.top/2024/04/25/XYCTF%20WP/</link>
      <guid>http://midnightr3d.top/2024/04/25/XYCTF%20WP/</guid>
      <pubDate>Thu, 25 Apr 2024 14:23:02 GMT</pubDate>
      
      <description>&lt;p&gt;咸鱼头一次做出比较多的比赛，学到了很多东西（虽然感觉应该早该会的），后面会逐步把没做出的re复现&lt;/p&gt;
&lt;h2 id=&quot;聪明的信使&quot;&gt;聪明的信使</description>
      
      
      
      <content:encoded><![CDATA[<p>咸鱼头一次做出比较多的比赛，学到了很多东西（虽然感觉应该早该会的），后面会逐步把没做出的re复现</p><h2 id="聪明的信使">聪明的信使 <span id="more"></span></h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl encrypt(char *a1, int a2)</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax</span><br><span class="line">  char v3; // [esp+Bh] [ebp-5h]</span><br><span class="line">  int i; // [esp+Ch] [ebp-4h]</span><br><span class="line"></span><br><span class="line">  for ( i = 0; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (unsigned __int8)a1[i];</span><br><span class="line">    if ( !(_BYTE)result )</span><br><span class="line">      break;</span><br><span class="line">    v3 = a1[i];</span><br><span class="line">    if ( v3 &lt;= 96 || v3 &gt; 122 )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v3 &gt; 64 &amp;&amp; v3 &lt;= 90 )</span><br><span class="line">        v3 = (v3 + a2 - 65) % 26 + 65;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = (v3 + a2 - 97) % 26 + 97;</span><br><span class="line">    &#125;</span><br><span class="line">    a1[i] = v3;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>签到题，点开加密函数发现是凯撒密码，偏移量为9，使用逆向解密函数得解：</p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_caesar</span>(<span class="params">encrypted_str, shift</span>):</span><br><span class="line">    decrypted_str = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> encrypted_str:</span><br><span class="line">        <span class="comment"># 确保字符是字母</span></span><br><span class="line">        <span class="keyword">if</span> char.isalpha():</span><br><span class="line">            <span class="comment"># 获取字符的ASCII码</span></span><br><span class="line">            ascii_offset = <span class="built_in">ord</span>(char)</span><br><span class="line">            <span class="comment"># 判断是大写还是小写字母</span></span><br><span class="line">            <span class="keyword">if</span> char.isupper():</span><br><span class="line">                <span class="comment"># 大写字母的ASCII范围是65-90</span></span><br><span class="line">                base = <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 小写字母的ASCII范围是97-122</span></span><br><span class="line">                base = <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">                <span class="comment"># 执行解密操作</span></span><br><span class="line">            decrypted_char = <span class="built_in">chr</span>((ascii_offset - base - shift) % <span class="number">26</span> + base)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 非字母字符不进行解密</span></span><br><span class="line">            decrypted_char = char</span><br><span class="line">            <span class="comment"># 将解密后的字符添加到结果字符串中</span></span><br><span class="line">        decrypted_str += decrypted_char</span><br><span class="line">    <span class="keyword">return</span> decrypted_str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">encrypted_str = <span class="string">&quot;oujp&#123;H0d_TwXf_Lahyc0_14_e3ah_Rvy0ac@wc!&#125;&quot;</span></span><br><span class="line">shift = -<span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密字符串</span></span><br><span class="line">decrypted_str = decrypt_caesar(encrypted_str, -shift)</span><br><span class="line"><span class="built_in">print</span>(decrypted_str)</span><br><span class="line"><span class="comment"># flag&#123;Y0u_KnOw_Crypt0_14_v3ry_Imp0rt@nt!&#125;</span></span><br></pre></td></tr></table></figure><h2 id="喵喵喵的flag碎了一地">喵喵喵的flag碎了一地</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">puts(&quot;Hint:&quot;);</span><br><span class="line">  puts(&quot;1. Open in IDA and Learn about `Strings` to find the first part of the flag&quot;);</span><br><span class="line">  puts(&quot;2. Learn about `Functions` to find the second part of the flag which is the name of a function&quot;);</span><br><span class="line">  puts(&quot;3. The hint for the last part is in the function you found in the second part&quot;);</span><br></pre></td></tr></table></figure><p>打开主函数发现hint。根据提示一步一步来。shift + F12发现目标字符串</p><p><code>flag&#123;My_fl@g_h4s_</code></p><p>在函数栏里搜索 <code>_</code> 发现第二段<code>br0ken_4parT_</code></p><p>点进去后对函数头按下X发现引用路径<code>int func718()</code>，转换成字符后发现不够，转换成汇编代码发现余下部分。结合得到flag:<code>flag&#123;My_fl@g_h4s_br0ken_4parT_f1x_1t!&#125;</code></p><h2 id="你真的是大学生吗">你真的是大学生吗</h2><p>DIE查看发现是16位文件，无法运行。在ida里只能查看汇编代码和流程图。分析得知逻辑:输入的20个字符首先第零位和第19位进行异或，代替第十八位，19位和18位异或代替17位。。。以此类推将整个输入除了第19位全部替换。由于异或的逆运算是本身，所以得到解密脚本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 待比较的字节序列</span></span><br><span class="line">enc = [</span><br><span class="line">    <span class="number">0x76</span>, <span class="number">0x0E</span>, <span class="number">0x77</span>, <span class="number">0x14</span>, <span class="number">0x60</span>, <span class="number">0x06</span>, <span class="number">0x7D</span>, <span class="number">0x04</span>, <span class="number">0x6B</span>, <span class="number">0x1E</span>,</span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x2A</span>, <span class="number">0x44</span>, <span class="number">0x2B</span>, <span class="number">0x5C</span>, <span class="number">0x03</span>, <span class="number">0x3B</span>, <span class="number">0x0B</span>, <span class="number">0x33</span>, <span class="number">0x05</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">denc = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">19</span>):</span><br><span class="line">    denc.append(<span class="built_in">chr</span>(enc[i] ^ enc[i+<span class="number">1</span>]))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> denc:</span><br><span class="line">    <span class="built_in">print</span>(i,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment"># 最后一位为 &#x27;&#125;&#x27;</span></span><br><span class="line"><span class="comment"># flag: xyctf&#123;you_know_8086&#125;</span></span><br></pre></td></tr></table></figure><h2 id="debugme">DebugMe</h2><p>jeb打开文件后分析java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view0)</span> &#123;</span><br><span class="line">              <span class="keyword">if</span>(Debug.isDebuggerConnected()) &#123;</span><br><span class="line">                  Toast.makeText(MainActivity.<span class="built_in">this</span>, What.x(<span class="string">&quot;WikFhRxyYjoSJ8mMbM3fRwty/74bc7Ip7ojqenHaSqc9wDv3JDG9XfV6xEiC7Eg1RWTUa4LaM%2BD0W%2BPKanSA5w==&quot;</span>), <span class="number">0</span>).show();</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              Toast.makeText(MainActivity.<span class="built_in">this</span>, <span class="string">&quot;flag呢&quot;</span>, <span class="number">0</span>).show();</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure><p>发现关键部分，只要检测到调试就会自动解密就会弹出flag。用模拟器连接调试得到flag:</p><h2 id="trustme">TrustMe</h2><p>启动后需要输入用户名和密码。打开源码发现用户名是个RC4加密</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(MainActivity.bytesToHex(MainActivity.RC4(textView1.getText().toString().getBytes(), <span class="string">&quot;XYCTF&quot;</span>.getBytes())).equals(<span class="string">&quot;5a3c46e0228b444decc7651c8a7ca93ba4cb35a46f7eb589bef4&quot;</span>)) &#123;</span><br><span class="line">           Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;成功!&quot;</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在线解密可得账户<code>The Real username is admin</code></p><p>接着查看剩下的类没有发现具体处理密码的痕迹。但是在<code>ProxyApplication</code>类中发现了文件读入读出，以及一个可疑的异或</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] decrypt(<span class="type">byte</span>[] arr_b) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; arr_b.length; ++v) &#123;</span><br><span class="line">            arr_b[v] = (<span class="type">byte</span>)(arr_b[v] ^ <span class="number">0xFF</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr_b;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>继续往下查看发现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] readDexFileFromApk() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ZipInputStream</span> <span class="variable">zipInputStream0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipInputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="built_in">this</span>.getApplicationInfo().sourceDir)));</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">ZipEntry</span> <span class="variable">zipEntry0</span> <span class="operator">=</span> zipInputStream0.getNextEntry();</span><br><span class="line">            <span class="keyword">if</span>(zipEntry0 == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>百度后发现是加壳的方法，</p><p>继续往下发现最重要的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">splitPayloadFromDex</span><span class="params">(<span class="type">byte</span>[] arr_b)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">byte</span>[] arr_b1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">        System.arraycopy(arr_b, arr_b.length - <span class="number">4</span>, arr_b1, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(arr_b1)).readInt();</span><br><span class="line">        <span class="type">byte</span>[] arr_b2 = <span class="keyword">new</span> <span class="title class_">byte</span>[v];</span><br><span class="line">        System.arraycopy(arr_b, arr_b.length - <span class="number">4</span> - v, arr_b2, <span class="number">0</span>, v);</span><br><span class="line">        <span class="type">byte</span>[] arr_b3 = <span class="built_in">this</span>.decrypt(arr_b2);</span><br><span class="line">        <span class="type">File</span> <span class="variable">file0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="built_in">this</span>.apkFileName);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file0);</span><br><span class="line">        fileOutputStream0.write(arr_b3);</span><br><span class="line">        fileOutputStream0.close();</span><br><span class="line">        <span class="type">ZipInputStream</span> <span class="variable">zipInputStream0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipInputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file0)));</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">ZipEntry</span> <span class="variable">zipEntry0</span> <span class="operator">=</span> zipInputStream0.getNextEntry();</span><br><span class="line">            <span class="keyword">if</span>(zipEntry0 == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> zipEntry0.getName();</span><br><span class="line">            <span class="keyword">if</span>((s.startsWith(<span class="string">&quot;lib/&quot;</span>)) &amp;&amp; (s.endsWith(<span class="string">&quot;.so&quot;</span>))) &#123;</span><br><span class="line">                <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="built_in">this</span>.libPath + <span class="string">&quot;/&quot;</span> + s.substring(s.lastIndexOf(<span class="string">&quot;/&quot;</span>)));</span><br><span class="line">                file1.createNewFile();</span><br><span class="line">                <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file1);</span><br><span class="line">                <span class="type">byte</span>[] arr_b4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0x400</span>];</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">v1</span> <span class="operator">=</span> zipInputStream0.read(arr_b4);</span><br><span class="line">                    <span class="keyword">if</span>(v1 == -<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    fileOutputStream1.write(arr_b4, <span class="number">0</span>, v1);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                fileOutputStream1.flush();</span><br><span class="line">                fileOutputStream1.close();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            zipInputStream0.closeEntry();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        zipInputStream0.close();</span><br><span class="line">        zipInputStream0.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>百度函数名后发现类似题目：<code>[[原创\]安卓逆向之2016年华山杯CTF安卓writeUp-Android安全-看雪-安全社区|安全招聘|kanxue.com](https://bbs.kanxue.com/thread-218555.htm)</code></p><p><strong>通过以上分析，我们可以得到加壳了以后的apk的结构应该是：</strong>+——-+———–|——————+ + 壳子 | 原始apk | 原始apk的长度 | +——+———–+——————+</p><p>模仿java代码写出提取脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new_byte</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        src_len = file.read()</span><br><span class="line"></span><br><span class="line">    decrypt_len = struct.unpack(<span class="string">&#x27;&gt;I&#x27;</span>, src_len[-<span class="number">4</span>:])[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;长度是：&#123;:x&#125;&quot;</span>.<span class="built_in">format</span>(decrypt_len))</span><br><span class="line"></span><br><span class="line">    new_dex_byte = src_len[-<span class="number">4</span> - decrypt_len:-<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">    decrypted_data = <span class="built_in">bytes</span>([b ^ <span class="number">0xFF</span> <span class="keyword">for</span> b <span class="keyword">in</span> new_dex_byte])</span><br><span class="line"></span><br><span class="line">    output_path = <span class="string">r&quot;G:\Chanllages\xyctf\notrust\new_write_dex.apk&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(output_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(decrypted_data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decrypted_data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">        path = sys.argv[<span class="number">1</span>]</span><br><span class="line">        new_byte(path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;请提供Dex文件的路径！&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打开提取后的apk文件终于发现hint所说的简单漏洞是什么了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view0)</span> &#123;</span><br><span class="line">        <span class="type">TextView</span> <span class="variable">textView0</span> <span class="operator">=</span> (TextView)<span class="built_in">this</span>.findViewById(id.username);</span><br><span class="line">        <span class="type">TextView</span> <span class="variable">textView1</span> <span class="operator">=</span> (TextView)<span class="built_in">this</span>.findViewById(id.password);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> textView0.getText().toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> textView1.getText().toString();</span><br><span class="line">        <span class="type">SQLiteDatabase</span> <span class="variable">sQLiteDatabase0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DBHelper</span>(<span class="built_in">this</span>.getApplicationContext()).getReadableDatabase();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM User WHERE username = \&#x27;&quot;</span> + s + <span class="string">&quot;\&#x27; AND password = \&#x27;&quot;</span> + s1 + <span class="string">&quot;\&#x27;&quot;</span>;</span><br><span class="line">        Log.i(<span class="string">&quot;SQL语句&quot;</span>, s2);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Cursor</span> <span class="variable">cursor0</span> <span class="operator">=</span> sQLiteDatabase0.rawQuery(s2, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span>(cursor0 != <span class="literal">null</span> &amp;&amp; (cursor0.moveToFirst())) &#123;</span><br><span class="line">                Log.d(<span class="string">&quot;Login&quot;</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">                <span class="type">Cursor</span> <span class="variable">cursor1</span> <span class="operator">=</span> sQLiteDatabase0.rawQuery(<span class="string">&quot;SELECT password FROM User WHERE username = \&#x27;flag\&#x27;&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">if</span>(cursor1 != <span class="literal">null</span> &amp;&amp; (cursor1.moveToFirst())) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> cursor1.getString(cursor1.getColumnIndex(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">                    <span class="type">Builder</span> <span class="variable">alertDialog$Builder0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Builder</span>(<span class="built_in">this</span>);</span><br><span class="line">                    alertDialog$Builder0.setTitle(<span class="string">&quot;登录成功!&quot;</span>);</span><br><span class="line">                    alertDialog$Builder0.setMessage(<span class="string">&quot;flag: &quot;</span> + s3);</span><br><span class="line">                    alertDialog$Builder0.setPositiveButton(<span class="string">&quot;确定&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">                    alertDialog$Builder0.show();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cursor1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                    cursor1.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Log.d(<span class="string">&quot;Login&quot;</span>, <span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">                <span class="type">Builder</span> <span class="variable">alertDialog$Builder1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Builder</span>(<span class="built_in">this</span>);</span><br><span class="line">                alertDialog$Builder1.setTitle(<span class="string">&quot;Failed&quot;</span>);</span><br><span class="line">                alertDialog$Builder1.setMessage(<span class="string">&quot;登录失败，如果不知道用户名的话想想之前是否漏了什么提示没有解密&quot;</span>);</span><br><span class="line">                alertDialog$Builder1.setPositiveButton(<span class="string">&quot;收到&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">                alertDialog$Builder1.show();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(cursor0 != <span class="literal">null</span>) &#123;</span><br><span class="line">                cursor0.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception exception0) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Log.d(<span class="string">&quot;Login&quot;</span>, <span class="string">&quot;SQL查询错误: &quot;</span> + exception0.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(Throwable throwable0) &#123;</span><br><span class="line">                sQLiteDatabase0.close();</span><br><span class="line">                <span class="keyword">throw</span> throwable0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Throwable throwable0) &#123;</span><br><span class="line">            sQLiteDatabase0.close();</span><br><span class="line">            <span class="keyword">throw</span> throwable0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sQLiteDatabase0.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>简单的MySQL漏洞，在账户处输入<code>admin' or '1' = '1</code>即可构建万能密码</p><p>获得flag: <code>XYCTF&#123;And0r1d_15_V3ryEasy&#125;</code></p><h2 id="砸核桃">砸核桃</h2><p>放入die中发现是国产加密，百度到拖壳器后得到文件</p><p>题目很实诚，加密方法就在main里面</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">strlen</span>(Buffer) == <span class="number">42</span> )</span><br><span class="line"> &#123;</span><br><span class="line">   v4 = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> ( (Buffer[v4] ^ byte_402130[v4 % <span class="number">16</span>]) == dword_402150[v4] )</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> ( ++v4 &gt;= <span class="number">42</span> )</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;right!\n&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;error!\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;error!\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>显然flag长度是42，点击byte_402130和dword_402150即可得到解密所需要的数据（虽然后者内含大量无关的0x00）</p><p>写出解密脚本:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除所有0x00即可</span></span><br><span class="line">byte_402130 = <span class="string">&#x27;this_is_not_flag&#x27;</span></span><br><span class="line">dword_402150 = [ <span class="number">0x12</span>,<span class="number">0x4</span>,<span class="number">0x8</span>,<span class="number">0x14</span>,<span class="number">0x24</span>,<span class="number">0x5c</span>,<span class="number">0x4a</span>,<span class="number">0x3d</span>,<span class="number">0x56</span>,<span class="number">0xa</span>,<span class="number">0x10</span>,<span class="number">0x67</span>,<span class="number">0x00</span>,<span class="number">0x41</span>,<span class="number">0x00</span>,<span class="number">0x1</span>,<span class="number">0x46</span>,<span class="number">0x5a</span>,<span class="number">0x44</span>,<span class="number">0x42</span>,<span class="number">0x6e</span>,<span class="number">0xc</span>,<span class="number">0x44</span>,<span class="number">0x72</span>,<span class="number">0x0c</span>,<span class="number">0x0d</span>,<span class="number">0x40</span>,<span class="number">0x3E</span>,<span class="number">0x4B</span>, <span class="number">0x5F</span>, <span class="number">0x2</span>, <span class="number">0x1</span>, <span class="number">0x4C</span>, <span class="number">0x5E</span>, <span class="number">0x5B</span>, <span class="number">0x17</span>, <span class="number">0x6E</span>, <span class="number">0x0C</span> ,<span class="number">0x16</span>,<span class="number">0x68</span>,<span class="number">0x5b</span>,<span class="number">0x12</span>,<span class="number">0x02</span>,<span class="number">0x48</span>,<span class="number">0x0e</span>]</span><br><span class="line"></span><br><span class="line">x = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">42</span>):</span><br><span class="line">    x += <span class="built_in">chr</span>(dword_402150[i]^<span class="built_in">ord</span>(byte_402130[i%<span class="number">16</span>]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment">#flag: flag&#123;59b8ed8f-af22-11e7-bb4a-3cf862d1ee75&#125;</span></span><br></pre></td></tr></table></figure><h2 id="ez_enc">Ez_enc</h2><p>die查看无壳，扔进ida中，发现没有main函数，但是又start函数，进去走几步后无果。开始查找字符串，内含大量无用信息，但是发现最下方有奇怪的字符串<code>.data:000000014001E000   00000007    C   IMouto</code>百度后发现是妹控相关（二次元真下头）。查看交叉引用发现加密函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_int64 <span class="title">sub_140011960</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> i; <span class="comment">// [rsp+44h] [rbp+24h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+64h] [rbp+44h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">sub_14001137F</span>((__int64)&amp;unk_140023008);</span><br><span class="line">  <span class="built_in">sub_1400111A4</span>(&amp;unk_14001ACB0);</span><br><span class="line">  <span class="built_in">sub_1400111A4</span>(&amp;unk_14001AE60);</span><br><span class="line">  <span class="built_in">sub_1400111A4</span>(&amp;unk_14001AF20);</span><br><span class="line">  <span class="built_in">sub_1400111A4</span>(&amp;unk_14001B1A0);</span><br><span class="line">  <span class="built_in">sub_1400111A4</span>(&amp;unk_14001B290);</span><br><span class="line">  <span class="built_in">sub_1400111A4</span>(&amp;unk_14001B640);</span><br><span class="line">  <span class="built_in">sub_1400111A4</span>(&amp;unk_14001AE18);</span><br><span class="line">  <span class="built_in">sub_14001109B</span>(&amp;unk_14001BA14, Str);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)(<span class="built_in">j_strlen</span>(Str) - <span class="number">1</span>); ++i )</span><br><span class="line">    Str[i] = aImouto[i % <span class="number">6</span>] ^ (Str[i + <span class="number">1</span>] + (<span class="type">unsigned</span> __int8)Str[i] % <span class="number">20</span>);</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; (<span class="type">int</span>)<span class="built_in">j_strlen</span>(Str); ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( Str[j] != byte_14001E008[j] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">sub_1400111A4</span>(<span class="string">&quot;Wrong&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sub_1400111A4</span>(<span class="string">&quot;Right,but where is my Imouto?\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>前面几个函数估计是输出终端中的虾头发言，重点在于第一个循环。最后的比对内容点击即可获得，但是困难的是前面的加密。将34个字符处理33个，但是由于是取余运算导致结果多样且之后的解密高度依赖先前的解密。再询问群内佬后了解了DFS（深度优先算法，西湖论剑时遇见过但是没有认真学，那题到现在都还没有复现。。）,网上学习速成后得到脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">enc, key</span>):</span><br><span class="line">    N = <span class="built_in">len</span>(enc)</span><br><span class="line">    Str = [<span class="number">0</span>] * N  <span class="comment"># 初始化解密后的字符串数组</span></span><br><span class="line">    key = [<span class="built_in">ord</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> key]  <span class="comment"># 将key字符串转换为其ASCII值的列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 尝试解密从最后一个已知的Str[N-1]</span></span><br><span class="line">    Str[N-<span class="number">1</span>] = enc[N-<span class="number">1</span>]  <span class="comment"># 最后一个字符未被加密修改</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从后向前递归解密每个字符</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decrypt_character</span>(<span class="params">i</span>):</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 成功解密所有字符</span></span><br><span class="line">        <span class="keyword">for</span> possible_char <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>, <span class="number">127</span>):  <span class="comment"># 只考虑ASCII的可见字符</span></span><br><span class="line">            <span class="comment"># 检查这个字符是否能够适应加密方程</span></span><br><span class="line">            <span class="keyword">if</span> key[i % <span class="number">6</span>] ^ (Str[i + <span class="number">1</span>] + possible_char % <span class="number">20</span>) == enc[i]:</span><br><span class="line">                Str[i] = possible_char</span><br><span class="line">                <span class="keyword">if</span> decrypt_character(i - <span class="number">1</span>):  <span class="comment"># 递归密解前一个字符</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> decrypt_character(N-<span class="number">2</span>):  <span class="comment"># 从倒数第二个字符开始解密</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> Str)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Decryption failed&quot;</span></span><br><span class="line"></span><br><span class="line">enc = [<span class="number">0x27</span>, <span class="number">0x24</span>, <span class="number">0x17</span>, <span class="number">0x0B</span>, <span class="number">0x50</span>, <span class="number">0x03</span>, <span class="number">0xC8</span>, <span class="number">0x0C</span>, <span class="number">0x1F</span>, <span class="number">0x17</span>,</span><br><span class="line">       <span class="number">0x36</span>, <span class="number">0x55</span>, <span class="number">0xCB</span>, <span class="number">0x2D</span>, <span class="number">0xE9</span>, <span class="number">0x32</span>, <span class="number">0x0E</span>, <span class="number">0x11</span>, <span class="number">0x26</span>, <span class="number">0x02</span>,</span><br><span class="line">       <span class="number">0x0C</span>, <span class="number">0x07</span>, <span class="number">0xFC</span>, <span class="number">0x27</span>, <span class="number">0x3D</span>, <span class="number">0x2D</span>, <span class="number">0xED</span>, <span class="number">0x35</span>, <span class="number">0x59</span>, <span class="number">0xEB</span>,</span><br><span class="line">       <span class="number">0x3C</span>, <span class="number">0x3E</span>, <span class="number">0xE4</span>, <span class="number">0x7D</span>]</span><br><span class="line">key = <span class="string">&#x27;IMouto&#x27;</span></span><br><span class="line"></span><br><span class="line">decrypted_text = decrypt(enc, key)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Decrypted text:&quot;</span>, decrypted_text)</span><br><span class="line"><span class="comment">#output：*lag&#123;!_r3ea11y_w4nt_@_cu7e_s1$ter&#125;</span></span><br></pre></td></tr></table></figure><p>没有特别处理第一个字符，改成f后flag正确。</p><h2 id="熊博士">熊博士</h2><p>以为是凯撒密码但是解密后显然不对，基于对这种没头没脑的密码题的认识，百度关键词“熊博士”和解密发现埃特巴什码- Atbash Cipher。在线网站解密后得到flag:xyctf{liu_ye_mei_you_xiao_jj}(头要改成大写)</p><h2 id="zzl的护理小课堂">zzl的护理小课堂</h2><p>老老实实完成所有题目后遭遇雌小鬼，怒而按下F12发现真相。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;quizForm&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;submit&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           event.<span class="title function_">preventDefault</span>(); </span></span><br><span class="line"><span class="language-javascript">   </span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">var</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>(<span class="variable language_">this</span>);</span></span><br><span class="line"><span class="language-javascript">   </span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>(); </span></span><br><span class="line"><span class="language-javascript">           xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;getScore.php&#x27;</span>, <span class="literal">true</span>); </span></span><br><span class="line"><span class="language-javascript">           xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">               <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>) &#123; </span></span><br><span class="line"><span class="language-javascript">                   <span class="keyword">var</span> score = xhr.<span class="property">responseText</span>;</span></span><br><span class="line"><span class="language-javascript">                   <span class="keyword">if</span>(score != <span class="number">111111110</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                       <span class="keyword">var</span> flagXhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>(); </span></span><br><span class="line"><span class="language-javascript">                       flagXhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;flag.php&#x27;</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript">                       flagXhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                           <span class="keyword">if</span> (flagXhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; flagXhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                               <span class="keyword">var</span> flag = flagXhr.<span class="property">responseText</span>;</span></span><br><span class="line"><span class="language-javascript">                               <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;scoreDisplay&#x27;</span>).<span class="property">innerText</span> = <span class="string">&quot;Flag: &quot;</span> + flag;</span></span><br><span class="line"><span class="language-javascript">                           &#125;</span></span><br><span class="line"><span class="language-javascript">                       &#125;;</span></span><br><span class="line"><span class="language-javascript">                       flagXhr.<span class="title function_">send</span>(); <span class="comment">// 发送请求获取 flag</span></span></span><br><span class="line"><span class="language-javascript">                   &#125;</span></span><br><span class="line"><span class="language-javascript">               &#125;</span></span><br><span class="line"><span class="language-javascript">           &#125;;</span></span><br><span class="line"><span class="language-javascript">           xhr.<span class="title function_">send</span>(formData); <span class="comment">// 发送请求获取分数</span></span></span><br><span class="line"><span class="language-javascript">       &#125;);</span></span><br><span class="line"><span class="language-javascript">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>用修改条件后的网页替代后得到flag：XYCTF{Z2I_T3IL_YOU_2991b3d1fb37}</p><h2 id="签到">签到</h2><p>公众号关注并输入特定字符后得到flag ： XYCTF{WELCOME_TO_XYCTF}</p><h2 id="game">game</h2><p>在某个单机游戏贴吧里发帖得到回应，游戏是paper，please。按格式输入即可。</p><h2 id="真签到">真&lt;签到</h2><p>发现无法解压后010打开，发现flag：XYCTF{59bd0e77d13c_1406b23219e_f91cf3a_153e8ea4_77508ba}</p>]]></content:encoded>
      
      
      
      <category domain="http://midnightr3d.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</category>
      
      <category domain="http://midnightr3d.top/tags/CTF/">CTF</category>
      
      
      <comments>http://midnightr3d.top/2024/04/25/XYCTF%20WP/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>STL算法涉猎</title>
      <link>http://midnightr3d.top/2024/04/23/STL%E7%AE%97%E6%B3%95%E6%B6%89%E7%8C%8E/</link>
      <guid>http://midnightr3d.top/2024/04/23/STL%E7%AE%97%E6%B3%95%E6%B6%89%E7%8C%8E/</guid>
      <pubDate>Tue, 23 Apr 2024 15:28:45 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;引子&quot;&gt;引子&lt;/h2&gt;
&lt;p&gt;考虑以下问题：假设我们想要编写一个程序，该程序从文件中读取整数列表（可能表示作业中的成绩），然后打印出这些值的平均值。为简单起见，我们假设此数据存储在名为
data.txt 的文件中，每行一个整数。例如：&lt;/p&gt;
&lt;figure class=&quot;highlight html&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;95&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;92&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;98&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;100&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;83&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;87&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;97&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;99&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;89&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;88&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以下是一个可能的例子：</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="引子">引子</h2><p>考虑以下问题：假设我们想要编写一个程序，该程序从文件中读取整数列表（可能表示作业中的成绩），然后打印出这些值的平均值。为简单起见，我们假设此数据存储在名为data.txt 的文件中，每行一个整数。例如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">95</span><br><span class="line">92</span><br><span class="line">98</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">100</span><br><span class="line">87</span><br><span class="line">89</span><br><span class="line">87</span><br><span class="line">89</span><br><span class="line">83</span><br><span class="line">87</span><br><span class="line">97</span><br><span class="line">99</span><br><span class="line">89</span><br><span class="line">88</span><br></pre></td></tr></table></figure><p>以下是一个可能的例子： <span id="more"></span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">input</span><span class="params">(<span class="string">&quot;G:\\Cpp_Learn\\full_course_reader\\week5\\data.txt&quot;</span>)</span></span>;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; values;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> currVaule;</span><br><span class="line">    <span class="keyword">while</span>(input &gt;&gt; currVaule)&#123;</span><br><span class="line">        values.<span class="built_in">insert</span>(currVaule);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//习惯性的写法</span></span><br><span class="line">    <span class="type">float</span> total = <span class="number">0.000</span>; </span><br><span class="line">    <span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator itr = values.<span class="built_in">begin</span>(); itr != values.<span class="built_in">end</span>(); ++itr)&#123;</span><br><span class="line">        total += *itr;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;average is : &quot;</span> &lt;&lt; total/values.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要用语言描绘这个程序，我们可以把他分为三步：</p><ol type="1"><li>读取文件内容</li><li>将值相加</li><li>除以元素个数</li></ol><p>我们必须以这种机械的方式向计算机发出命令的原因正是因为计算机是机械的——它是一台高效计算功能的机器。编程的挑战是找到一种方法，将一组高级命令转换为一系列控制机器的低级指令。这通常是一件苦差事，因为计算机导出的基本操作相当有限。但编程并不一定这么难。正如你所看到的，我们可以根据旧函数来定义新函数，并且可以从这些越来越强大的子程序中构建复杂的程序。从理论上讲，你可以编译一个巨大的库，其中包含所有非平凡的编程问题的解决方案。有了这个库，你就可以轻松地编写程序，只需将这些预先编写好的组件拼接在一起。</p><p>不幸的是，没有一个库可以解决每个编程问题。然而，这并没有阻止STL的设计者尽最大努力建造一个。这些是STL 算法，一个用于处理数据的非常强大的例程库。STL算法不能做所有事情，但它们能做的事情却做得非常出色。实际上，使用 STL算法，可以重写在四行代码中平均数字的程序。</p><h2 id="第一个stl算法accumulate">第一个STL算法：Accumulate</h2><p>关于先前求和的部分，可以用以下的方法替代：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;numeric&gt;</span></span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;average is : &quot;</span> &lt;&lt; <span class="built_in">accumulate</span>(values.<span class="built_in">begin</span>(),values.<span class="built_in">end</span>(),<span class="number">0.0</span>)/values.<span class="built_in">size</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>在标头中定义的 accumulate 函数<numeric>采用三个参数 –两个定义元素范围的迭代器，以及用于求和的初始值。然后，它计算迭代器范围内包含的所有元素的总和，加上基本值。accumulate（以及一般的 STL 算法）的美妙之处在于，accumulate可以接受任何类型的迭代器。也就是说，我们可以从多集、向量或 deque中求和迭代器。这意味着，如果您发现自己需要计算容器中包含的元素的总和，则可以将该容器的begin（） 和 end（） 迭代器传递到 accumulate中以获得总和。此外，accumulate可以接受任何有效的迭代器范围，而不仅仅是跨整个容器的迭代器范围。例如，如果我们想计算多集的元素之和，这些元素介于42 和 137 之间（含 42 和 137），我们可以写成:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">accumulate</span>(values.<span class="built_in">lower_bound</span>(<span class="number">42</span>), values.<span class="built_in">upper_bound</span>(<span class="number">137</span>), <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>在幕后，accumulate被实现为一个模板函数，它接受两个迭代器，并简单地使用循环将值相加。这是accumulate 的一种可能实现:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> Type&gt; <span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function">   Type <span class="title">accumulate</span><span class="params">(InputIterator start, InputIterator stop, Type initial)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(start != stop) &#123;</span><br><span class="line">           initial += *start;</span><br><span class="line">           ++start;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> initial;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>代码的核心是一个标准的迭代器循环，它不断向前推进启动迭代器，直到它到达目的地。累加没有什么神奇之处，函数调用是一行代码这一事实并没有改变它仍然使用循环将所有值相加的事实。</p><p>如果 STL算法只是在幕后使用循环的函数，为什么我们还要费心学习呢？有几个原因，第一个原因是简单。借助STL算法，您可以利用已经为您编写的代码，而不是从头开始重新编写代码。这可以节省大量时间，也导致了第二个原因，即正确性。如果你每次需要使用它们时都必须从头开始重写所有算法，那么在某个时候你很可能会犯错误。例如，您可能会编写一个排序例程，该例程在您打算&gt;时意外地使用了&lt;，因此根本不起作用。STL算法则不然——它们已经过全面测试，可以正常工作于任何给定的输入。使用算法的第三个原因是速度。一般来说，你可以假设，如果有一个STL算法来执行一项任务，它将比你手动编写的大多数代码更快。通过模板专用化和模板元编程等先进技术，STL算法经过透明优化，以尽可能快地工作。最后，STL算法提供了清晰度。使用算法，您可以立即判断出对累积的调用将某个范围内的数字相加。但使用求和值的for 循环，您必须先阅读循环中的每一行，然后才能理解代码的作用。</p><h2 id="算法命名的约定">算法命名的约定</h2><p>有超过 50 种 STL 算法（定义在 中<algorithm><numeric>或中），至少可以说，记住它们将是一件苦差事。幸运的是，它们中的许多都有通用的命名约定，因此即使我们以前从未遇到过它们，也可以轻松识别。</p><h3 id="后缀-_if">后缀 ' _if '</h3><p>以 <code>_if</code>结尾的算法基于条件执行操作。这些函数需要一个谓词——一个接受元素作为输入并返回布尔值的函数，该布尔值指示元素是否满足特定标准。示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEven</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myVec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">137</span>, <span class="number">137</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;偶数元素数量: &quot;</span> </span><br><span class="line">              &lt;&lt; <span class="built_in">count_if</span>(myVec.<span class="built_in">begin</span>(), myVec.<span class="built_in">end</span>(), IsEven) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="关键字-copy">关键字 ' copy '</h3><p>名称中包含 <code>copy</code>的算法执行操作并将结果存储在由另一个迭代器指定的新位置。当想保留原始数据的同时处理转换后的数据时，这非常有用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; src = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; dest;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为新元素腾出空间</span></span><br><span class="line">    dest.<span class="built_in">resize</span>(src.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">remove_copy_if</span>(src.<span class="built_in">begin</span>(), src.<span class="built_in">end</span>(), dest.<span class="built_in">begin</span>(), [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : dest) &#123;</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="后缀-_n">后缀 '_n '</h3><p>算法名称中的 <code>_n</code>后缀表明操作将执行指定次数，而不是在一个范围内执行。当确切的操作次数比数据范围更重要时，这特别有用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::deque&lt;<span class="type">int</span>&gt; <span class="title">myDeque</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fill_n</span>(myDeque.<span class="built_in">begin</span>(), <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : myDeque) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里的<code>fill_n</code> 将 <code>myDeque</code>的前十个元素设置为零。</p><h2 id="解析-stl-迭代器的分类">解析 STL 迭代器的分类</h2><p>在 C++标准模板库（STL）中，迭代器是访问和操作容器中元素的关键工具。由于不同容器的内部结构差异，迭代器的功能也有所不同，因此STL迭代器被分为几种不同的类型，每种迭代器具有不同的能力和限制。了解这些迭代器的分类对于有效使用STL 是非常重要的。</p><h3 id="迭代器的分类及功能">迭代器的分类及功能</h3><p>迭代器按照功能强弱分为五种类型，从功能最弱到功能最强依次是：</p><ol type="1"><li><strong>输出迭代器（Output Iterators）</strong><ul><li>输出迭代器允许写入值（使用 <code>*myItr = value</code> 语法）。</li><li>可以向前移动（使用 <code>++</code> 操作符）。</li><li>不能读取值或使用 <code>+=</code> 或 <code>-</code> 操作符。</li></ul></li><li><strong>输入迭代器（Input Iterators）</strong><ul><li>输入迭代器允许读取值（使用 <code>value = *myItr</code> 语法）。</li><li>不能写入值或遍历同一范围两次。</li></ul></li><li><strong>前向迭代器（Forward Iterators）</strong><ul><li>结合了输入和输出迭代器的功能，支持读写操作。</li><li>只能向前移动（使用 <code>++</code> 操作符）。</li></ul></li><li><strong>双向迭代器（Bidirectional Iterators）</strong><ul><li>拥有前向迭代器的所有功能。</li><li>可以向后移动（使用 <code>--</code> 操作符）。</li><li>通常用于像 <code>map</code> 和 <code>set</code> 这样的容器。</li></ul></li><li><strong>随机访问迭代器（Random-Access Iterators）</strong><ul><li>提供最大的功能，支持任意前后移动。</li><li>支持迭代器加减、使用方括号语法和 <code>+</code>、<code>+=</code>操作。</li><li>主要用于 <code>vector</code> 和 <code>deque</code>。</li></ul></li></ol><h3 id="为什么要区分迭代器类型">为什么要区分迭代器类型？</h3><p>由于容器的内部数据结构不同，迭代器的实现和性能也会有很大差异。例如，<code>vector</code>和 <code>deque</code>支持随机访问迭代器，因为它们的元素是连续存储的，可以通过简单的地址计算快速访问任何元素。相反，<code>set</code>和 <code>map</code>通常使用树结构存储元素，所以它们的迭代器只能一步一步地前进或后退，这种操作的复杂度是线性的。</p><p>在实际编程中，了解并使用正确类型的迭代器非常关键，因为它关系到代码的性能和效率。当一个库函数需要特定类型的迭代器时，提供一个功能相当或更强大的迭代器是可行的。例如，如果一个函数需要一个前向迭代器，那么提供一个前向迭代器、双向迭代器或随机访问迭代器都是可以的。</p><p>通过掌握这些迭代器的分类和功能，可以更加灵活和高效地使用STL，从而编写出更优雅和高效的 C++ 代码。</p><figure><imgsrc="G:\Cpp_Learn\full_course_reader\notes\assets\image-20240423225530689.png"alt="image-20240423225530689" /><figcaption aria-hidden="true">image-20240423225530689</figcaption></figure><h2 id="探索-stl-重排序算法">探索 STL 重排序算法</h2><p>在 C++的标准模板库（STL）中，有一系列用于重排序容器中元素的算法。这些算法能够在不改变元素内容的前提下，改变元素的排列顺序。以下是三种主要的重排序算法：<code>sort</code>、<code>random_shuffle</code>和 <code>rotate</code>，它们各自的用途和功能都非常实用。</p><h3 id="排序算法sort">排序算法（<code>sort</code>）</h3><p><code>sort</code>算法是用于将容器中的元素按照升序排序。此算法要求传入的迭代器为随机访问迭代器，因此它不能用于<code>map</code> 或 <code>set</code>类型的容器，不过这些容器本身就是有序的。</p><p><strong>基本用法：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(myVector.<span class="built_in">begin</span>(), myVector.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></p><p>此外，<code>sort</code>还允许指定一个自定义的比较函数，以实现不同的排序准则。</p><p><strong>自定义比较函数示例：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">placeT</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ComparePlaces</span><span class="params">(placeT one, placeT two)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (one.x != two.x) <span class="keyword">return</span> one.x &lt; two.x;</span><br><span class="line">    <span class="keyword">return</span> one.y &lt; two.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;placeT&gt; myPlaceVector = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(myPlaceVector.<span class="built_in">begin</span>(), myPlaceVector.<span class="built_in">end</span>(), ComparePlaces);</span><br></pre></td></tr></table></figure></p><h3id="随机打乱算法random_shuffle">随机打乱算法（<code>random_shuffle</code>）</h3><p><code>random_shuffle</code> 算法用于随机打乱容器中的元素。类似于<code>sort</code>，这个算法也需要随机访问迭代器。</p><p><strong>示例用法：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">std::<span class="built_in">random_shuffle</span>(myVector.<span class="built_in">begin</span>(), myVector.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure></p><p>在使用 <code>random_shuffle</code> 之前，建议使用 <code>srand</code>函数来设定随机数生成器的种子，以确保每次程序运行结果的随机性。</p><h3 id="旋转算法rotate">旋转算法（<code>rotate</code>）</h3><p><code>rotate</code>算法通过循环移动容器中的元素，使得指定位置的元素变为容器的开始。</p><p><strong>示例用法：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">std::<span class="built_in">rotate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">begin</span>() + <span class="number">2</span>, v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure> 在此示例中，向量<code>v</code> 中的元素会被旋转，结果为<code>&#123;2, 3, 4, 5, 0, 1&#125;</code>。</p><p>这些重排序算法在日常编程中非常有用，它们可以帮助开发者有效地处理和变换数据。了解和运用这些算法，可以极大地提高编程效率和代码的可读性。</p><h2 id="探索-stl-中的搜索算法">探索 STL 中的搜索算法</h2><p>在数据处理过程中，常常需要在容器中查找特定的元素。例如，你可能想知道一个向量是否包含一个特定的元素。尽管<code>map</code> 和 <code>set</code>容器提供了内置的查找功能，<code>vector</code> 和 <code>deque</code>等线性容器则缺少这样的功能。好在，STL提供了多种算法来补充这一功能缺失。</p><h3 id="find-算法"><code>find</code> 算法</h3><p><code>find</code>函数是最基本的搜索算法，它接受两个迭代器（定义搜索范围）和一个值，返回第一个匹配该值的元素的迭代器。如果范围内没有匹配的元素，<code>find</code>返回第二个迭代器作为哨兵值。</p><p><strong>示例用法：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">137</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">find</span>(myVector.<span class="built_in">begin</span>(), myVector.<span class="built_in">end</span>(), <span class="number">137</span>) != myVector.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// 向量包含元素 137</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>虽然你可以在 <code>map</code> 和 <code>set</code> 上使用<code>find</code>，但通常不推荐这样做。因为 <code>map</code> 和<code>set</code> 的成员函数 <code>find</code>使用了容器内部数据结构的信息来加快搜索速度，而 STL 的 <code>find</code>函数则必须线性地遍历元素，效率较低。</p><h3 id="binary_search-算法"><code>binary_search</code> 算法</h3><p>如果你有一个已排序的线性容器（如排序后的<code>vector</code>），可以使用 <code>binary_search</code>来执行搜索，这比线性搜索快得多。<code>binary_search</code>仅返回一个布尔值，表示是否找到了指定的元素。</p><p><strong>示例用法：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">137</span>&#125;;  <span class="comment">// 假设已排序</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">binary_search</span>(myVector.<span class="built_in">begin</span>(), myVector.<span class="built_in">end</span>(), <span class="number">137</span>)) &#123;</span><br><span class="line">    <span class="comment">// 找到了元素 137</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果容器使用了特殊的比较函数进行排序，你也可以将这个比较函数传递给<code>binary_search</code>。但要确保使用一致的比较函数，否则可能导致<code>binary_search</code> 工作不正常。</p><h3 id="lower_bound-算法"><code>lower_bound</code> 算法</h3><p>如果你需要在排序的容器中找到一个元素并获取指向该元素的迭代器，可以使用<code>lower_bound</code>。这个算法返回指向第一个不小于指定值的元素的迭代器。如果没有找到精确匹配的元素，<code>lower_bound</code>可能返回指向一个更大元素的迭代器，因此在使用返回的迭代器前需要进行检查。</p><p><strong>示例用法：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">137</span>&#125;;  <span class="comment">// 假设已排序</span></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(myVector.<span class="built_in">begin</span>(), myVector.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span> (it != myVector.<span class="built_in">end</span>() &amp;&amp; *it == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="comment">// 找到元素 4</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 元素 4 不在向量中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这些搜索算法是处理 STL容器中数据的强大工具。合理使用这些算法不仅可以提高代码的效率，还能使代码更加清晰和易于维护。</p><h2 id="迭代器适配器">迭代器适配器</h2><p>在使用 C++标准模板库（STL）的过程中，当我们想要通过算法生成数据范围时，确保目标位置有足够的空间来存放结果是非常重要的。例如，<code>copy</code>算法需要目标容器预先分配足够的空间以防写入数据时超出范围导致未定义行为。为了解决这个问题，STL提供了一类特殊的工具，称为迭代器适配器，这些适配器扩展了迭代器的功能，使其更加灵活和强大。</p><h3 id="ostream_iterator-输出流迭代器"><code>ostream_iterator</code> ——输出流迭代器</h3><p><code>ostream_iterator</code>是一种输出流迭代器，它不指向任何实际的容器元素，而是将数据输出到指定的流，如<code>cout</code> 或文件流。</p><p><strong>示例用法：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">myItr</span><span class="params">(std::cout, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line">    *myItr = <span class="number">137</span>; <span class="comment">// 输出 137 到 cout</span></span><br><span class="line">    ++myItr;</span><br><span class="line">    *myItr = <span class="number">42</span>;  <span class="comment">// 输出 42 到 cout</span></span><br><span class="line">    ++myItr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 这段代码通过<code>ostream_iterator</code> 将整数直接写入到标准输出流<code>cout</code>，数字之间由空格分隔。</p><h3 id="使用-ostream_iterator-结合-stl-算法">使用<code>ostream_iterator</code> 结合 STL 算法</h3><p>由于 <code>ostream_iterator</code> 本身是一个迭代器，我们可以将其与STL算法结合使用，从而实现复杂的输出任务。例如，我们可以将一个容器中的所有元素复制到输出流中。</p><p><strong>示例用法：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::<span class="built_in">copy</span>(myVector.<span class="built_in">begin</span>(), myVector.<span class="built_in">end</span>(), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 此代码将<code>myVector</code> 中的所有元素复制到<code>cout</code>，元素之间以空格分隔，一行代码实现了整个向量的输出。</p><h3id="back_insert_iterator-后插迭代器"><code>back_insert_iterator</code>—— 后插迭代器</h3><p>另一个有用的迭代器适配器是<code>back_insert_iterator</code>，这种迭代器在写入数据时会自动调用<code>push_back</code> 方法将数据追加到容器的末尾。</p><p><strong>示例用法：</strong> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myVector;</span><br><span class="line">    std::back_insert_iterator&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">itr</span>(myVector);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        *itr = i; <span class="comment">// 追加值到 myVector</span></span><br><span class="line">        ++itr;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">copy</span>(myVector.<span class="built_in">begin</span>(), myVector.<span class="built_in">end</span>(), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>在这个例子中，<code>back_insert_iterator</code> 被用来动态地向<code>myVector</code> 添加元素，之后通过 <code>copy</code> 和<code>ostream_iterator</code> 输出所有元素。</p><h3 id="insert_iterator-的应用"><code>insert_iterator</code> 的应用</h3><p><code>insert_iterator</code>是一种更通用的迭代器适配器，它可以在容器的任意位置插入元素。这种迭代器在处理需要元素插入的算法，如集合操作算法<code>set_union</code>, <code>set_intersection</code>,<code>set_difference</code> 等时尤为有用。</p><p><strong>示例用法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;int&gt; setOne = &#123;1, 2, 3&#125;;</span><br><span class="line">std::set&lt;int&gt; setTwo = &#123;2, 3, 4&#125;;</span><br><span class="line">std::set&lt;int&gt; result;</span><br><span class="line">std::set_union(setOne.begin(), setOne.end(), setTwo.begin(), setTwo.end(), std::inserter(result, result.begin()));</span><br></pre></td></tr></table></figure><p>这段代码计算了 <code>setOne</code> 和 <code>setTwo</code>的并集，并使用 <code>insert_iterator</code> 将结果存入<code>result</code>。</p><h3 id="istream_iterator-输入流迭代器"><code>istream_iterator</code> ——输入流迭代器</h3><p><code>istream_iterator</code>是另一种迭代器适配器，它允许从输入流（如文件或标准输入）读取数据。这使得<code>istream_iterator</code> 成为处理输入数据流的理想工具。</p><p><strong>示例用法：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::istream_iterator&lt;int&gt; it(std::cin);</span><br><span class="line">std::istream_iterator&lt;int&gt; end;</span><br><span class="line">std::vector&lt;int&gt; values(it, end); // 从标准输入读取整数直到 EOF</span><br></pre></td></tr></table></figure><p>在这个例子中，从标准输入读取的整数被存储到 <code>values</code>向量中，直到输入结束。</p><h2 id="常见的迭代器及其应用">常见的迭代器及其应用</h2><p>在 C++标准模板库（STL）中，迭代器适配器扩展了基本迭代器的功能，使它们能够在特定的上下文中更加有效地工作。下面是一些常见迭代器适配器的详细介绍，这些适配器广泛应用于处理容器和流中的数据。</p><h2 id="常见的迭代器适配器及其应用">常见的迭代器适配器及其应用</h2><p>在 C++标准模板库（STL）中，迭代器适配器扩展了基本迭代器的功能，使它们能够在特定的上下文中更加有效地工作。下面是一些常见迭代器适配器的详细介绍，这些适配器广泛应用于处理容器和流中的数据。</p><h3 id="输出迭代器">输出迭代器</h3><h4 id="back_insert_iterator"><code>back_insert_iterator</code></h4><ul><li><p><strong>定义</strong>:<code>back_insert_iterator&lt;Container&gt;</code></p></li><li><p><strong>构造方法</strong>:<code>back_insert_iterator&lt;vector&lt;int&gt;&gt; itr(myVector);</code></p></li><li><p><strong>功能</strong>: 通过调用容器的 <code>push_back</code>方法来存储元素。</p></li><li><p><strong>用法</strong>: 可以显式声明或使用<code>back_inserter</code> 函数快速创建。</p></li><li><p>示例:</p><p>使用 <code>back_insert_iterator</code> 将元素添加到<code>vector</code> 的末尾。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    std::<span class="built_in">copy</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(result));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : result) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="front_insert_iterator"><code>front_insert_iterator</code></h4><ul><li><p><strong>定义</strong>:<code>front_insert_iterator&lt;Container&gt;</code></p></li><li><p><strong>构造方法</strong>:<code>front_insert_iterator&lt;deque&lt;int&gt;&gt; itr(myIntDeque);</code></p></li><li><p><strong>功能</strong>: 通过调用容器的 <code>push_front</code>方法来存储元素。</p></li><li><p><strong>限制</strong>: 不能用于不支持 <code>push_front</code>方法的容器，如 <code>vector</code>。</p></li><li><p><strong>用法</strong>: 可以使用 <code>front_inserter</code>函数创建。</p></li><li><p>示例:</p><p>使用 <code>front_insert_iterator</code> 将元素添加到<code>deque</code> 的前端。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">    std::front_insert_iterator&lt;std::deque&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">inserter</span>(data);</span><br><span class="line">    *inserter = <span class="number">1</span>;</span><br><span class="line">    *inserter = <span class="number">2</span>;</span><br><span class="line">    *inserter = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : data) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// Output: 3 2 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="insert_iterator"><code>insert_iterator</code></h4><ul><li><strong>定义</strong>:<code>insert_iterator&lt;Container&gt;</code></li><li><strong>构造方法</strong>:<code>insert_iterator&lt;set&lt;int&gt;&gt; itr(mySet, mySet.begin());</code></li><li><strong>功能</strong>: 在指定位置调用容器的 <code>insert</code>方法来插入元素。</li><li><strong>适用范围</strong>: 可用于任何容器，尤其适合于<code>set</code>。</li><li><strong>用法</strong>: 可以通过 <code>inserter</code>函数生成。</li><li>示例:</li></ul><p>​ 使用 <code>insert_iterator</code> 在 <code>set</code>中插入元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line">    std::insert_iterator&lt;std::set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">inserter</span>(numbers, numbers.<span class="built_in">begin</span>());</span><br><span class="line">    *inserter = <span class="number">3</span>;</span><br><span class="line">    *inserter = <span class="number">1</span>;</span><br><span class="line">    *inserter = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// Output: 1 2 3 (automatically sorted)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="流迭代器">流迭代器</h3><h4 id="ostream_iterator"><code>ostream_iterator</code></h4><ul><li><strong>定义</strong>:<code>ostream_iterator&lt;Type&gt;</code></li><li><strong>构造方法</strong>:<code>ostream_iterator&lt;int&gt; itr(cout, " ");</code></li><li><strong>功能</strong>:将元素写入输出流中，可选地在每个元素后添加分隔符。</li><li><strong>用法</strong>: 初始化时必须指定输出流和可选的分隔符。</li><li>示例:</li></ul><p>​ 使用 <code>ostream_iterator</code> 输出元素到标准输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="function">std::ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">output</span><span class="params">(std::cout, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), output);  <span class="comment">// Output: 1 2 3</span></span><br></pre></td></tr></table></figure><h4 id="istream_iterator"><code>istream_iterator</code></h4><ul><li><strong>定义</strong>:<code>istream_iterator&lt;Type&gt;</code></li><li><strong>构造方法</strong>:<code>istream_iterator&lt;int&gt; itr(cin);</code></li><li><strong>功能</strong>: 从指定的输入流中读取值。</li><li><strong>特性</strong>:当到达流的末尾时，会取得一个特殊的“结束”值。</li><li><strong>注意事项</strong>: 易受输入流状态影响，使用时需注意。</li><li>示例:</li></ul><p>​ 使用 <code>istream_iterator</code> 从标准输入读取整数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter numbers separated by spaces: &quot;</span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(std::<span class="built_in">istream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cin), std::<span class="built_in">istream_iterator</span>&lt;<span class="type">int</span>&gt;(), std::<span class="built_in">back_inserter</span>(numbers));</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ostreambuf_iterator"><code>ostreambuf_iterator</code></h4><ul><li><strong>定义</strong>:<code>ostreambuf_iterator&lt;char&gt;</code></li><li><strong>构造方法</strong>:<code>ostreambuf_iterator&lt;char&gt; itr(cout);</code></li><li><strong>功能</strong>: 将原始字符数据写入输出流。</li><li><strong>限制</strong>: 仅能写入字符数据。</li><li>示例:</li></ul><p>​ 使用 <code>ostreambuf_iterator</code> 输出字符到标准输出。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ostreambuf_iterator&lt;<span class="type">char</span>&gt; <span class="title">output</span><span class="params">(std::cout)</span></span>;</span><br><span class="line">    *output = <span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">    *output = <span class="string">&#x27;i&#x27;</span>;</span><br><span class="line">    *output = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="istreambuf_iterator"><code>istreambuf_iterator</code></h4><ul><li><p><strong>定义</strong>:<code>istreambuf_iterator&lt;char&gt;</code></p></li><li><p><strong>构造方法</strong>:<code>istreambuf_iterator&lt;char&gt; itr(cin);</code></p></li><li><p><strong>功能</strong>: 从输入流中读取未格式化的数据。</p></li><li><p><strong>特性</strong>: 始终读取字符数据，不跳过空白。</p></li><li><p><strong>用途</strong>:常用于从文件中读取原始数据进行处理。</p></li><li><p>示例:</p><p>使用 <code>istreambuf_iterator</code>从标准输入读取原始字符数据。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter text, followed by EOF: &quot;</span>;</span><br><span class="line">    <span class="function">std::istreambuf_iterator&lt;<span class="type">char</span>&gt; <span class="title">start</span><span class="params">(std::cin)</span>, end</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">characters</span><span class="params">(start, end)</span></span>;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(characters.<span class="built_in">begin</span>(), characters.<span class="built_in">end</span>(), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">char</span>&gt;(std::cout, <span class="string">&quot;&quot;</span>));</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content:encoded>
      
      
      
      <category domain="http://midnightr3d.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</category>
      
      <category domain="http://midnightr3d.top/tags/C/">C++</category>
      
      <category domain="http://midnightr3d.top/tags/C%E8%AF%AD%E8%A8%80/">C语言</category>
      
      
      <comments>http://midnightr3d.top/2024/04/23/STL%E7%AE%97%E6%B3%95%E6%B6%89%E7%8C%8E/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>bashshell基础命令</title>
      <link>http://midnightr3d.top/2024/04/17/bashshell%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</link>
      <guid>http://midnightr3d.top/2024/04/17/bashshell%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/</guid>
      <pubDate>Wed, 17 Apr 2024 15:10:12 GMT</pubDate>
      
      <description>&lt;h1 id=&quot;section&quot;&gt;&lt;/h1&gt;
&lt;h2 id=&quot;启动终端&quot;&gt;启动终端&lt;/h2&gt;
&lt;p&gt;启动终端后会看见 &lt;strong&gt;shell CLI&lt;/strong&gt;
提示符，在此输入shell命令。默认的提示符符号是 $</description>
      
      
      
      <content:encoded><![CDATA[<h1 id="section"></h1><h2 id="启动终端">启动终端</h2><p>启动终端后会看见 <strong>shell CLI</strong>提示符，在此输入shell命令。默认的提示符符号是 $ <span id="more"></span></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/etc]</span><br><span class="line">└─$ </span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="与bash手册交互">与bash手册交互</h2><p>大多数Linux发行版自带在线手册。使用man命令可以访问Linux系统的手册页。输入<code>man 想要查看的命令</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       <span class="built_in">cat</span> - concatenate files and <span class="built_in">print</span> on the standard output</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="built_in">cat</span> [OPTION]... [FILE]...</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       Concatenate FILE(s) to standard output.</span><br><span class="line"></span><br><span class="line">       With no FILE, or when FILE is -, <span class="built_in">read</span> standard input.</span><br><span class="line"></span><br><span class="line">       -A, --show-all</span><br><span class="line">              equivalent to -vET</span><br><span class="line"></span><br><span class="line">       -b, --number-nonblank</span><br><span class="line">              number nonempty output lines, overrides -n</span><br><span class="line"></span><br><span class="line">       -e     equivalent to -vE</span><br><span class="line"></span><br><span class="line">       -E, --show-ends</span><br><span class="line">              display $ at end of each line</span><br><span class="line"></span><br><span class="line">       -n, --number</span><br><span class="line">              number all output lines</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>以上是 <code>cat</code>的部分用法。输入<code>man cat</code>即可查看</p><p>其中 <strong>DESCRIPTION</strong>部分提供了快速参考。从中可以迅速了解命令的作用以及用法。</p><p>mannal里通过空格翻页，enter逐行查看，以及上下箭头进行滑动。按q退出。</p><p>如果忘记命令了，可以通过<code>man -k terminal</code>进行关键词查找。</p><h2 id="浏览文件系统">浏览文件系统</h2><h3 id="linux中的目录">Linux中的目录</h3><p>Linux采用名为“虚拟目录”的单个目录结构中。虚拟目录会将计算机中所有储存设备的文件路径都纳入单个目录结构。Linux的虚拟目录结构只包含一个叫做root的目录的基础目录。所有文件都在root目录下一一列出。Linux中安装的第一块硬盘为根驱动器，所有目录都是从那里开始构建的。以下是kali的根目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿kali)-[/]</span><br><span class="line">└─<span class="comment"># ls</span></span><br><span class="line">bin   home            lib32       mnt   run       sys  vmlinuz</span><br><span class="line">boot  initrd.img      lib64       opt   sbin      tmp  vmlinuz.old</span><br><span class="line">dev   initrd.img.old  lost+found  proc  srv       usr</span><br><span class="line">etc   lib             media       root  swapfile  var</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里使用了ls命令来查看文件夹中的内容。常见的Linux目录名均基于文件系统层级标准（filesytemhierarchy standard, FHS）。</p><p>在Linux中，可以通过cd命令来切换目录。语法为<code>cd destination</code>。使用<code>cd ..</code>可以快速回到父目录。</p><p>使用 <code>pwd</code>命令可以了解当前工作目录。</p><p><code>ls</code>命令最基本的形式会显示当前目录下的文件和目录。使用<code>ls -F</code>(注意，Linux系统严格区分大小写，-f和-F是两个不同的命令)可以区分文件和目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿kali)-[/]</span><br><span class="line">└─<span class="comment"># ls -F</span></span><br><span class="line">bin@   home/            lib32@       mnt/   run/      sys/  vmlinuz@</span><br><span class="line">boot/  initrd.img@      lib64@       opt/   sbin@     tmp/  vmlinuz.old@</span><br><span class="line">dev/   initrd.img.old@  lost+found/  proc/  srv/      usr/</span><br><span class="line">etc/   lib@             media/       root/  swapfile  var/</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>-a选项能显示隐藏文件（通常是文件名以 . 开始的文件）</p><p>-R选项称作递归选项，能列出当前目录包含的子目录的文件与目录。</p><p>-l命令会产生长列表格式的输出，提供目录中各个文件的详细信息。在-l后跟上文件名即可只查看该文件的信息。</p><h3 id="过滤输出列表">过滤输出列表</h3><p>ls命令支持在命令行中定义过滤器，使用过滤器来决定该在命令行中显示哪些文件或者目录。</p><p>在ls最后添加文件名是最基本的过滤方式，我们可以通过使用标准通配符来进行模式匹配。</p><ul><li>问号 （ ? ）代表任意单个字符</li><li>星号 （ * ）代表零个或者多个任意字符</li></ul><p>以 <code>/home/kali/</code>目录为例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ <span class="built_in">ls</span> -F                </span><br><span class="line">backup/   Documents/  fill    Pictures/  tast.py  teeeeeeeesy.txt  test.py</span><br><span class="line">Desktop/  Downloads/  Music/  Public/    te3t.py  Templates/       Videos/</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ <span class="built_in">ls</span> t[a-z]st*</span><br><span class="line">tast.py  test.py</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ <span class="built_in">ls</span> t*       </span><br><span class="line">tast.py  te3t.py  teeeeeeeesy.txt  test.py</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ <span class="built_in">ls</span> t?st.py</span><br><span class="line">tast.py  test.py</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ <span class="built_in">ls</span> t[^/e]st.py       </span><br><span class="line">tast.py</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>!]可能被zsh认为是一个事件从而出错，把把方括号部分替换为<code>'['!what_you_think']'</code>或者把 <code>!</code> 替换为…<code>^/</code></p><p>Zsh（Z Shell）是一个强大的命令行解释器，用于 UNIX 操作系统。它是Bourne Shell的扩展，具有许多改进，包括更好的用户交互、功能强大的脚本能力和自定义功能。</p>]]></content:encoded>
      
      
      
      <category domain="http://midnightr3d.top/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</category>
      
      <category domain="http://midnightr3d.top/tags/Linux/">Linux</category>
      
      
      <comments>http://midnightr3d.top/2024/04/17/bashshell%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
