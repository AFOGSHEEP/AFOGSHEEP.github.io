<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-mac-osx.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"afogsheep.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="We losers do nothing so winners keeping winning   仍在施工中">
<meta property="og:type" content="website">
<meta property="og:title" content="杜鹃声">
<meta property="og:url" content="https://afogsheep.github.io/index.html">
<meta property="og:site_name" content="杜鹃声">
<meta property="og:description" content="We losers do nothing so winners keeping winning   仍在施工中">
<meta property="og:locale" content="zh_CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://afogsheep.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>杜鹃声</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">杜鹃声</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">此情可待成追忆，只是当时已惘然</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://afogsheep.github.io/2024/04/23/STL%E7%AE%97%E6%B3%95%E6%B6%89%E7%8C%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="We losers do nothing so winners keeping winning <br> </br> 仍在施工中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杜鹃声">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/23/STL%E7%AE%97%E6%B3%95%E6%B6%89%E7%8C%8E/" class="post-title-link" itemprop="url">STL算法涉猎</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2024-04-23 23:28:45 / 修改时间：23:29:44" itemprop="dateCreated datePublished" datetime="2024-04-23T23:28:45+08:00">2024-04-23</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="STL算法涉猎"><a href="#STL算法涉猎" class="headerlink" title="STL算法涉猎"></a>STL算法涉猎</h1><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>考虑以下问题：假设我们想要编写一个程序，该程序从文件中读取整数列表（可能表示作业中的成绩），然后打印出这些值的平均值。为简单起见，我们假设此数据存储在名为 data.txt 的文件中，每行一个整数。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">95</span><br><span class="line">92</span><br><span class="line">98</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">100</span><br><span class="line">87</span><br><span class="line">89</span><br><span class="line">87</span><br><span class="line">89</span><br><span class="line">83</span><br><span class="line">87</span><br><span class="line">97</span><br><span class="line">99</span><br><span class="line">89</span><br><span class="line">88</span><br></pre></td></tr></table></figure>

<p>以下是一个可能的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">input</span><span class="params">(<span class="string">&quot;G:\\Cpp_Learn\\full_course_reader\\week5\\data.txt&quot;</span>)</span></span>;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; values;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> currVaule;</span><br><span class="line">    <span class="keyword">while</span>(input &gt;&gt; currVaule)&#123;</span><br><span class="line">        values.<span class="built_in">insert</span>(currVaule);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//习惯性的写法</span></span><br><span class="line">    <span class="type">float</span> total = <span class="number">0.000</span>; </span><br><span class="line">    <span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator itr = values.<span class="built_in">begin</span>(); itr != values.<span class="built_in">end</span>(); ++itr)&#123;</span><br><span class="line">        total += *itr;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;average is : &quot;</span> &lt;&lt; total/values.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要用语言描绘这个程序，我们可以把他分为三步：</p>
<ol>
<li>读取文件内容</li>
<li>将值相加</li>
<li>除以元素个数</li>
</ol>
<p>我们必须以这种机械的方式向计算机发出命令的原因正是因为计算机是机械的——它是一台高效计算功能的机器。编程的挑战是找到一种方法，将一组高级命令转换为一系列控制机器的低级指令。这通常是一件苦差事，因为计算机导出的基本操作相当有限。但编程并不一定这么难。正如你所看到的，我们可以根据旧函数来定义新函数，并且可以从这些越来越强大的子程序中构建复杂的程序。从理论上讲，你可以编译一个巨大的库，其中包含所有非平凡的编程问题的解决方案。有了这个库，你就可以轻松地编写程序，只需将这些预先编写好的组件拼接在一起。</p>
<p>不幸的是，没有一个库可以解决每个编程问题。然而，这并没有阻止STL的设计者尽最大努力建造一个。这些是 STL 算法，一个用于处理数据的非常强大的例程库。STL 算法不能做所有事情，但它们能做的事情却做得非常出色。实际上，使用 STL 算法，可以重写在四行代码中平均数字的程序。</p>
<h2 id="第一个STL算法：Accumulate"><a href="#第一个STL算法：Accumulate" class="headerlink" title="第一个STL算法：Accumulate"></a>第一个STL算法：Accumulate</h2><p>关于先前求和的部分，可以用以下的方法替代：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;numeric&gt;</span></span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;average is : &quot;</span> &lt;&lt; <span class="built_in">accumulate</span>(values.<span class="built_in">begin</span>(),values.<span class="built_in">end</span>(),<span class="number">0.0</span>)/values.<span class="built_in">size</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>在标头中定义的 accumulate 函数<numeric>采用三个参数 – 两个定义元素范围的迭代器，以及用于求和的初始值。然后，它计算迭代器范围内包含的所有元素的总和，加上基本值。 accumulate（以及一般的 STL 算法）的美妙之处在于，accumulate 可以接受任何类型的迭代器。也就是说，我们可以从多集、向量或 deque 中求和迭代器。这意味着，如果您发现自己需要计算容器中包含的元素的总和，则可以将该容器的 begin（） 和 end（） 迭代器传递到 accumulate 中以获得总和。此外，accumulate 可以接受任何有效的迭代器范围，而不仅仅是跨整个容器的迭代器范围。例如，如果我们想计算多集的元素之和，这些元素介于 42 和 137 之间（含 42 和 137），我们可以写成:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">accumulate</span>(values.<span class="built_in">lower_bound</span>(<span class="number">42</span>), values.<span class="built_in">upper_bound</span>(<span class="number">137</span>), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>在幕后，accumulate 被实现为一个模板函数，它接受两个迭代器，并简单地使用循环将值相加。这是 accumulate 的一种可能实现:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> Type&gt; <span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function">   Type <span class="title">accumulate</span><span class="params">(InputIterator start, InputIterator stop, Type initial)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(start != stop) &#123;</span><br><span class="line">           initial += *start;</span><br><span class="line">           ++start;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> initial;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>代码的核心是一个标准的迭代器循环，它不断向前推进启动迭代器，直到它到达目的地。累加没有什么神奇之处，函数调用是一行代码这一事实并没有改变它仍然使用循环将所有值相加的事实。</p>
<p>如果 STL 算法只是在幕后使用循环的函数，为什么我们还要费心学习呢？有几个原因，第一个原因是简单。借助 STL 算法，您可以利用已经为您编写的代码，而不是从头开始重新编写代码。这可以节省大量时间，也导致了第二个原因，即正确性。如果你每次需要使用它们时都必须从头开始重写所有算法，那么在某个时候你很可能会犯错误。例如，您可能会编写一个排序例程，该例程在您打算&gt;时意外地使用了 &lt;，因此根本不起作用。STL 算法则不然——它们已经过全面测试，可以正常工作于任何给定的输入。使用算法的第三个原因是速度。一般来说，你可以假设，如果有一个 STL 算法来执行一项任务，它将比你手动编写的大多数代码更快。通过模板专用化和模板元编程等先进技术，STL 算法经过透明优化，以尽可能快地工作。最后，STL 算法提供了清晰度。使用算法，您可以立即判断出对累积的调用将某个范围内的数字相加。但使用求和值的 for 循环，您必须先阅读循环中的每一行，然后才能理解代码的作用。</p>
<h2 id="算法命名的约定"><a href="#算法命名的约定" class="headerlink" title="算法命名的约定"></a>算法命名的约定</h2><p>有超过 50 种 STL 算法（定义在 中<algorithm><numeric>或 中），至少可以说，记住它们将是一件苦差事。幸运的是，它们中的许多都有通用的命名约定，因此即使我们以前从未遇到过它们，也可以轻松识别。</p>
<h3 id="后缀-‘-if-‘"><a href="#后缀-‘-if-‘" class="headerlink" title="后缀 ‘ _if ‘"></a>后缀 ‘ _if ‘</h3><p>以 <code>_if</code> 结尾的算法基于条件执行操作。这些函数需要一个谓词——一个接受元素作为输入并返回布尔值的函数，该布尔值指示元素是否满足特定标准。示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEven</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myVec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">137</span>, <span class="number">137</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;偶数元素数量: &quot;</span> </span><br><span class="line">              &lt;&lt; <span class="built_in">count_if</span>(myVec.<span class="built_in">begin</span>(), myVec.<span class="built_in">end</span>(), IsEven) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="关键字-‘-copy-‘"><a href="#关键字-‘-copy-‘" class="headerlink" title="关键字 ‘ copy ‘"></a>关键字 ‘ copy ‘</h3><p>名称中包含 <code>copy</code> 的算法执行操作并将结果存储在由另一个迭代器指定的新位置。当想保留原始数据的同时处理转换后的数据时，这非常有用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; src = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; dest;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为新元素腾出空间</span></span><br><span class="line">    dest.<span class="built_in">resize</span>(src.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">remove_copy_if</span>(src.<span class="built_in">begin</span>(), src.<span class="built_in">end</span>(), dest.<span class="built_in">begin</span>(), [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : dest) &#123;</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="后缀-‘-n-‘"><a href="#后缀-‘-n-‘" class="headerlink" title="后缀 ‘_n ‘"></a>后缀 ‘_n ‘</h3><p>算法名称中的 <code>_n</code> 后缀表明操作将执行指定次数，而不是在一个范围内执行。当确切的操作次数比数据范围更重要时，这特别有用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::deque&lt;<span class="type">int</span>&gt; <span class="title">myDeque</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fill_n</span>(myDeque.<span class="built_in">begin</span>(), <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : myDeque) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的<code>fill_n</code> 将 <code>myDeque</code> 的前十个元素设置为零。</p>
<h2 id="解析-STL-迭代器的分类"><a href="#解析-STL-迭代器的分类" class="headerlink" title="解析 STL 迭代器的分类"></a>解析 STL 迭代器的分类</h2><p>在 C++ 标准模板库（STL）中，迭代器是访问和操作容器中元素的关键工具。由于不同容器的内部结构差异，迭代器的功能也有所不同，因此 STL 迭代器被分为几种不同的类型，每种迭代器具有不同的能力和限制。了解这些迭代器的分类对于有效使用 STL 是非常重要的。</p>
<h3 id="迭代器的分类及功能"><a href="#迭代器的分类及功能" class="headerlink" title="迭代器的分类及功能"></a>迭代器的分类及功能</h3><p>迭代器按照功能强弱分为五种类型，从功能最弱到功能最强依次是：</p>
<ol>
<li><strong>输出迭代器（Output Iterators）</strong><ul>
<li>输出迭代器允许写入值（使用 <code>*myItr = value</code> 语法）。</li>
<li>可以向前移动（使用 <code>++</code> 操作符）。</li>
<li>不能读取值或使用 <code>+=</code> 或 <code>-</code> 操作符。</li>
</ul>
</li>
<li><strong>输入迭代器（Input Iterators）</strong><ul>
<li>输入迭代器允许读取值（使用 <code>value = *myItr</code> 语法）。</li>
<li>不能写入值或遍历同一范围两次。</li>
</ul>
</li>
<li><strong>前向迭代器（Forward Iterators）</strong><ul>
<li>结合了输入和输出迭代器的功能，支持读写操作。</li>
<li>只能向前移动（使用 <code>++</code> 操作符）。</li>
</ul>
</li>
<li><strong>双向迭代器（Bidirectional Iterators）</strong><ul>
<li>拥有前向迭代器的所有功能。</li>
<li>可以向后移动（使用 <code>--</code> 操作符）。</li>
<li>通常用于像 <code>map</code> 和 <code>set</code> 这样的容器。</li>
</ul>
</li>
<li><strong>随机访问迭代器（Random-Access Iterators）</strong><ul>
<li>提供最大的功能，支持任意前后移动。</li>
<li>支持迭代器加减、使用方括号语法和 <code>+</code>、<code>+=</code> 操作。</li>
<li>主要用于 <code>vector</code> 和 <code>deque</code>。</li>
</ul>
</li>
</ol>
<h3 id="为什么要区分迭代器类型？"><a href="#为什么要区分迭代器类型？" class="headerlink" title="为什么要区分迭代器类型？"></a>为什么要区分迭代器类型？</h3><p>由于容器的内部数据结构不同，迭代器的实现和性能也会有很大差异。例如，<code>vector</code> 和 <code>deque</code> 支持随机访问迭代器，因为它们的元素是连续存储的，可以通过简单的地址计算快速访问任何元素。相反，<code>set</code> 和 <code>map</code> 通常使用树结构存储元素，所以它们的迭代器只能一步一步地前进或后退，这种操作的复杂度是线性的。</p>
<p>在实际编程中，了解并使用正确类型的迭代器非常关键，因为它关系到代码的性能和效率。当一个库函数需要特定类型的迭代器时，提供一个功能相当或更强大的迭代器是可行的。例如，如果一个函数需要一个前向迭代器，那么提供一个前向迭代器、双向迭代器或随机访问迭代器都是可以的。</p>
<p>通过掌握这些迭代器的分类和功能，可以更加灵活和高效地使用 STL，从而编写出更优雅和高效的 C++ 代码。</p>
<p><img src="G:\Cpp_Learn\full_course_reader\notes\assets\image-20240423225530689.png" alt="image-20240423225530689"></p>
<h2 id="探索-STL-重排序算法"><a href="#探索-STL-重排序算法" class="headerlink" title="探索 STL 重排序算法"></a>探索 STL 重排序算法</h2><p>在 C++ 的标准模板库（STL）中，有一系列用于重排序容器中元素的算法。这些算法能够在不改变元素内容的前提下，改变元素的排列顺序。以下是三种主要的重排序算法：<code>sort</code>、<code>random_shuffle</code> 和 <code>rotate</code>，它们各自的用途和功能都非常实用。</p>
<h3 id="排序算法（sort）"><a href="#排序算法（sort）" class="headerlink" title="排序算法（sort）"></a>排序算法（<code>sort</code>）</h3><p><code>sort</code> 算法是用于将容器中的元素按照升序排序。此算法要求传入的迭代器为随机访问迭代器，因此它不能用于 <code>map</code> 或 <code>set</code> 类型的容器，不过这些容器本身就是有序的。</p>
<p><strong>基本用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(myVector.<span class="built_in">begin</span>(), myVector.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<p>此外，<code>sort</code> 还允许指定一个自定义的比较函数，以实现不同的排序准则。</p>
<p><strong>自定义比较函数示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">placeT</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ComparePlaces</span><span class="params">(placeT one, placeT two)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (one.x != two.x) <span class="keyword">return</span> one.x &lt; two.x;</span><br><span class="line">    <span class="keyword">return</span> one.y &lt; two.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;placeT&gt; myPlaceVector = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(myPlaceVector.<span class="built_in">begin</span>(), myPlaceVector.<span class="built_in">end</span>(), ComparePlaces);</span><br></pre></td></tr></table></figure>

<h3 id="随机打乱算法（random-shuffle）"><a href="#随机打乱算法（random-shuffle）" class="headerlink" title="随机打乱算法（random_shuffle）"></a>随机打乱算法（<code>random_shuffle</code>）</h3><p><code>random_shuffle</code> 算法用于随机打乱容器中的元素。类似于 <code>sort</code>，这个算法也需要随机访问迭代器。</p>
<p><strong>示例用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">std::<span class="built_in">random_shuffle</span>(myVector.<span class="built_in">begin</span>(), myVector.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<p>在使用 <code>random_shuffle</code> 之前，建议使用 <code>srand</code> 函数来设定随机数生成器的种子，以确保每次程序运行结果的随机性。</p>
<h3 id="旋转算法（rotate）"><a href="#旋转算法（rotate）" class="headerlink" title="旋转算法（rotate）"></a>旋转算法（<code>rotate</code>）</h3><p><code>rotate</code> 算法通过循环移动容器中的元素，使得指定位置的元素变为容器的开始。</p>
<p><strong>示例用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">std::<span class="built_in">rotate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">begin</span>() + <span class="number">2</span>, v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p>在此示例中，向量 <code>v</code> 中的元素会被旋转，结果为 <code>&#123;2, 3, 4, 5, 0, 1&#125;</code>。</p>
<p>这些重排序算法在日常编程中非常有用，它们可以帮助开发者有效地处理和变换数据。了解和运用这些算法，可以极大地提高编程效率和代码的可读性。</p>
<h2 id="探索-STL-中的搜索算法"><a href="#探索-STL-中的搜索算法" class="headerlink" title="探索 STL 中的搜索算法"></a>探索 STL 中的搜索算法</h2><p>在数据处理过程中，常常需要在容器中查找特定的元素。例如，你可能想知道一个向量是否包含一个特定的元素。尽管 <code>map</code> 和 <code>set</code> 容器提供了内置的查找功能，<code>vector</code> 和 <code>deque</code> 等线性容器则缺少这样的功能。好在，STL 提供了多种算法来补充这一功能缺失。</p>
<h3 id="find-算法"><a href="#find-算法" class="headerlink" title="find 算法"></a><code>find</code> 算法</h3><p><code>find</code> 函数是最基本的搜索算法，它接受两个迭代器（定义搜索范围）和一个值，返回第一个匹配该值的元素的迭代器。如果范围内没有匹配的元素，<code>find</code> 返回第二个迭代器作为哨兵值。</p>
<p><strong>示例用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">137</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">find</span>(myVector.<span class="built_in">begin</span>(), myVector.<span class="built_in">end</span>(), <span class="number">137</span>) != myVector.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// 向量包含元素 137</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然你可以在 <code>map</code> 和 <code>set</code> 上使用 <code>find</code>，但通常不推荐这样做。因为 <code>map</code> 和 <code>set</code> 的成员函数 <code>find</code> 使用了容器内部数据结构的信息来加快搜索速度，而 STL 的 <code>find</code> 函数则必须线性地遍历元素，效率较低。</p>
<h3 id="binary-search-算法"><a href="#binary-search-算法" class="headerlink" title="binary_search 算法"></a><code>binary_search</code> 算法</h3><p>如果你有一个已排序的线性容器（如排序后的 <code>vector</code>），可以使用 <code>binary_search</code> 来执行搜索，这比线性搜索快得多。<code>binary_search</code> 仅返回一个布尔值，表示是否找到了指定的元素。</p>
<p><strong>示例用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">137</span>&#125;;  <span class="comment">// 假设已排序</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">binary_search</span>(myVector.<span class="built_in">begin</span>(), myVector.<span class="built_in">end</span>(), <span class="number">137</span>)) &#123;</span><br><span class="line">    <span class="comment">// 找到了元素 137</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果容器使用了特殊的比较函数进行排序，你也可以将这个比较函数传递给 <code>binary_search</code>。但要确保使用一致的比较函数，否则可能导致 <code>binary_search</code> 工作不正常。</p>
<h3 id="lower-bound-算法"><a href="#lower-bound-算法" class="headerlink" title="lower_bound 算法"></a><code>lower_bound</code> 算法</h3><p>如果你需要在排序的容器中找到一个元素并获取指向该元素的迭代器，可以使用 <code>lower_bound</code>。这个算法返回指向第一个不小于指定值的元素的迭代器。如果没有找到精确匹配的元素，<code>lower_bound</code> 可能返回指向一个更大元素的迭代器，因此在使用返回的迭代器前需要进行检查。</p>
<p><strong>示例用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">137</span>&#125;;  <span class="comment">// 假设已排序</span></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(myVector.<span class="built_in">begin</span>(), myVector.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span> (it != myVector.<span class="built_in">end</span>() &amp;&amp; *it == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="comment">// 找到元素 4</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 元素 4 不在向量中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些搜索算法是处理 STL 容器中数据的强大工具。合理使用这些算法不仅可以提高代码的效率，还能使代码更加清晰和易于维护。</p>
<h2 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h2><p>在使用 C++ 标准模板库（STL）的过程中，当我们想要通过算法生成数据范围时，确保目标位置有足够的空间来存放结果是非常重要的。例如，<code>copy</code> 算法需要目标容器预先分配足够的空间以防写入数据时超出范围导致未定义行为。为了解决这个问题，STL 提供了一类特殊的工具，称为迭代器适配器，这些适配器扩展了迭代器的功能，使其更加灵活和强大。</p>
<h3 id="ostream-iterator-——-输出流迭代器"><a href="#ostream-iterator-——-输出流迭代器" class="headerlink" title="ostream_iterator —— 输出流迭代器"></a><code>ostream_iterator</code> —— 输出流迭代器</h3><p><code>ostream_iterator</code> 是一种输出流迭代器，它不指向任何实际的容器元素，而是将数据输出到指定的流，如 <code>cout</code> 或文件流。</p>
<p><strong>示例用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">myItr</span><span class="params">(std::cout, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line">    *myItr = <span class="number">137</span>; <span class="comment">// 输出 137 到 cout</span></span><br><span class="line">    ++myItr;</span><br><span class="line">    *myItr = <span class="number">42</span>;  <span class="comment">// 输出 42 到 cout</span></span><br><span class="line">    ++myItr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码通过 <code>ostream_iterator</code> 将整数直接写入到标准输出流 <code>cout</code>，数字之间由空格分隔。</p>
<h3 id="使用-ostream-iterator-结合-STL-算法"><a href="#使用-ostream-iterator-结合-STL-算法" class="headerlink" title="使用 ostream_iterator 结合 STL 算法"></a>使用 <code>ostream_iterator</code> 结合 STL 算法</h3><p>由于 <code>ostream_iterator</code> 本身是一个迭代器，我们可以将其与 STL 算法结合使用，从而实现复杂的输出任务。例如，我们可以将一个容器中的所有元素复制到输出流中。</p>
<p><strong>示例用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::<span class="built_in">copy</span>(myVector.<span class="built_in">begin</span>(), myVector.<span class="built_in">end</span>(), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此代码将 <code>myVector</code> 中的所有元素复制到 <code>cout</code>，元素之间以空格分隔，一行代码实现了整个向量的输出。</p>
<h3 id="back-insert-iterator-——-后插迭代器"><a href="#back-insert-iterator-——-后插迭代器" class="headerlink" title="back_insert_iterator —— 后插迭代器"></a><code>back_insert_iterator</code> —— 后插迭代器</h3><p>另一个有用的迭代器适配器是 <code>back_insert_iterator</code>，这种迭代器在写入数据时会自动调用 <code>push_back</code> 方法将数据追加到容器的末尾。</p>
<p><strong>示例用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myVector;</span><br><span class="line">    std::back_insert_iterator&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">itr</span>(myVector);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        *itr = i; <span class="comment">// 追加值到 myVector</span></span><br><span class="line">        ++itr;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">copy</span>(myVector.<span class="built_in">begin</span>(), myVector.<span class="built_in">end</span>(), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>back_insert_iterator</code> 被用来动态地向 <code>myVector</code> 添加元素，之后通过 <code>copy</code> 和 <code>ostream_iterator</code> 输出所有元素。</p>
<h3 id="insert-iterator-的应用"><a href="#insert-iterator-的应用" class="headerlink" title="insert_iterator 的应用"></a><code>insert_iterator</code> 的应用</h3><p><code>insert_iterator</code> 是一种更通用的迭代器适配器，它可以在容器的任意位置插入元素。这种迭代器在处理需要元素插入的算法，如集合操作算法 <code>set_union</code>, <code>set_intersection</code>, <code>set_difference</code> 等时尤为有用。</p>
<p><strong>示例用法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cppCopy codestd::set&lt;int&gt; setOne = &#123;1, 2, 3&#125;;</span><br><span class="line">std::set&lt;int&gt; setTwo = &#123;2, 3, 4&#125;;</span><br><span class="line">std::set&lt;int&gt; result;</span><br><span class="line">std::set_union(setOne.begin(), setOne.end(), setTwo.begin(), setTwo.end(), std::inserter(result, result.begin()));</span><br></pre></td></tr></table></figure>

<p>这段代码计算了 <code>setOne</code> 和 <code>setTwo</code> 的并集，并使用 <code>insert_iterator</code> 将结果存入 <code>result</code>。</p>
<h3 id="istream-iterator-——-输入流迭代器"><a href="#istream-iterator-——-输入流迭代器" class="headerlink" title="istream_iterator —— 输入流迭代器"></a><code>istream_iterator</code> —— 输入流迭代器</h3><p><code>istream_iterator</code> 是另一种迭代器适配器，它允许从输入流（如文件或标准输入）读取数据。这使得 <code>istream_iterator</code> 成为处理输入数据流的理想工具。</p>
<p><strong>示例用法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cppCopy codestd::istream_iterator&lt;int&gt; it(std::cin);</span><br><span class="line">std::istream_iterator&lt;int&gt; end;</span><br><span class="line">std::vector&lt;int&gt; values(it, end); // 从标准输入读取整数直到 EOF</span><br></pre></td></tr></table></figure>

<p>在这个例子中，从标准输入读取的整数被存储到 <code>values</code> 向量中，直到输入结束。</p>
<h2 id="常见的迭代器及其应用"><a href="#常见的迭代器及其应用" class="headerlink" title="常见的迭代器及其应用"></a>常见的迭代器及其应用</h2><p>在 C++ 标准模板库（STL）中，迭代器适配器扩展了基本迭代器的功能，使它们能够在特定的上下文中更加有效地工作。下面是一些常见迭代器适配器的详细介绍，这些适配器广泛应用于处理容器和流中的数据。</p>
<h2 id="常见的迭代器适配器及其应用"><a href="#常见的迭代器适配器及其应用" class="headerlink" title="常见的迭代器适配器及其应用"></a>常见的迭代器适配器及其应用</h2><p>在 C++ 标准模板库（STL）中，迭代器适配器扩展了基本迭代器的功能，使它们能够在特定的上下文中更加有效地工作。下面是一些常见迭代器适配器的详细介绍，这些适配器广泛应用于处理容器和流中的数据。</p>
<h3 id="输出迭代器"><a href="#输出迭代器" class="headerlink" title="输出迭代器"></a>输出迭代器</h3><h4 id="back-insert-iterator"><a href="#back-insert-iterator" class="headerlink" title="back_insert_iterator"></a><code>back_insert_iterator</code></h4><ul>
<li><p><strong>定义</strong>: <code>back_insert_iterator&lt;Container&gt;</code></p>
</li>
<li><p><strong>构造方法</strong>: <code>back_insert_iterator&lt;vector&lt;int&gt;&gt; itr(myVector);</code></p>
</li>
<li><p><strong>功能</strong>: 通过调用容器的 <code>push_back</code> 方法来存储元素。</p>
</li>
<li><p><strong>用法</strong>: 可以显式声明或使用 <code>back_inserter</code> 函数快速创建。</p>
</li>
<li><p>示例:</p>
<p>使用 <code>back_insert_iterator</code> 将元素添加到 <code>vector</code> 的末尾。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    std::<span class="built_in">copy</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(result));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : result) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="front-insert-iterator"><a href="#front-insert-iterator" class="headerlink" title="front_insert_iterator"></a><code>front_insert_iterator</code></h4><ul>
<li><p><strong>定义</strong>: <code>front_insert_iterator&lt;Container&gt;</code></p>
</li>
<li><p><strong>构造方法</strong>: <code>front_insert_iterator&lt;deque&lt;int&gt;&gt; itr(myIntDeque);</code></p>
</li>
<li><p><strong>功能</strong>: 通过调用容器的 <code>push_front</code> 方法来存储元素。</p>
</li>
<li><p><strong>限制</strong>: 不能用于不支持 <code>push_front</code> 方法的容器，如 <code>vector</code>。</p>
</li>
<li><p><strong>用法</strong>: 可以使用 <code>front_inserter</code> 函数创建。</p>
</li>
<li><p>示例:</p>
<p>使用 <code>front_insert_iterator</code> 将元素添加到 <code>deque</code> 的前端。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">    std::front_insert_iterator&lt;std::deque&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">inserter</span>(data);</span><br><span class="line">    *inserter = <span class="number">1</span>;</span><br><span class="line">    *inserter = <span class="number">2</span>;</span><br><span class="line">    *inserter = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : data) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// Output: 3 2 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="insert-iterator"><a href="#insert-iterator" class="headerlink" title="insert_iterator"></a><code>insert_iterator</code></h4><ul>
<li><strong>定义</strong>: <code>insert_iterator&lt;Container&gt;</code></li>
<li><strong>构造方法</strong>: <code>insert_iterator&lt;set&lt;int&gt;&gt; itr(mySet, mySet.begin());</code></li>
<li><strong>功能</strong>: 在指定位置调用容器的 <code>insert</code> 方法来插入元素。</li>
<li><strong>适用范围</strong>: 可用于任何容器，尤其适合于 <code>set</code>。</li>
<li><strong>用法</strong>: 可以通过 <code>inserter</code> 函数生成。</li>
<li>示例:</li>
</ul>
<p>​	使用 <code>insert_iterator</code> 在 <code>set</code> 中插入元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line">    std::insert_iterator&lt;std::set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">inserter</span>(numbers, numbers.<span class="built_in">begin</span>());</span><br><span class="line">    *inserter = <span class="number">3</span>;</span><br><span class="line">    *inserter = <span class="number">1</span>;</span><br><span class="line">    *inserter = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// Output: 1 2 3 (automatically sorted)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="流迭代器"><a href="#流迭代器" class="headerlink" title="流迭代器"></a>流迭代器</h3><h4 id="ostream-iterator"><a href="#ostream-iterator" class="headerlink" title="ostream_iterator"></a><code>ostream_iterator</code></h4><ul>
<li><strong>定义</strong>: <code>ostream_iterator&lt;Type&gt;</code></li>
<li><strong>构造方法</strong>: <code>ostream_iterator&lt;int&gt; itr(cout, &quot; &quot;);</code></li>
<li><strong>功能</strong>: 将元素写入输出流中，可选地在每个元素后添加分隔符。</li>
<li><strong>用法</strong>: 初始化时必须指定输出流和可选的分隔符。</li>
<li>示例:</li>
</ul>
<p>​	使用 <code>ostream_iterator</code> 输出元素到标准输出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="function">std::ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">output</span><span class="params">(std::cout, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), output);  <span class="comment">// Output: 1 2 3</span></span><br></pre></td></tr></table></figure>

<h4 id="istream-iterator"><a href="#istream-iterator" class="headerlink" title="istream_iterator"></a><code>istream_iterator</code></h4><ul>
<li><strong>定义</strong>: <code>istream_iterator&lt;Type&gt;</code></li>
<li><strong>构造方法</strong>: <code>istream_iterator&lt;int&gt; itr(cin);</code></li>
<li><strong>功能</strong>: 从指定的输入流中读取值。</li>
<li><strong>特性</strong>: 当到达流的末尾时，会取得一个特殊的“结束”值。</li>
<li><strong>注意事项</strong>: 易受输入流状态影响，使用时需注意。</li>
<li>示例:</li>
</ul>
<p>​	使用 <code>istream_iterator</code> 从标准输入读取整数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter numbers separated by spaces: &quot;</span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(std::<span class="built_in">istream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cin), std::<span class="built_in">istream_iterator</span>&lt;<span class="type">int</span>&gt;(), std::<span class="built_in">back_inserter</span>(numbers));</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ostreambuf-iterator"><a href="#ostreambuf-iterator" class="headerlink" title="ostreambuf_iterator"></a><code>ostreambuf_iterator</code></h4><ul>
<li><strong>定义</strong>: <code>ostreambuf_iterator&lt;char&gt;</code></li>
<li><strong>构造方法</strong>: <code>ostreambuf_iterator&lt;char&gt; itr(cout);</code></li>
<li><strong>功能</strong>: 将原始字符数据写入输出流。</li>
<li><strong>限制</strong>: 仅能写入字符数据。</li>
<li>示例:</li>
</ul>
<p>​	使用 <code>ostreambuf_iterator</code> 输出字符到标准输出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ostreambuf_iterator&lt;<span class="type">char</span>&gt; <span class="title">output</span><span class="params">(std::cout)</span></span>;</span><br><span class="line">    *output = <span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">    *output = <span class="string">&#x27;i&#x27;</span>;</span><br><span class="line">    *output = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="istreambuf-iterator"><a href="#istreambuf-iterator" class="headerlink" title="istreambuf_iterator"></a><code>istreambuf_iterator</code></h4><ul>
<li><p><strong>定义</strong>: <code>istreambuf_iterator&lt;char&gt;</code></p>
</li>
<li><p><strong>构造方法</strong>: <code>istreambuf_iterator&lt;char&gt; itr(cin);</code></p>
</li>
<li><p><strong>功能</strong>: 从输入流中读取未格式化的数据。</p>
</li>
<li><p><strong>特性</strong>: 始终读取字符数据，不跳过空白。</p>
</li>
<li><p><strong>用途</strong>: 常用于从文件中读取原始数据进行处理。</p>
</li>
<li><p>示例:</p>
<p>使用 <code>istreambuf_iterator</code> 从标准输入读取原始字符数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">cppCopy code<span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter text, followed by EOF: &quot;</span>;</span><br><span class="line">    <span class="function">std::istreambuf_iterator&lt;<span class="type">char</span>&gt; <span class="title">start</span><span class="params">(std::cin)</span>, end</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">characters</span><span class="params">(start, end)</span></span>;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(characters.<span class="built_in">begin</span>(), characters.<span class="built_in">end</span>(), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">char</span>&gt;(std::cout, <span class="string">&quot;&quot;</span>));</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://afogsheep.github.io/2024/04/17/bashshell%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="We losers do nothing so winners keeping winning <br> </br> 仍在施工中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杜鹃声">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/17/bashshell%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">bashshell基础命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-17 23:10:12" itemprop="dateCreated datePublished" datetime="2024-04-17T23:10:12+08:00">2024-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-18 13:44:17" itemprop="dateModified" datetime="2024-04-18T13:44:17+08:00">2024-04-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="bashshell基础命令"><a href="#bashshell基础命令" class="headerlink" title="bashshell基础命令"></a>bashshell基础命令</h1><h2 id="启动终端"><a href="#启动终端" class="headerlink" title="启动终端"></a>启动终端</h2><p>启动终端后会看见 <strong>shell CLI</strong> 提示符，在此输入shell命令。默认的提示符符号是 $</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/etc]</span><br><span class="line">└─$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="与bash手册交互"><a href="#与bash手册交互" class="headerlink" title="与bash手册交互"></a>与bash手册交互</h2><p>大多数Linux发行版自带在线手册。使用man命令可以访问Linux系统的手册页。输入 <code>man 想要查看的命令</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       <span class="built_in">cat</span> - concatenate files and <span class="built_in">print</span> on the standard output</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="built_in">cat</span> [OPTION]... [FILE]...</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       Concatenate FILE(s) to standard output.</span><br><span class="line"></span><br><span class="line">       With no FILE, or when FILE is -, <span class="built_in">read</span> standard input.</span><br><span class="line"></span><br><span class="line">       -A, --show-all</span><br><span class="line">              equivalent to -vET</span><br><span class="line"></span><br><span class="line">       -b, --number-nonblank</span><br><span class="line">              number nonempty output lines, overrides -n</span><br><span class="line"></span><br><span class="line">       -e     equivalent to -vE</span><br><span class="line"></span><br><span class="line">       -E, --show-ends</span><br><span class="line">              display $ at end of each line</span><br><span class="line"></span><br><span class="line">       -n, --number</span><br><span class="line">              number all output lines</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上是 <code>cat</code>的部分用法。输入 <code>man cat</code>即可查看</p>
<p>其中 <strong>DESCRIPTION</strong> 部分提供了快速参考。从中可以迅速了解命令的作用以及用法。</p>
<p>mannal里通过空格翻页，enter逐行查看，以及上下箭头进行滑动。按q退出。</p>
<p>如果忘记命令了，可以通过 <code>man -k terminal</code>进行关键词查找。</p>
<h2 id="浏览文件系统"><a href="#浏览文件系统" class="headerlink" title="浏览文件系统"></a>浏览文件系统</h2><h3 id="Linux中的目录"><a href="#Linux中的目录" class="headerlink" title="Linux中的目录"></a>Linux中的目录</h3><p>Linux采用名为“虚拟目录”的单个目录结构中。虚拟目录会将计算机中所有储存设备的文件路径都纳入单个目录结构。Linux的虚拟目录结构只包含一个叫做 root的目录的基础目录。所有文件都在root目录下一一列出。Linux中安装的第一块硬盘为根驱动器，所有目录都是从那里开始构建的。以下是kali的根目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿kali)-[/]</span><br><span class="line">└─<span class="comment"># ls</span></span><br><span class="line">bin   home            lib32       mnt   run       sys  vmlinuz</span><br><span class="line">boot  initrd.img      lib64       opt   sbin      tmp  vmlinuz.old</span><br><span class="line">dev   initrd.img.old  lost+found  proc  srv       usr</span><br><span class="line">etc   lib             media       root  swapfile  var</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里使用了ls命令来查看文件夹中的内容。常见的Linux目录名均基于文件系统层级标准（filesytem hierarchy standard, FHS）。</p>
<p>在Linux中，可以通过cd命令来切换目录。语法为 <code>cd destination</code>。使用 <code>cd ..</code>可以快速回到父目录。</p>
<p>使用 <code>pwd</code>命令可以了解当前工作目录。</p>
<p><code>ls</code>命令最基本的形式会显示当前目录下的文件和目录。使用 <code>ls -F</code>(注意，Linux系统严格区分大小写，-f和-F是两个不同的命令)可以区分文件和目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿kali)-[/]</span><br><span class="line">└─<span class="comment"># ls -F</span></span><br><span class="line">bin@   home/            lib32@       mnt/   run/      sys/  vmlinuz@</span><br><span class="line">boot/  initrd.img@      lib64@       opt/   sbin@     tmp/  vmlinuz.old@</span><br><span class="line">dev/   initrd.img.old@  lost+found/  proc/  srv/      usr/</span><br><span class="line">etc/   lib@             media/       root/  swapfile  var/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>-a选项能显示隐藏文件（通常是文件名以 . 开始的文件）</p>
<p>-R选项称作递归选项，能列出当前目录包含的子目录的文件与目录。</p>
<p>-l命令会产生长列表格式的输出，提供目录中各个文件的详细信息。在-l后跟上文件名即可只查看该文件的信息。</p>
<h3 id="过滤输出列表"><a href="#过滤输出列表" class="headerlink" title="过滤输出列表"></a>过滤输出列表</h3><p>ls命令支持在命令行中定义过滤器，使用过滤器来决定该在命令行中显示哪些文件或者目录。</p>
<p>在ls最后添加文件名是最基本的过滤方式，我们可以通过使用标准通配符来进行模式匹配。</p>
<ul>
<li>问号 （ ? ）代表任意单个字符</li>
<li>星号 （ * ）代表零个或者多个任意字符</li>
</ul>
<p>以 <code>/home/kali/</code>目录为例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ <span class="built_in">ls</span> -F                </span><br><span class="line">backup/   Documents/  fill    Pictures/  tast.py  teeeeeeeesy.txt  test.py</span><br><span class="line">Desktop/  Downloads/  Music/  Public/    te3t.py  Templates/       Videos/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ <span class="built_in">ls</span> t[a-z]st*</span><br><span class="line">tast.py  test.py</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ <span class="built_in">ls</span> t*       </span><br><span class="line">tast.py  te3t.py  teeeeeeeesy.txt  test.py</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ <span class="built_in">ls</span> t?st.py</span><br><span class="line">tast.py  test.py</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ <span class="built_in">ls</span> t[^/e]st.py       </span><br><span class="line">tast.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>!]可能被zsh认为是一个事件从而出错，把把方括号部分替换为 <code>&#39;[&#39;!what_you_think&#39;]&#39;</code>或者把 <code>!</code> 替换为 …<code>^/</code></p>
<p>Zsh（Z Shell）是一个强大的命令行解释器，用于 UNIX 操作系统。它是 Bourne Shell 的扩展，具有许多改进，包括更好的用户交互、功能强大的脚本能力和自定义功能。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://afogsheep.github.io/2024/04/10/cpp-learn%20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="We losers do nothing so winners keeping winning <br> </br> 仍在施工中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杜鹃声">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/10/cpp-learn%20/" class="post-title-link" itemprop="url">C++学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-10 21:20:12" itemprop="dateCreated datePublished" datetime="2024-04-10T21:20:12+08:00">2024-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-04-18 23:05:29" itemprop="dateModified" datetime="2024-04-18T23:05:29+08:00">2024-04-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="C-预备"><a href="#C-预备" class="headerlink" title="C++预备"></a>C++预备</h1><h2 id="一个半循环"><a href="#一个半循环" class="headerlink" title=" 一个半循环 "></a><span style="font-size:1.2em;"> <strong>一个半循环</strong> </span></h2><p>思考以下的循环方式和 <strong>while(! input.fail())</strong> 的区别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rowNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> intValue;</span><br><span class="line">            <span class="type">double</span> doubleValue;</span><br><span class="line">            input &gt;&gt; intValue &gt;&gt; doubleValue;</span><br><span class="line">            <span class="keyword">if</span>(input.<span class="built_in">fail</span>()) <span class="keyword">break</span>;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(COLUMN_WIDTH) &lt;&lt; (rowNumber + <span class="number">1</span>) &lt;&lt; <span class="string">&quot; | &quot;</span>;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(COLUMN_WIDTH) &lt;&lt; intValue &lt;&lt; <span class="string">&quot; | &quot;</span>;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(COLUMN_WIDTH) &lt;&lt; doubleValue &lt;&lt; endl;</span><br><span class="line"> rowNumber++;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这种循环优点在于错误发生时能及时停止循环，若是后者，则总是会多执行一次循环。使用一个半循环而不是简单的 while 循环是有益的。</p>
<p>事实上，以上的代码可以简化成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int intValue;</span><br><span class="line">   double doubleValue;</span><br><span class="line">   while(input &gt;&gt; intValue &gt;&gt; doubleValue) &#123;</span><br><span class="line">       /* ... process values here ... */</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>直接将操作符运算放进 while 循环的判定条件中，能有效的减少代码的冗余。</p>
<h2 id="c-程序是如何运行的？"><a href="#c-程序是如何运行的？" class="headerlink" title=" c++程序是如何运行的？ "></a><span style="font-size:1.2em;"> <strong>c++程序是如何运行的？</strong> </span></h2><p>c++程序的运行分为三个部分：</p>
<p>​	<span style="font-size:1.1em;"> 预处理（preprocessing）  编译(compile)  连接(link)</span></p>
<ul>
<li>预处理：在预处理步骤中，称为预处理器的特殊程序会扫描 C++ 源代码并对其应用各种转换。例如，解析 #include 指令以使各种库可用，特殊标记（如 __FILE_ _和 _ _LINE__将替换为源文件中的文件和行号，#define-d 常量和宏替换为其适当的值</li>
<li>编译：在编译步骤中，编译器将 C++源文件读入、优化并转换为目标文件。这些目标文件是特定于机器的，但通常包含执行 C++ 文件中指定的指令的机器代码，以及一些额外的信息。在这个阶段，编译器将报告犯的任何语法错误，例如省略分号、引用未定义的变量或将错误类型的参数传递到函数中</li>
<li>连接：最后，在链接阶段，一个名为链接器的程序将构建最终可执行文件所需的所有目标文件收集在一起，将它们与特定于操作系统的信息捆绑在一起，最后生成一个多文件程序、抽象和可以运行和分发的预处理器可执行文件。在此阶段，链接器可能会报告一些最终错误，这些错误会阻止它生成有效的 C++ 程序。</li>
</ul>
<h2 id="包含保护（include-guard）"><a href="#包含保护（include-guard）" class="headerlink" title=" 包含保护（include guard）"></a><strong><span style="font-size:1.2em;"> 包含保护（include guard）</span></strong></h2><p>运用以下代码来防止头文件被重复利用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef file_Included</span><br><span class="line">#define file_Included</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>头文件的后缀是 <strong>.h</strong></p>
<h2 id="define-是什么？"><a href="#define-是什么？" class="headerlink" title="#define 是什么？"></a><strong><span style="font-size:1.2em;">#define 是什么？</span></strong></h2><p>运用以下格式，在整个代码中完成替换</p>
<p> <span style="font-style:italic;">#define phrase replacement </span></p>
<p>注意，被替换的判断是从第一个空格开始，#define 指令的替换部分由换行符前面的短语后的所有文本组成。同时默认替换后的文本将会是字符串。这个过程是在编译过程中进行的。如果全局定义了一个函数，那么在调用时会将其先转化成 c++代码。</p>
<h2 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title=" inline, 内联函数 "></a><span style="font-size:1.2em;"> <strong>inline, 内联函数</strong> </span></h2><p>在计算机科学术语中，宏是内联的，因为编译器将“函数”的内容放在调用站点，而不是插入到函数代码的间接跳转。内联函数可能比非内联函数效率高得多.对一个函数使用 inline 关键字会建议编译器自动内联该函数，提高运行效率。inline 关键字只是对编译器的建议，如果编译器认为内联函数太难或成本太高，则可以忽略该关键字。但是，在编写短函数时，有时有助于将函数标记为内联以提高性能。</p>
<p>如以下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> one, <span class="type">int</span> two)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> one &gt; two ? one : two;</span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure>



<h2 id="向量小结"><a href="#向量小结" class="headerlink" title=" 向量小结 "></a><span style="font-size:1.2em;"> <strong>向量小结</strong> </span></h2><p>向量，作为一个允许我们使用单个变量存储元素序列的多功能工具，有着难以取代的非凡地位。向量可以储存所有类型的数据(不可以混储)，没有元素数量限制，增减元素都十分方便。仅仅需要在头文件中引入 <span style="color:#0000FF;"> include&lt;vector&gt; </span>。比如完成一个简单的从大到小排序的程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetInteger</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> myInt;</span><br><span class="line">    cin &gt;&gt; myInt;</span><br><span class="line">    <span class="keyword">return</span> myInt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">GetSmallestIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v,<span class="type">size_t</span> startIndex)</span></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> bestIndex = startIndex; <span class="comment">//size_t类型表示C中任何对象所能达到的最大长度，它是无符号整数。这里使用是因为index肯定是大于零的数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = startIndex; i &lt; v.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i] &lt; v[bestIndex])</span><br><span class="line">            bestIndex = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bestIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;  </span><br><span class="line">        <span class="type">size_t</span> smallestIndex = <span class="built_in">GetSmallestIndex</span>(v, i); </span><br><span class="line">        <span class="built_in">swap</span> (v[i], v[smallestIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; values; <span class="comment">//创建一个空向量</span></span><br><span class="line">    <span class="type">int</span> kNumValues = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span> ;i &lt; kNumValues; ++i)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;enter another value &quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span> val =<span class="built_in">GetInteger</span>();</span><br><span class="line">        values.<span class="built_in">push_back</span>(val);  <span class="comment">//给向量赋值</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SelectionSort</span>(values);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i&lt;values.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        cout &lt;&lt; values[i]&lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也能通过以下格式初始化向量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">myReals</span><span class="params">(<span class="number">20</span>, <span class="number">137.0</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">myStrings</span><span class="params">(<span class="number">5</span>, <span class="string">&quot;(none)&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>规定向量的元素上限以及填充内容。之后如果要改变向量元素上限可以使用&#96;.resize() 以下是示例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; myVector;			<span class="comment">// Defaults to empty vector</span></span><br><span class="line"><span class="built_in">PrintVector</span>(myVector);			<span class="comment">// Output: [nothing]</span></span><br><span class="line"></span><br><span class="line">myVector.<span class="built_in">resize</span>(<span class="number">10</span>);			<span class="comment">// Grow the vector, setting new elements to 0</span></span><br><span class="line"><span class="built_in">PrintVector</span>(myVector);			<span class="comment">// Output: 0 0 0 0 0 0 0 0 0 0</span></span><br><span class="line"></span><br><span class="line">myVector.<span class="built_in">resize</span>(<span class="number">5</span>);				<span class="comment">// Shrink the vector</span></span><br><span class="line"><span class="built_in">PrintVector</span>(myVector);			<span class="comment">// Output: 0 0 0 0 0</span></span><br><span class="line"></span><br><span class="line">myVector.<span class="built_in">resize</span>(<span class="number">7</span>, <span class="number">1</span>);			<span class="comment">// Grow the vector, setting new elements to 1</span></span><br><span class="line"><span class="built_in">PrintVector</span>(myVector);			<span class="comment">// Output: 0 0 0 0 0 1 1</span></span><br><span class="line"></span><br><span class="line">myVector.<span class="built_in">resize</span>(<span class="number">1</span>, <span class="number">7</span>);			<span class="comment">// The second parameter is effectively ignored.</span></span><br><span class="line"><span class="built_in">PrintVector</span>(myVector);			<span class="comment">// Output: 0</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><span style="font-size:1.2em;"> <strong>部分常见的向量操作</strong> </span></p>
<table>
<thead>
<tr>
<th>Constructor: vector ()</th>
<th>vector myVector; Constructs an empty vector</th>
</tr>
</thead>
<tbody><tr>
<td>Constructor: vector (size_type size)</td>
<td>vector myVector(10);                            Constructs a vector of the specified size where all elements  use their default values (for integral types, this is zero).</td>
</tr>
<tr>
<td>Constructor: vector (size_type size,                       const T&amp; default)</td>
<td>vector myVector(5, “blank”);                   Constructs a vector of the specified size where each  element is equal to the specified default value.</td>
</tr>
<tr>
<td>size_type size() const;</td>
<td>for(int i &#x3D; 0; i &lt; myVector.size(); ++i) { … } Returns the number of elements in the vector</td>
</tr>
<tr>
<td>bool empty() const;</td>
<td>while(! myVector.empty()) { … } Returns whether the vector is empty.</td>
</tr>
<tr>
<td>void clear();</td>
<td>myVector.clear(); <br /> Erases all the elements in the vector and sets the size to  zero.</td>
</tr>
<tr>
<td>T&amp; operator [] (size_type position); <br /> const T&amp; operator [] (size_type position) const;    <br /> T&amp; at(size_type position); const T&amp; at(size_type position) const;</td>
<td>myVector [0] &#x3D; 100; int x &#x3D; myVector [0]; myVector.at(0) &#x3D; 100; int x &#x3D; myVector.at(0); Returns a reference to the element at the specified position.  The bracket notation [] does not do any bounds checking  and has undefined behavior past the end of the data.  The at  member function will throw an exception if you try to  access data beyond the end.  We will cover exception  handling in a later chapter</td>
</tr>
<tr>
<td>void resize(size_type newSize); void resize(size_type newSize, T fill);</td>
<td>myVector.resize(10); myVector.resize(10, “default”); Resizes the vector so that it’s guaranteed to be the specified  size.  In the second version, the vector elements are  initialized to the value specified by the second parameter.  Elements are added to and removed from the end of the  vector, so you can’t use resize to add elements to or remove  elements from the start of the vector</td>
</tr>
<tr>
<td>void push_back();</td>
<td>myVector.push_back(100); Appends an element to the vector</td>
</tr>
<tr>
<td>T&amp; back(); const T&amp; back() const;</td>
<td>myVector.back() &#x3D; 5; int lastElem &#x3D; myVector.back(); Returns a reference to the last element in the vector.</td>
</tr>
</tbody></table>
<p>续表：</p>
<table>
<thead>
<tr>
<th>T&amp; front(); const T&amp; front() const;</th>
<th>myVector.front() &#x3D; 0; int firstElem &#x3D; myVector.front(); Returns a reference to the first element in the vector.</th>
</tr>
</thead>
<tbody><tr>
<td>void pop_back();</td>
<td>myVector.pop_back(); <br /> Removes the last element from the vector.</td>
</tr>
<tr>
<td>iterator begin(); const_iterator begin() const;</td>
<td>vector:: iterator itr &#x3D; myVector.begin(); <br /> Returns an iterator that points to the first element in the  vector</td>
</tr>
<tr>
<td>iterator end(); const_iterator end() const;</td>
<td>while(itr !&#x3D; myVector.end()); <br /> Returns an iterator to the element after the last.  The  iterator returned by end does not point to an element in the  vector.</td>
</tr>
<tr>
<td>iterator insert(iterator position,                 const T&amp; value); void insert(iterator start,             size_type numCopies,             const T&amp; value);</td>
<td>myVector.insert(myVector.begin() + 4, “Hello”); myVector.insert(myVector.begin(), 2, “Yo!”); <br /> The first version inserts the specified value into the vector,  and the second inserts numCopies copies of the value into  the vector.  Both calls invalidate all outstanding iterators for  the vector.</td>
</tr>
<tr>
<td>iterator erase(iterator position); iterator erase(iterator start,               iterator end);</td>
<td>myVector.erase(myVector.begin()); <br /> myVector.erase(startItr, endItr); <br /> The first version erases the element at the position pointed  to by position.  The second version erases all elements in the  range [startItr, endItr).  Note that this does not erase  the element pointed to by endItr.  All iterators after the  remove point are invalidated.  If using this member  function on a deque (see below), all iterators are  invalidated.</td>
</tr>
</tbody></table>
<h2 id="Deque"><a href="#Deque" class="headerlink" title=" Deque "></a><span style="font-size:1.2em;"> <strong>Deque</strong> </span></h2><p>称作 double_end_queue。也就是双端队列和 vector 相较有许多类似的操作，比如 resize，push.back 等。但是与 vector 最大的不同是，在 STL 实现的储存空间是不连续的大片“page”，而 vector 的是连续的空间.</p>
<p><img src="E:\Blog\source_posts\assets\image-20240320165928508-1713452721015-1.png" alt="image-20240320165928508"></p>
<p>优点：(1) 随机访问方便，即支持 [ ] 操作符和 vector.at()<br>      (2) 在内部方便的进行插入和删除操作<br>      (3) 可在两端进行 push、pop</p>
<p>缺点：占用内存多</p>
<h1 id="四个新的容器类"><a href="#四个新的容器类" class="headerlink" title="四个新的容器类"></a>四个新的容器类</h1><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>设想一个程序，它能计算出连续扔骰子，直到扔出的点数与第一次相同时所需的次数，以下是采用向量的实现方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//摇骰子</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DieRoll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">rand</span>() %<span class="number">6</span>) +<span class="number">1</span>; <span class="comment">//确保返回是一到六的整数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RunProcess</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; generate;  <span class="comment">//储存重复前摇出的数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> NextVaule = <span class="built_in">DieRoll</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> k =<span class="number">0</span> ; k &lt; generate.<span class="built_in">size</span>(); ++k)&#123;</span><br><span class="line">            <span class="keyword">if</span> (generate[k] == NextVaule)&#123; <span class="comment">//满足说明已经重复了</span></span><br><span class="line">                <span class="keyword">return</span> generate.<span class="built_in">size</span>() + <span class="number">1</span>; <span class="comment">//加一是为了返还摇动的总次数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    generate.<span class="built_in">push_back</span>(NextVaule);    <span class="comment">//不是就把数字保存进去</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> kNumIterations = <span class="number">10000</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span>&gt;(<span class="built_in">time</span>(<span class="literal">NULL</span>)));</span><br><span class="line">    <span class="type">float</span> total2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span> ; i&lt; kNumIterations ; ++i)&#123;</span><br><span class="line">        <span class="type">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> k = <span class="number">0</span>; k&lt; kNumIterations ;++k)&#123;</span><br><span class="line">            total += <span class="built_in">RunProcess</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    total2 += <span class="built_in">float</span>(total) / kNumIterations;</span><br><span class="line">    </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ultimate unswer is &quot;</span> &lt;&lt; total2 / kNumIterations &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们扔常见的六面骰子时，结果似乎很合理：</p>
<p><img src="E:\Blog\source_posts\assets\image-20240408110931050-1713452721015-2.png" alt="image-20240408110931050"></p>
<p>当重复次数增加这个数字的精度也会变大。但是如果我们扔的是个八面骰子呢？</p>
<p><img src="E:\Blog\source_posts\assets\image-20240408111044967-1713452721015-4.png" alt="image-20240408111044967"></p>
<p>到重复时所需要的数字并没增大许多。那要是我们正在玩博德之门3，需要连续过两个高难检定呢？</p>
<p><img src="E:\Blog\source_posts\assets\image-20240408111222882-1713452721015-3.png" alt="image-20240408111222882"></p>
<p>仅仅需要大概6次就可以重复？？虽然这是个概率论问题，但我们可以注意到我们所使用的容器——向量。答案在于 RunProcess 函数的实现。此函数的核心是一个 for 循环，用于检查向量中是否包含特定值。直观地说，向量保持元素的有序序列。对向量的主要操作通过在该序列中添加和删除元素、查找该序列中特定位置的元素等来维护该序列。对于此应用程序，我们希望存储一个无序的数字集合。我们不关心元素何时被添加到向量中或它们占据什么位置。相反，我们感兴趣的是向量中有哪些元素，特别是给定的元素是否在向量中。</p>
<h2 id="容器-set"><a href="#容器-set" class="headerlink" title="容器:set"></a>容器:set</h2><p>当元素集合的内容比元素所在的容器内的实际序列更重要时，便可以采用set容器。跟向量相比，set提供了一个任意的，无序的特殊容器，并且对以下的操作有很好的支持：</p>
<ul>
<li><p>将元素添加到集合中</p>
</li>
<li><p>从集合中删去元素</p>
</li>
<li><p>确认集合中是否包含特定元素</p>
<p>回到引子中那个问题，尝试用set来替换使用过向量的部分：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">RunProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       set&lt;<span class="type">int</span>&gt; generated;</span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="type">int</span> nextValue = <span class="built_in">DieRoll</span>();</span><br><span class="line">           <span class="comment">/* Check if this value has been rolled before. */</span></span><br><span class="line">           <span class="keyword">if</span> (generated.<span class="built_in">count</span>(nextValue)) <span class="keyword">return</span> generated.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">           <span class="comment">/* Otherwise, add this value to the set. */</span></span><br><span class="line">generated.<span class="built_in">insert</span>(nextValue);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>运行后的结果还是大差不差。</p>
<h3 id="set的基本操作"><a href="#set的基本操作" class="headerlink" title="set的基本操作"></a>set的基本操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容器之间的操作大多具有相似性</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; myset;</span><br><span class="line">    <span class="comment">//插入元素</span></span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="number">124</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="number">125</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="number">14</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="number">1324</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//检查元素是否在集合中</span></span><br><span class="line">    <span class="keyword">if</span>(myset.<span class="built_in">count</span>(<span class="number">1</span>))&#123;cout&lt;&lt; <span class="string">&quot;there is it&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="keyword">if</span>(!myset.<span class="built_in">count</span>(<span class="number">1000</span>))&#123;cout &lt;&lt; <span class="string">&quot;there is not it&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="comment">//删除集合中元素</span></span><br><span class="line">    myset.<span class="built_in">erase</span>(<span class="number">125</span>);</span><br><span class="line">    <span class="comment">//也可以使用clear来清除元素，size来查看容器大小，等等类似操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器初探"><a href="#迭代器初探" class="headerlink" title="迭代器初探"></a>迭代器初探</h3><h4 id="为什么要使用迭代器？"><a href="#为什么要使用迭代器？" class="headerlink" title="为什么要使用迭代器？"></a>为什么要使用迭代器？</h4><p>在最开始的C语言学习中，我们就已经习惯了用for循环来遍历数组的操作。这当然是一个很简洁方便的方法，但假如我们要遍历的容器不是数组呢？甚至这个容器不存在自带的顺序呢？（就如刚才提到的set），这时候再使用for循环就显得力不从心了。但是对于用迭代器来说刚好。如下所示：</p>
<h4 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">9</span>,<span class="number">564</span>,<span class="number">94</span>,<span class="number">71</span>,<span class="number">62</span>,<span class="number">6933</span>,<span class="number">122</span>,<span class="number">47</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator itr = myVector.<span class="built_in">begin</span>();</span><br><span class="line">    itr != myVector.<span class="built_in">end</span>();++itr)&#123;</span><br><span class="line">        cout &lt;&lt; *itr &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>到这里还有一个问题，就是当遇见无序容器时，迭代器遍历的顺序是如何的？当使用向量或 deque 时，有一个自然的迭代顺序（从序列的开始到结束），但是当使用 STL 集时，排序的概念有点模糊。但是，<strong>集合的迭代顺序是明确指定的。通过迭代器遍历集合元素时，将按排序顺序访问元素，从最小的元素开始，到最大的元素结束</strong>。这在一定程度上解释了为什么 STL 集合只能存储使用 less-than 运算符可比较的元素：如果无法比较元素，则集合中没有明确定义的“最小”或“最大”元素。若要查看其实际操作，请考虑以下代码片段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 生成随机数 */</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt; randomNumbers;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++k)</span><br><span class="line">        randomNumbers.<span class="built_in">insert</span>(<span class="built_in">rand</span>());</span><br><span class="line">    <span class="comment">/* 顺序打印集合内容 */</span></span><br><span class="line">    <span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator itr = randomNumbers.<span class="built_in">begin</span>(); </span><br><span class="line">         itr != randomNumbers.<span class="built_in">end</span>(); ++itr)</span><br><span class="line">        cout &lt;&lt; *itr &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>正如刚才所做到的，使用迭代器有三个主要操作：</p>
<ul>
<li><strong>取消迭代器的引用</strong></li>
<li><strong>将迭代器从一个位置推进到另外一个位置</strong></li>
<li><strong>比较两个迭代器是否相等</strong></li>
</ul>
<p>迭代器的功能当然不止读取内容，也能写入内容，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator ite = myVector.<span class="built_in">begin</span>();</span><br><span class="line">    ite != myVector.<span class="built_in">end</span>(); ++ite)</span><br><span class="line">    myVector.<span class="built_in">insert</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>由于迭代器提供了一种间接读取和写入容器元素的方法，因此可以通过操作容器类中的迭代器来编写对任何容器类中的数据进行操作的函数。这些函数称为 STL 算法。</p>
<p>现在让我们尝试一下用迭代器对字符串类型的容器进行操作。假设我们想要打印某个字符串向量的所有元素的长度，我们很可能会这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (set&lt;string&gt;::iterator itr = mySet.<span class="built_in">begin</span>(); itr != mySet.<span class="built_in">end</span>(); ++itr)</span><br><span class="line">        cout &lt;&lt; *itr.<span class="built_in">length</span>() &lt;&lt; endl; <span class="comment">// Error: Incorrect syntax!</span></span><br></pre></td></tr></table></figure>

<p>原因是编译器把我们的代码理解成了<code>\*(itr.length())</code>而不是<code>(*itr).length()</code>。</p>
<p>为了解决此问题，所有 STL 迭代器都支持并调用了箭头运算符，该运算符允许您在当前正在迭代的元素上调用成员函数。例如，要打印出集合中所有字符串的长度<string>，正确的语法是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (set&lt;string&gt;::iterator itr = mySet.<span class="built_in">begin</span>(); itr != mySet.<span class="built_in">end</span>(); ++itr)</span><br><span class="line">       cout &lt;&lt; itr-&gt;<span class="built_in">length</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h3 id="迭代的范围定义"><a href="#迭代的范围定义" class="headerlink" title="迭代的范围定义"></a>迭代的范围定义</h3><p>容易注意到我们之前的循环控制是靠 <code>mySet.begin()</code>与 <code>mySet.end()</code>。前者指定迭代范围开始的第一个元素，后者定义迭代范围末尾的元素。单个迭代器指向容器类中的单个位置，并表示间接读取或写入该值的方法。一对迭代器定义两个位置，从而定义一系列元素。具体而言，给定两个迭代器 start 和 stop，这些迭代器定义从 start 开始到停止前一个位置结束的元素范围。使用数学符号，由开始和停止跨度定义的元素范围 [start， stop)。</p>
<p>由于集合本身把元素按顺序排列的性质，我们可以尝试：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt;::iterator stop = mySet.<span class="built_in">upper_bound</span>(<span class="number">100</span>);</span><br><span class="line">   <span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator itr = mySet.<span class="built_in">lower_bound</span>(<span class="number">10</span>); itr != stop; ++itr)</span><br><span class="line">       cout &lt;&lt; *itr &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p><strong>upper_bound</strong> 和 <strong>lower_bound</strong> 的美妙之处在于，指定为函数参数的元素是否实际存在于集合中并不重要(假如要求的元素不存在就会直接返还到开头或者末尾)。例如，假设我们在包含 3 到 137 之间的所有奇数的集合上运行上述 for 循环。在本例中，集合中既不包含 10 也不包含 100。但是，代码仍将正常工作。lower_bound 函数向第一个元素返回一个迭代器，其大小至少与其参数一样大，并且在奇数集中将向元素 11 返回一个迭代器。类似地，upper_bound 向第一个元素返回一个迭代器，严格大于其参数，因此将向元素 101 返回一个迭代器。</p>
<h3 id="集合的常用函数"><a href="#集合的常用函数" class="headerlink" title="集合的常用函数"></a>集合的常用函数</h3><table>
<thead>
<tr>
<th>Constructor: set<T>()</th>
<th>set<int> mySet; 构造一个空集合。</th>
</tr>
</thead>
<tbody><tr>
<td>Constructor: set<T>(const set<T>&amp; other)</td>
<td>set<int> myOtherSet &#x3D; mySet; 构造一个另一个集合的副本。</td>
</tr>
<tr>
<td>Constructor: set<T>(InputIterator start, InputIterator stop)</td>
<td>set<int> mySet(myVec.begin(), myVec.end()); 构造一个包含特定范围（[start, stop)）内元素的副本的集合。任何重复的元素都将被丢弃，并且元素将被排序。注意，这个函数接受来自任何来源的迭代器。</td>
</tr>
<tr>
<td>size_type size() const</td>
<td>int numEntries &#x3D; mySet.size(); 返回集合中包含的元素数量</td>
</tr>
<tr>
<td>bool empty() const</td>
<td>if(mySet.empty()) { … } 返回集合是否为空。</td>
</tr>
<tr>
<td>void clear()</td>
<td>mySet.clear(); 从集合中移除所有元素。</td>
</tr>
<tr>
<td>iterator begin() const_iterator begin() const</td>
<td>set<int>::iterator itr &#x3D; mySet.begin(); 返回一个迭代器指向集合的开始。在就地修改元素时要小心。</td>
</tr>
<tr>
<td>iterator end() const_iterator end() const</td>
<td>while(itr !&#x3D; mySet.end()) { … } 返还迭代器到最后一个元素后面</td>
</tr>
<tr>
<td>insert(const T&amp; value)</td>
<td>第一个版本将指定的值插入集合中。返回类型是一个包含指向元素的迭代器和一个bool值的对，bool值指示元素是否成功插入（真）或者是否已经存在（假）。</td>
</tr>
<tr>
<td>void insert(InputIterator begin, InputIterator end)</td>
<td>第二个版本将指定范围的元素插入集合中，忽略重复项。</td>
</tr>
<tr>
<td>const_iterator find(const T&amp; element) const</td>
<td>如果指定元素存在，则返回指向该元素的迭代器；否则，返回end。</td>
</tr>
<tr>
<td>size_type count(const T&amp; item) const</td>
<td>如果指定元素包含在集合中，则返回1；否则，返回0。</td>
</tr>
<tr>
<td>size_type erase(const T&amp; element) void erase(iterator itr); void erase(iterator start, iterator stop);</td>
<td>从集合中移除一个元素。在第一个版本中，如果找到指定元素，则将其移除，并且如果元素被移除则函数返回1，如果元素不在集合中则返回0。第二个版本移除itr指向的元素。最后一个版本擦除[start, stop)范围内的元素。</td>
</tr>
<tr>
<td>iterator lower_bound(const T&amp; value)</td>
<td>返回指向第一个大于或等于指定值的元素的迭代器。这个函数对于获取一系列元素的迭代器特别有用，尤其是与upper_bound一起使用时。</td>
</tr>
<tr>
<td>iterator upper_bound(const T&amp; value)</td>
<td>返回指向第一个大于指定值的元素的迭代器。因为这个元素必须严格大于指定值，你可以迭代一个范围，直到迭代器等于upper_bound，以获得所有小于或等于参数的元素。</td>
</tr>
</tbody></table>
<h2 id="容器-Map"><a href="#容器-Map" class="headerlink" title="容器:Map"></a>容器:Map</h2><h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><p>pair 是一个参数化类，它只保存两个任意类型的值。其中定义的 <code>pair &lt;utility&gt;</code>接受两个模板参数。定义的声明是：  <code>pair&lt;TypeOne, TypeTwo&gt;</code>。如下示范：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//基本操作</span><br><span class="line">pair&lt;int, string&gt; myPair;</span><br><span class="line">	myPair.first  =  137;</span><br><span class="line">   myPair.second = &quot;C++ is awesome!&quot;;</span><br><span class="line">   //动态设置</span><br><span class="line">    pair&lt;int, string&gt; myPair = make_pair(137, &quot;string!&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="Map的基本操作"><a href="#Map的基本操作" class="headerlink" title="Map的基本操作"></a>Map的基本操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>,string&gt; mymap;</span><br><span class="line">    mymap[<span class="number">0</span>] = <span class="string">&quot;zero&quot;</span>;</span><br><span class="line">    mymap[<span class="number">1</span>] = <span class="string">&quot;one&quot;</span>;</span><br><span class="line">    mymap[<span class="number">2</span>] = <span class="string">&quot;two&quot;</span>;</span><br><span class="line">    mymap[<span class="number">3</span>] = <span class="string">&quot;three&quot;</span>;</span><br><span class="line">    cout &lt;&lt; mymap[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; mymap[<span class="number">99</span>] &lt;&lt; endl;<span class="comment">//假如调用一个没有的键值对，那么map会自动创建对应的键，并把其对应的值初始化int类型的是0,string是&quot;&quot;</span></span><br><span class="line">    <span class="comment">//对MAP使用迭代器</span></span><br><span class="line">    map&lt;<span class="type">int</span>,string&gt;::iterator itr = mymap.<span class="built_in">find</span>(<span class="number">13</span>); <span class="comment">//find()可以寻找map类型里的键</span></span><br><span class="line">    <span class="keyword">if</span>(itr == mymap.<span class="built_in">end</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到对应键&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;存在key是&quot;</span> &lt;&lt; itr-&gt;first &lt;&lt; <span class="string">&quot;，值是&quot;</span> &lt;&lt; itr-&gt;second &lt;&lt; <span class="string">&quot;的数据&quot;</span> &lt;&lt; endl; <span class="comment">//迭代器访问地图的方式</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//迭代map</span></span><br><span class="line">    <span class="keyword">for</span>(map&lt;<span class="type">int</span>,string&gt;::iterator itr = mymap.<span class="built_in">begin</span>();itr != mymap.<span class="built_in">end</span>() ; itr++)&#123;</span><br><span class="line">        cout &lt;&lt; itr-&gt;first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; itr-&gt;second &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    mymap.<span class="built_in">erase</span>(<span class="number">99</span>);<span class="comment">//键不能更改但是可以删除</span></span><br><span class="line">    <span class="comment">//mymap.clear();//删除所有键值对</span></span><br><span class="line">    <span class="comment">//mymap.size(); //获取键值对数目</span></span><br><span class="line"></span><br><span class="line">    mymap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">4</span>,<span class="string">&quot;four&quot;</span>));<span class="comment">//利用insert函数进行插入</span></span><br><span class="line">    mymap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">5</span>,<span class="string">&quot;five&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，map的底层逻辑和set一样是平衡二叉树实现的，所以用迭代器输出时是按从小到大的排列顺序。即使是string类的输出也会按照字母表的顺序。</p>
<h3 id="在Map中使用-insert-需要注意"><a href="#在Map中使用-insert-需要注意" class="headerlink" title="在Map中使用 insert()需要注意"></a>在Map中使用 <code>insert()</code>需要注意</h3><p>如上所示，map的<code>insert()</code> 与集合的插入函数一样，只需要指定要插入的内容使用即可，因为映射与集合一样，不会按特定顺序存储值。但是，由于映射将元素存储为键&#x2F;值对，因此插入函数的参数应为包含键和值的对对象。</p>
<p>下面请考虑以下两个向map中添加键值对的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Populate a map using [ ] */</span></span><br><span class="line">    map&lt;string, string&gt; one;</span><br><span class="line">    one[<span class="string">&quot;C++&quot;</span>] = <span class="string">&quot;sad&quot;</span>;</span><br><span class="line">    one[<span class="string">&quot;C++&quot;</span>] = <span class="string">&quot;happy&quot;</span>;</span><br><span class="line"><span class="comment">/* Populate a map using insert */</span></span><br><span class="line">    map&lt;string, string&gt; two;</span><br><span class="line">    two.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;C++&quot;</span>, <span class="string">&quot;sad&quot;</span>));</span><br><span class="line">    two.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;C++&quot;</span>, <span class="string">&quot;happy&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>运行后结果：</p>
<p><img src="E:\Blog\source_posts\assets\image-20240417164442494-1713452721015-5.png" alt="image-20240417164442494"></p>
<p>为什么会出现这种情况呢？原因是：map和set相似，key一旦被创建就不能再进行修改，而使用方括号对map进行的更新都是永久性的。当检测到后续增加的key与已有的重复时，会对原有的值进行覆盖。但是insert函数就没有这种权限，遇见已有的键时不能进行修改。也不会更新与现有键关联的值。为了缓解这种情况，我们可以</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Try to insert normally. */</span></span><br><span class="line">pair&lt;map&lt;string, <span class="type">int</span>&gt;::iterator, <span class="type">bool</span>&gt; result = </span><br><span class="line">       myMap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;STL&quot;</span>, <span class="number">137</span>));</span><br><span class="line"><span class="comment">/* If insertion failed, manually set the value. */</span></span><br><span class="line"><span class="keyword">if</span>(!result.second)</span><br><span class="line">       result.first-&gt;second = <span class="number">137</span>;</span><br></pre></td></tr></table></figure>

<p>解释一下上面的代码，在 C++ 中，<code>std::map::insert</code> 方法在插入元素时返回一个 <code>pair</code> 对象，这个 <code>pair</code> 对象包含两个部分：</p>
<ol>
<li><strong>第一个部分</strong>：一个迭代器，指向插入的元素或者已经存在于 <code>std::map</code> 中具有相同键的元素。如果插入成功，则这个迭代器指向新插入的元素；如果插入失败（因为键已存在），则这个迭代器指向已经存在的元素。</li>
<li><strong>第二个部分</strong>：一个布尔值，表示插入操作的结果。如果插入成功，则为 <code>true</code>；如果插入失败（因为键已存在），则为 <code>false</code>。</li>
</ol>
<p>这样的设计允许开发者在执行插入操作后，通过一个函数调用同时获得插入位置的迭代器和插入操作的结果。这在处理插入可能失败的情况时非常方便，因为我们可以根据插入的结果来决定下一步的操作，而不需要额外的查找操作。如果插入失败，即键已存在，通过 <code>result.first</code> 可以获取到已存在的元素的迭代器，然后可以在其上进行操作，如更新其值。</p>
<h3 id="Map的常用函数"><a href="#Map的常用函数" class="headerlink" title="Map的常用函数"></a>Map的常用函数</h3><table>
<thead>
<tr>
<th>函数&#x2F;方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>map&lt;K, V&gt;()</code></td>
<td>构造一个空的 map。</td>
</tr>
<tr>
<td><code>map&lt;K, V&gt;(const map&lt;K, V&gt;&amp; other)</code></td>
<td>构造一个其他 map 的副本。</td>
</tr>
<tr>
<td><code>map&lt;K, V&gt;(InputIterator start, InputIterator stop)</code></td>
<td>构造一个包含指定范围元素副本的 map，任何重复的元素都会被丢弃，并且元素会被排序。注意，此函数接受来自任何来源的迭代器，但它们必须是对键值对的迭代器。</td>
</tr>
<tr>
<td><code>size_type size() const</code></td>
<td>返回 map 中包含的元素数量。</td>
</tr>
<tr>
<td><code>bool empty() const</code></td>
<td>返回 map 是否为空。</td>
</tr>
<tr>
<td><code>void clear()</code></td>
<td>从 map 中移除所有元素。</td>
</tr>
<tr>
<td><code>iterator begin()</code></td>
<td><code>const_iterator begin() const</code> 返回指向 map 开始的迭代器。</td>
</tr>
<tr>
<td><code>iterator end()</code></td>
<td><code>const_iterator end() const</code> 返回指向 map 结束后一个元素的迭代器。</td>
</tr>
<tr>
<td><code>pair&lt;iterator, bool&gt; insert(const pair&lt;const K, V&gt;&amp; value)</code></td>
<td>插入指定的键值对到 map 中。返回一个 pair，包含一个指向元素的迭代器和一个表示插入是否成功的布尔值。</td>
</tr>
<tr>
<td><code>void insert(InputIterator begin, InputIterator end)</code></td>
<td>插入指定范围的元素到 map 中，忽略重复元素。</td>
</tr>
<tr>
<td><code>V&amp; operator[] (const K&amp; key)</code></td>
<td>返回与指定键关联的值，如果键不存在，则创建一个新的键值对，并将值初始化为零（如果它是原始类型）或默认值（对于非原始类型）。</td>
</tr>
</tbody></table>
<p>续表：</p>
<table>
<thead>
<tr>
<th>函数&#x2F;方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>iterator find(const K&amp; element)</code></td>
<td><code>const_iterator find(const K&amp; element) const</code> 如果存在指定键的键值对，则返回指向其的迭代器，否则返回 <code>end</code> 迭代器。</td>
</tr>
<tr>
<td><code>size_type count(const K&amp; item)</code></td>
<td>返回在 map 中具有指定键的键值对的数量。如果存在，返回 1，否则返回 0。</td>
</tr>
<tr>
<td><code>size_type erase(const K&amp; element)</code></td>
<td>移除具有指定键的键值对。第一版本中，如果找到具有指定键的键值对，则将其移除，并返回 1；否则返回 0。</td>
</tr>
<tr>
<td><code>void erase(iterator itr)</code></td>
<td>移除由迭代器 <code>itr</code> 指向的键值对。</td>
</tr>
<tr>
<td><code>void erase(iterator start, iterator stop)</code></td>
<td>移除指定范围内的键值对，范围为 <code>[start, stop)</code>。</td>
</tr>
<tr>
<td><code>iterator lower_bound(const K&amp; value)</code></td>
<td>返回一个指向第一个键值对的迭代器，其键大于或等于指定值。此函数可用于获取一系列元素的迭代器，特别是与 <code>upper_bound</code> 结合使用。</td>
</tr>
<tr>
<td><code>iterator upper_bound(const K&amp; value)</code></td>
<td>返回一个指向第一个键值对的迭代器，其键严格大于指定值。因为这个元素必须严格大于指定值，所以可以在迭代器等于 <code>upper_bound</code> 之前迭代一个范围，以获取所有小于或等于参数的元素。</td>
</tr>
</tbody></table>
<h2 id="Practice-Problems"><a href="#Practice-Problems" class="headerlink" title="Practice Problems"></a>Practice Problems</h2><ol>
<li><p>您如何检查一个元素是否包含在STL set中？</p>
<ul>
<li>使用STL set的成员函数<code>count</code>来检查元素是否存在。如果元素存在，则<code>count</code>函数返回1；如果不存在，则返回0。</li>
</ul>
</li>
<li><p>对于STL set，存储的类型必须支持严格的弱序比较（<code>strict weak ordering</code>）。这意味着类型必须具有定义了小于运算符（<code>operator&lt;</code>）的排序规则。相比之下，vector或deque没有这个限制。</p>
</li>
<li><p>您如何将一个元素插入到一个集合中？如何从集合中移除一个元素？</p>
<ul>
<li>若要将元素插入到set中，可以使用成员函数<code>insert</code>。若要从集合中移除元素，可以使用成员函数<code>erase</code>。</li>
</ul>
</li>
<li><p>一个单一元素在set中可以存在多少个副本？在multiset中呢？</p>
<ul>
<li>在set中，由于元素必须唯一，因此只能有一个副本。而在multiset中，可以包含多个相同的元素。</li>
</ul>
</li>
<li><p>您如何迭代遍历set的内容？</p>
<ul>
<li>可以使用迭代器进行遍历，例如使用<code>begin()</code>和<code>end()</code>函数，或者使用范围循环（range-based loop）。</li>
</ul>
</li>
<li><p>您如何检查一个键是否包含在STL map中？</p>
<ul>
<li>使用STL map的成员函数<code>find</code>来检查键是否存在。如果键存在，<code>find</code>函数返回指向该键-值对的迭代器；如果不存在，则返回指向map末尾的迭代器。</li>
</ul>
</li>
<li><p>列举两种您可以向STL map中插入键&#x2F;值对的方法。</p>
<ul>
<li>可以使用<code>insert</code>函数插入键&#x2F;值对，或者使用下标运算符<code>[]</code>直接赋值。</li>
</ul>
</li>
<li><p>如果您使用方括号在STL map中查找与不存在的键关联的值会发生什么？如果使用<code>find</code>函数呢？</p>
<ul>
<li>如果使用方括号运算符<code>[]</code>查找不存在的键，则会在map中插入一个新的键-值对，值为默认值。而如果使用<code>find</code>函数，则返回指向map末尾的迭代器。</li>
</ul>
</li>
<li><p>回想一下，在迭代STL multiset的内容时，元素将按照排序顺序进行访问。利用这一特性，重写上一章的程序，该程序从用户处读取一系列数字，然后按排序顺序打印它们。为什么需要使用multiset而不是常规的set？</p>
<ul>
<li>使用multiset而不是set的原因是multiset允许存储多个相同的元素，因此可以按顺序保存重复的数字。</li>
</ul>
</li>
<li><p>两个集合的并集是包含在两个集合中至少一个集合中的元素的集合。编写一个函数Union，它接受两个set<int>，并返回它们的并集。</p>
</li>
<li><p>两个集合的交集是包含在两个集合中的元素的集合。编写一个函数Intersection，它接受两个set<int>，并返回它们的交集。</p>
</li>
<li><p>在本章中的早些时候，我们编写了一个程序，它连续掷骰子直到相同的数字连续出现两次，然后打印出投掷的次数。重写此程序，以便相同的数字必须连续出现三次才能终止该过程。当掷20面骰子时，您预计此过程将进行多少次？（提示：您可能希望从使用set切换到使用multiset。还要记住set的count函数和multiset的count函数之间的区别。）</p>
</li>
<li><p>正如本章中提到的，您可以使用lower_bound和upper_bound的组合来迭代闭区间[min，max]中的元素。使用这两个函数的什么组合可以用来迭代区间[min，max）？[min，max]和（min，max）呢？</p>
</li>
<li><p>编写一个函数NumberDuplicateEntries，它接受一个map&lt;string，string&gt;，并返回map中重复值的数量（即，map中具有相同值的键&#x2F;值对的数量）。</p>
</li>
<li><p>编写一个函数InvertMap，它接受一个map&lt;string, string&gt;作为输入，并返回一个multimap&lt;string, string&gt;，其中源map中的每对（键，值）在生成的multimap中都由（值，键）表示。为什么在这里使用multimap是必要的？您如何使用上一个问题中的NumberDuplicateEntries函数来确定是否可以将map反转为另一个map？</p>
</li>
</ol>
<p>使用multimap的原因是在原始映射中，键是唯一的，但值不一定是唯一的。当将键映射到值时，可能会出现多个键映射到相同的值的情况。因此，使用multimap允许我们将多个键映射到相同的值。我们可以使用NumberDuplicateEntries函数来检查源映射中是否存在重复的值。如果NumberDuplicateEntries返回0，则表示源映射中的值是唯一的，可以进行反转。</p>
<ol start="16">
<li>假设我们有两个名为one和two的map&lt;string, string&gt;。我们可以定义one和two的组合（表示为two ○ one）如下：对于任意字符串r，如果one[r]是s，且two[s]是t，则(two ○ one)[r] &#x3D; t。也就是说，在组合映射中查找元素x等效于在one中查找与x关联的值，然后在two中查找其关联的值。如果one不包含r作为键，或者one[r]不是two中的键，则(two ○ one)[r]是未定义的。</li>
</ol>
<p>​		编写一个名为ComposeMaps的函数，它接受两个map&lt;string, string&gt;，并返回一个包含它们组合的		map&lt;string, string&gt;。</p>
<ol start="17">
<li>（挑战问题！）编写一个函数PrintMatchingPrefixes，它接受一个set<string>和一个包含前缀的字符串，并打印出所有以该前缀开头的集合条目。您的函数应仅迭代最终打印出的条目。您可以假设前缀是非空的，仅由字母数字字符组成，并且应区分大小写。 （提示：在set<string>中，字符串按字典顺序排序，因此所有以“abc”开头的字符串将位于所有以“abd”开头的字符串之前。）</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://afogsheep.github.io/2024/03/04/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="We losers do nothing so winners keeping winning <br> </br> 仍在施工中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杜鹃声">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/04/hello-world/" class="post-title-link" itemprop="url">Hello_My_Blog</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-04 20:30:15" itemprop="dateCreated datePublished" datetime="2024-03-04T20:30:15+08:00">2024-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-30 19:50:54" itemprop="dateModified" datetime="2024-03-30T19:50:54+08:00">2024-03-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.😊</p>
<p>兜兜转转一个月终于把自己的博客搭建的可以见人了，虽然里面还没什么有用的信息，就暂且当作自己的一方天地，保存些计算机科学学习的过程。过些阵子回头看，能感叹时光不枉虚度。</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">We losers do nothing so winners keeping winning <br> </br> 仍在施工中</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">4</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">4</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  















  

  

</body>
</html>
