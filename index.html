<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 7.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-mac-osx.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"afogsheep.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="We losers do nothing so winners keeping winning   仍在施工中">
<meta property="og:type" content="website">
<meta property="og:title" content="杜鹃声">
<meta property="og:url" content="https://afogsheep.github.io/index.html">
<meta property="og:site_name" content="杜鹃声">
<meta property="og:description" content="We losers do nothing so winners keeping winning   仍在施工中">
<meta property="og:locale" content="zh_CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://afogsheep.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>杜鹃声</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">杜鹃声</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">此情可待成追忆，只是当时已惘然</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://afogsheep.github.io/2024/05/01/%E5%9B%9E%E6%96%87%E5%88%A4%E6%96%AD/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="We losers do nothing so winners keeping winning <br> </br> 仍在施工中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杜鹃声">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/05/01/%E5%9B%9E%E6%96%87%E5%88%A4%E6%96%AD/" class="post-title-link" itemprop="url">STL运用示例：回文判断</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-05-01 17:24:34" itemprop="dateCreated datePublished" datetime="2024-05-01T17:24:34+08:00">2024-05-01</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-03 22:23:03" itemprop="dateModified" datetime="2024-05-03T22:23:03+08:00">2024-05-03</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>是时候用一个简短的例子来结束短暂的STL学习了。</p>
<h2 id="回文"><a href="#回文" class="headerlink" title="回文"></a>回文</h2><p>回文是向前或向后阅读时相同的单词或短语，例如“racecar”或“Malayalam”。阅读回文时，习惯上会忽略空格、标点符号和大写字母，因此“Mr. Owl ate my metal worm”和“Go hang a salami! I’m a lasagna hog。”这两句话将被视为回文，</p>
<h2 id="判断实现"><a href="#判断实现" class="headerlink" title="判断实现"></a>判断实现</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsPalindrome</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt; input.<span class="built_in">size</span>() / <span class="number">2</span>; ++k)</span><br><span class="line">            <span class="keyword">if</span>(input[k] != input[input.<span class="built_in">length</span>() - <span class="number">1</span> – k])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>这种方法只需遍历字符串的前半部分，检查每个字符是否等于字符串另一半上的相应字符。作为一种可能是头一个出现在脑海里的方法，他并没有错，但是太不优雅了。让我们用STL的方法试试。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsPalindrome</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">    string reversed = input;</span><br><span class="line">	 <span class="built_in">reverse</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> reversed == input;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>这种方法看起来好多了，但需要我们创建字符串的副本，因此效率低于我们的原始实现。我们可以使用迭代器以某种方式模拟初始 for 循环的功能吗？答案是肯定的，多亏了reverse_iterators。每个 STL 容器类都导出一个类型reverse_iterator，该类型类似于迭代器，只是它向后遍历容器。正如 begin 和 end 函数定义容器上的迭代器范围一样，rbegin 和 rend 函数定义跨容器的reverse_iterator范围。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">isPalindrome</span><span class="params">(string input)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">equal</span>(input.<span class="built_in">begin</span>(),input.<span class="built_in">begin</span>()+ input.<span class="built_in">length</span>()/<span class="number">2</span>,input.<span class="built_in">rbegin</span>()); </span><br><span class="line">    <span class="comment">// rbegin()从end开始向前遍历</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上的这个代码一行即可实现判断的功能。</p>
<p>但这还不能正确处理大写、空格或标点符号。如何改进呢？让我们首先从字符串中剥离除字母字符之外的所有内容。对于此任务，我们可以使用 STL remove_if 算法，该算法接受迭代器范围和谓词作为输入，然后通过删除谓词返回 true 的所有元素来修改范围。与它的伙伴算法 remove 一样，remove_if 实际上并没有从序列中删除元素，因此我们需要在之后擦除剩余的元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsNotAlpha</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123; <span class="comment">//&lt;cctype&gt;</span></span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isalpha</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsPalindrome</span><span class="params">(string input)</span></span>&#123;</span><br><span class="line">        input.<span class="built_in">erase</span>(<span class="built_in">remove_if</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(), IsNotAlpha),input.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">transform</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(), input.<span class="built_in">begin</span>(), ::toupper);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">equal</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">begin</span>() + input.<span class="built_in">size</span>() / <span class="number">2</span>,input.<span class="built_in">rbegin</span>());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>在三行代码中，我们去除了字符串中所有不是字母的字符，将剩下的字符转换为大写，并返回字符串是否向前和向后相同。</p>
<p>的技术的力量。在结束这个例子之前，让我们考虑回文上的一个变体，我们检查短语中的单词是否向前和向后相同。例如，“Did mom pop?  Mom did!”是回文，无论是字母还是文字，而”This is this“是一个短语，它不是回文，而是回文。与常规回文一样，我们将忽略空格和标点符号，因此“It’s an its”算作单词回文，即使它使用了两种不同形式的单词 its&#x2F;it’s。我们上面使用的算法适用于整个string，我们可以修改它以逐字工作吗？</p>
<p>我们仍然要忽略空格、标点符号和大写字母，但现在需要将单词而不是字母视为有意义的单位。有许多可能的算法可以检查此属性，但有一种解决方案特别好。思路如下：</p>
<p>1.清理输入：去掉除字母和空格以外的所有内容，然后将结果转换为大写。</p>
<p>2.将输入分解为单词列表。</p>
<p>3.向前和向后返回列表是否相同</p>
<p>这是一个完整的代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cctype&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sstream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsNotAlphaOrSpace</span><span class="params">(<span class="type">char</span> ch)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !<span class="built_in">isalpha</span>(ch) &amp;&amp; !<span class="built_in">isspace</span>(ch);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsWordPalindrome</span><span class="params">(string input)</span> </span>&#123;</span><br><span class="line">        input.<span class="built_in">erase</span>(<span class="built_in">remove_if</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(), IsNotAlphaOrSpace),</span><br><span class="line">                    input.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">transform</span>(input.<span class="built_in">begin</span>(), input.<span class="built_in">end</span>(), input.<span class="built_in">begin</span>(), ::toupper);</span><br><span class="line">        <span class="function">stringstream <span class="title">tokenizer</span><span class="params">(input)</span></span>;</span><br><span class="line">        vector&lt;string&gt; tokens;</span><br><span class="line">        tokens.<span class="built_in">insert</span>(tokens.<span class="built_in">begin</span>(),</span><br><span class="line">                      <span class="built_in">istream_iterator</span>&lt;string&gt;(tokenizer),</span><br><span class="line">                      <span class="built_in">istream_iterator</span>&lt;string&gt;());</span><br><span class="line">        <span class="comment">// 手动检查单词列表是否为回文,书里的equal()可能出现问题，具体https://blog.csdn.net/qq_52828510/article/details/121213451?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522171454848816800184139758%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=171454848816800184139758&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-1-121213451-null-null.142</span></span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> end = input.<span class="built_in">length</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (start &lt; end) &#123;</span><br><span class="line">        <span class="keyword">if</span> (input[start] != input[end]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    string input;</span><br><span class="line">    <span class="built_in">getline</span>(cin,input);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">IsWordPalindrome</span>(input))&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;no&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="remove的使用介绍"><a href="#remove的使用介绍" class="headerlink" title="remove的使用介绍"></a>remove的使用介绍</h2><p>代码中，<code>input.erase(...)</code> 这一部分是用来清除字符串中不需要的字符。具体来说，它结合了 <code>remove_if</code> 函数和 <code>erase</code> 方法来实现这个功能。这里是它的工作原理详解：</p>
<ol>
<li><p><strong><code>remove_if</code> 函数</strong>：</p>
<ul>
<li><code>remove_if</code> 是 C++ STL (Standard Template Library) 中的一个函数，用于从一个容器中移除满足特定条件的元素。</li>
<li>这个函数接受三个参数：容器的开始迭代器、结束迭代器和一个谓词函数（即一个返回布尔值、决定元素是否应被移除的函数）。</li>
<li>在您的代码中，谓词函数是 <code>IsNotAlphaOrSpace</code>，它检查一个字符是否既不是字母也不是空格。如果字符不是字母也不是空格，谓词返回 <code>true</code>，表示该字符应被移除。</li>
<li><code>remove_if</code> 实际上并不直接删除元素，而是通过重排容器中的元素，将所有不应被移除的元素移到容器的开始部分，返回一个新的迭代器，指向重排后的最后一个有效元素的下一个位置。</li>
</ul>
</li>
<li><p><strong><code>erase</code> 方法</strong>：</p>
<ul>
<li>一旦 <code>remove_if</code> 完成了元素的重排，<code>erase</code> 方法被用来实际从容器中删除那些不需要的元素。</li>
<li><code>erase</code> 接受两个迭代器：开始和结束。在这里，它从 <code>remove_if</code> 返回的迭代器开始，到字符串的末尾。</li>
<li>这意味着所有从 <code>remove_if</code> 返回的迭代器到容器末尾的元素（即被标记为移除的元素）都将被从字符串中删除。</li>
</ul>
</li>
</ol>
<p>这样的组合使用<code>remove_if</code> 和 <code>erase</code> 被称为“擦除-删除”惯用法（Erase-Remove Idiom），是一种高效清理容器的方式。</p>
<h2 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h2><p>欢迎阅读我们的最新博客文章，在本文中，我们将深入探讨标准模板库（STL）算法的实用性及其功能。这篇文章采用问答形式，帮助程序员理解并最大限度地提高STL算法在编程实践中的效率。</p>
<p><strong>1. 为什么STL算法比手写循环更受推荐？</strong></p>
<ul>
<li><strong>性能优化</strong>：STL算法经过严格优化，能够比手写循环提供更好的性能。</li>
<li><strong>可读性和维护性</strong>：使用STL算法可以使代码更加清晰和易于维护。</li>
<li><strong>减少错误</strong>：STL算法减少了编程中常见的错误，如边界错误和指针错误。</li>
</ul>
<p><strong>2. STL算法中的_if后缀和_n后缀分别表示什么意思？</strong></p>
<ul>
<li><strong>_if后缀</strong>：表示算法版本接受一个谓词（条件函数），用于指定操作的条件。</li>
<li><strong>_n后缀</strong>：指算法接受一个额外的数量参数，用于指定操作的元素数量或范围。</li>
</ul>
<p><strong>3. STL迭代器有哪五种类别？</strong></p>
<ul>
<li><strong>输入迭代器</strong>：仅支持读取序列中的元素。</li>
<li><strong>输出迭代器</strong>：仅支持写入序列中的元素。</li>
<li><strong>前向迭代器</strong>：支持读写操作，并能多次遍历序列。</li>
<li><strong>双向迭代器</strong>：除了前向迭代器的功能外，还可以向后遍历。</li>
<li><strong>随机访问迭代器</strong>：支持直接访问任何元素，提供最灵活的访问方式。</li>
</ul>
<p><strong>4. 输入迭代器是否可以在需要前向迭代器的场合使用？反之亦然可以吗？</strong></p>
<ul>
<li><strong>输入迭代器用于前向迭代器</strong>：通常不可以，因为输入迭代器不支持多次遍历或双向移动。</li>
<li><strong>前向迭代器用于输入迭代器</strong>：可以，前向迭代器功能更全。</li>
</ul>
<p><strong>5. 为什么我们需要back_insert_iterator这类迭代器适配器？</strong></p>
<p>如果没有这些迭代器适配器，许多STL算法在处理需要动态添加元素到容器的情况时将无法工作，例如在使用<code>copy</code>算法时直接将元素添加到容器尾部。</p>
<p><strong>6. 如何修改代码以计算文件中25到75之间的值的平均数？</strong></p>
<p>首先使用<code>std::find_if</code>定位值在25到75之间的范围的迭代器，然后使用<code>std::accumulate</code>和<code>std::distance</code>计算这个范围的平均值。如果范围内没有元素，输出相应的消息。</p>
<p><strong>7.编写一个名为 <code>RemoveShortWords</code> 的函数，它接受一个 <code>vector&lt;string&gt;</code> 并移除其中所有长度为3或更短的字符串。</strong></p>
<p>（如果你正确地利用了算法，这个函数可以在两行代码内完成。）</p>
<p>这个问题可以通过结合使用 STL 的 <code>std::remove_if</code> 和 <code>erase</code> 方法解决。这里使用 <code>std::remove_if</code> 来标记所有应当被移除的元素，然后用 <code>erase</code> 实际移除这些元素。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">RemoveShortWords</span><span class="params">(std::vector&lt;std::string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> newEnd = std::<span class="built_in">remove_if</span>(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(),</span><br><span class="line">                                 [](<span class="type">const</span> std::string&amp; s) &#123; <span class="keyword">return</span> s.<span class="built_in">length</span>() &lt;= <span class="number">3</span>; &#125;);</span><br><span class="line">    words.<span class="built_in">erase</span>(newEnd, words.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注释</strong>:</p>
<ul>
<li><code>remove_if</code> 将遍历 <code>words</code> 向量，并应用 lambda 函数到每个字符串。</li>
<li>Lambda 函数检查字符串长度是否小于等于3，返回 <code>true</code> 表示该字符串应被移除。</li>
<li><code>remove_if</code> 将不应被移除的字符串移动到向量的前部，并返回一个新的结束迭代器。</li>
<li><code>erase</code> 使用这个新的结束迭代器，将所有被标记为移除的字符串从向量中删除。</li>
</ul>
<ol start="8">
<li>计算 n 维空间中点到原点的距离</li>
</ol>
<p><strong>问题</strong>: 在 n 维空间中，一个点 (x1, x2, x3, …, xn) 到原点的距离是 sqrt(x1^2 + x2^2 + x3^2 + … + xn^2)。编写一个函数 <code>DistanceToOrigin</code>，它接受一个代表空间中点的 <code>vector&lt;double&gt;</code>，并返回该点到原点的距离。不要使用任何循环，让算法为你完成繁重的工作。（提示：使用 <code>inner_product</code> 算法来计算平方根下的表达式。）</p>
<p>我们可以使用 <code>std::inner_product</code> 算法来计算向量元素的平方和，然后取平方根得到欧几里得距离。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span> <span class="comment">// For std::inner_product</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">DistanceToOrigin</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">double</span>&gt;&amp; point)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">sqrt</span>(std::<span class="built_in">inner_product</span>(point.<span class="built_in">begin</span>(), point.<span class="built_in">end</span>(), point.<span class="built_in">begin</span>(), <span class="number">0.0</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注释</strong>:</p>
<ul>
<li><code>std::inner_product</code> 计算两个序列的点积。这里我们使用同一个向量 <code>point</code> 两次，即计算每个维度的平方。</li>
<li>初始值 <code>0.0</code> 表示累加的起始值。</li>
<li>最终结果是所有维度平方和的平方根，即从原点到点的距离。</li>
</ul>
<ol start="9">
<li>实现一个具有偏好的排序函数 BiasedSort</li>
</ol>
<p><strong>问题</strong>: 编写一个名为 <code>BiasedSort</code> 的函数，它接受一个引用类型的 <code>vector&lt;string&gt;</code> 并按字典顺序对其进行排序，但如果向量中包含字符串 “Me First”，则该字符串始终位于排序列表的最前面。</p>
<p><strong>解决方案</strong>：</p>
<p>为了解决这个问题，我们可以首先检查是否存在 “Me First” 字符串，如果存在，则先将其移至向量的开始位置，然后对剩余的元素进行排序。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">BiasedSort</span><span class="params">(std::vector&lt;std::string&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> it = std::<span class="built_in">find</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), <span class="string">&quot;Me First&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (it != vec.<span class="built_in">end</span>()) &#123;</span><br><span class="line">        std::<span class="built_in">iter_swap</span>(vec.<span class="built_in">begin</span>(), it);</span><br><span class="line">        std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>() + <span class="number">1</span>, vec.<span class="built_in">end</span>());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::<span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注释</strong>:</p>
<ul>
<li>使用 <code>std::find</code> 查找 “Me First”，如果找到，则与第一个元素交换位置。</li>
<li>使用 <code>std::sort</code> 对除 “Me First” 外的所有元素进行排序。</li>
</ul>
<ol start="10">
<li>编写一个函数 CriticsPick</li>
</ol>
<p><strong>问题</strong>: 编写一个函数 <code>CriticsPick</code>，该函数接受一个 <code>map&lt;string, double&gt;</code>，其中包含电影及其评分（0.0 到 10.0之间），并返回一个 <code>set&lt;string&gt;</code>，其中包含地图中评分最高的前十部电影的名称。如果 map 中的元素少于十个，则结果 set 应包含 map 中的每个字符串。</p>
<p><strong>解决方案</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::set&lt;std::string&gt; <span class="title">CriticsPick</span><span class="params">(<span class="type">const</span> std::map&lt;std::string, <span class="type">double</span>&gt;&amp; movies)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;std::pair&lt;std::string, <span class="type">double</span>&gt;&gt; <span class="built_in">sortedMovies</span>(movies.<span class="built_in">begin</span>(), movies.<span class="built_in">end</span>());</span><br><span class="line">    std::<span class="built_in">sort</span>(sortedMovies.<span class="built_in">begin</span>(), sortedMovies.<span class="built_in">end</span>(), [](<span class="type">const</span> <span class="keyword">auto</span>&amp; a, <span class="type">const</span> <span class="keyword">auto</span>&amp; b) &#123;</span><br><span class="line">        <span class="keyword">return</span> a.second &gt; b.second;  <span class="comment">// 降序排序</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    std::set&lt;std::string&gt; topMovies;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; std::<span class="built_in">min</span>(<span class="number">10</span>, <span class="built_in">static_cast</span>&lt;<span class="type">int</span>&gt;(sortedMovies.<span class="built_in">size</span>())); ++i) &#123;</span><br><span class="line">        topMovies.<span class="built_in">insert</span>(sortedMovies[i].first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> topMovies;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注释</strong>:</p>
<ul>
<li>将 map 转换为 vector，以便使用排序算法。</li>
<li>按评分降序排序电影。</li>
<li>选取排序后的前10部电影（或者小于10部，如果元素不足的话）。</li>
</ul>
<ol start="11">
<li>实现 count 算法</li>
</ol>
<p><strong>问题</strong>: 为 <code>vector&lt;int&gt;</code> 实现 count 算法。你的函数应该有如下原型：<code>int count(vector&lt;int&gt;::iterator start, vector&lt;int&gt;::iterator stop, int element)</code>，并应该返回区间 [start, stop) 中等于 element 的元素数量。</p>
<p><strong>解决方案</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(std::vector&lt;<span class="type">int</span>&gt;::iterator start, std::vector&lt;<span class="type">int</span>&gt;::iterator stop, <span class="type">int</span> element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> std::<span class="built_in">count</span>(start, stop, element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注释</strong>:</p>
<ul>
<li>直接使用 STL 中的 <code>std::count</code> 函数，传递给定的迭代器和元素。</li>
</ul>
<ol start="12">
<li>使用 generate_n 和 rand 函数填充随机数向量，并计算平均值</li>
</ol>
<p><strong>问题</strong>: 使用 <code>generate_n</code> 算法、<code>rand</code> 函数和 <code>back_insert_iterator</code> 来填充一个向量，指定数量的随机值。然后使用 <code>accumulate</code> 计算该范围的平均值。</p>
<p><strong>解决方案</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span>  <span class="comment">// For rand()</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PopulateAndAverage</span><span class="params">(<span class="type">int</span> count)</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line">    std::<span class="built_in">generate_n</span>(std::<span class="built_in">back_inserter</span>(numbers), count, []() &#123; <span class="keyword">return</span> <span class="built_in">rand</span>() % <span class="number">100</span>; &#125;);</span><br><span class="line">    <span class="type">double</span> average = <span class="built_in">static_cast</span>&lt;<span class="type">double</span>&gt;(std::<span class="built_in">accumulate</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), <span class="number">0</span>)) / numbers.<span class="built_in">size</span>();</span><br><span class="line"></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Average: &quot;</span> &lt;&lt; average &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注释</strong>:</p>
<ul>
<li>使用 <code>generate_n</code> 和 <code>back_inserter</code> 向量填充随机数。<code>back_inserter</code> 创建一个后插迭代器，自动处理向量的大小调整。</li>
<li>随机数范围设置为 0 到 99。</li>
<li>使用 <code>accumulate</code> 计算总和，然后除以元素数量得到平均值。</li>
</ul>
<ol start="13">
<li>计算一组数据的中位数</li>
</ol>
<p><strong>问题</strong>: 中位数是指在一组数据中，有一半的数据比它大，另一半数据比它小。对于拥有奇数个元素的数据集，这是排序后的中间元素；对于偶数个元素的数据集，它是两个中间元素的平均值。使用 <code>nth_element</code> 算法编写一个计算数据集中位数的函数。</p>
<p><strong>解决方案</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">Median</span><span class="params">(std::vector&lt;<span class="type">double</span>&gt;&amp; data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">size_t</span> n = data.<span class="built_in">size</span>() / <span class="number">2</span>;</span><br><span class="line">    std::<span class="built_in">nth_element</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">begin</span>() + n, data.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (data.<span class="built_in">size</span>() % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> data[n];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> max_it = std::<span class="built_in">max_element</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">begin</span>() + n);</span><br><span class="line">        <span class="keyword">return</span> (*max_it + data[n]) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注释</strong>:</p>
<ul>
<li>使用 <code>nth_element</code> 定位中间元素，该算法可以更快地找到第 n 个位置的元素，而不需要完全排序。</li>
<li>对于偶数元素的数据集，找到前半部分的最大值，与中间位置的下一个元素求平均。</li>
</ul>
<ol start="14">
<li>使用 copy、istreambuf_iterator 和 ostreambuf_iterator 打开文件并打印其内容</li>
</ol>
<p><strong>问题</strong>: 展示如何使用 <code>copy</code>、<code>istreambuf_iterator</code> 和 <code>ostreambuf_iterator</code> 打开一个文件并将其内容打印到 cout。</p>
<p><strong>解决方案</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintFileContents</span><span class="params">(<span class="type">const</span> std::string&amp; filename)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ifstream <span class="title">file</span><span class="params">(filename)</span></span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(std::<span class="built_in">istreambuf_iterator</span>&lt;<span class="type">char</span>&gt;(file),</span><br><span class="line">              std::<span class="built_in">istreambuf_iterator</span>&lt;<span class="type">char</span>&gt;(),</span><br><span class="line">              std::<span class="built_in">ostreambuf_iterator</span>&lt;<span class="type">char</span>&gt;(std::cout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注释</strong>:</p>
<ul>
<li>使用 <code>istreambuf_iterator</code> 从文件读取字符。</li>
<li>使用 <code>ostreambuf_iterator</code> 将字符输出到标准输出。</li>
<li><code>copy</code> 算法在这两个迭代器之间传输内容，直接从文件流复制到输出流，无需额外缓存。</li>
</ul>
<ol start="15">
<li>使用 copy 和迭代器适配器将 STL 容器的内容写入文件</li>
</ol>
<p><strong>问题</strong>: 展示如何使用 <code>copy</code> 和迭代器适配器将 STL 容器的内容写入文件，其中每个元素存储在自己的一行上。</p>
<p><strong>解决方案</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">WriteToFile</span><span class="params">(<span class="type">const</span> std::vector&lt;T&gt;&amp; data, <span class="type">const</span> std::string&amp; filename)</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ofstream <span class="title">file</span><span class="params">(filename)</span></span>;</span><br><span class="line">    <span class="function">std::ostream_iterator&lt;T&gt; <span class="title">out_it</span><span class="params">(file, <span class="string">&quot;\n&quot;</span>)</span></span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), out_it);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><strong>注释</strong>:</p>
<ul>
<li>使用 <code>ostream_iterator</code> 定义输出到文件的迭代器，并设置每个元素后跟一个换行符。</li>
<li><code>copy</code> 算法用于从容器复制元素到文件流，每写入一个元素后自动插入一个换行符。</li>
</ul>
<ol start="16">
<li>打印两个已排序向量的共同元素</li>
</ol>
<p><strong>问题</strong>: 假设你有两个元素已经存储在排序顺序中的 <code>vector&lt;int&gt;</code>。展示如何使用一行代码通过 <code>set_intersection</code> 算法和适当的迭代器适配器打印出这两个向量的共有元素。</p>
<p><strong>解决方案</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PrintCommonElements</span><span class="params">(<span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; v1, <span class="type">const</span> std::vector&lt;<span class="type">int</span>&gt;&amp; v2)</span> </span>&#123;</span><br><span class="line">    std::<span class="built_in">set_intersection</span>(v1.<span class="built_in">begin</span>(), v1.<span class="built_in">end</span>(), v2.<span class="built_in">begin</span>(), v2.<span class="built_in">end</span>(),</span><br><span class="line">                          std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注释</strong>:</p>
<ul>
<li>使用 <code>set_intersection</code> 算法找出两个排序向量的共同元素。</li>
<li><code>ostream_iterator</code> 用于将找到的共同元素直接打印到标准输出，每个元素后面跟一个空格。</li>
</ul>
<p>这些示例展示了如何有效地利用 STL 算法和迭代器来简化常见的编程任务，同时保持代码的简洁和高效。通过这种方式，可以显著提升代码的可读性和维护性，同时利用现代 C++ 提供的强大功能来处理复杂的数据结构和算法操作。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://afogsheep.github.io/2024/04/25/XYCTF%20WP/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="We losers do nothing so winners keeping winning <br> </br> 仍在施工中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杜鹃声">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/25/XYCTF%20WP/" class="post-title-link" itemprop="url">XYCTF_WP</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-25 22:23:02" itemprop="dateCreated datePublished" datetime="2024-04-25T22:23:02+08:00">2024-04-25</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-01 16:27:00" itemprop="dateModified" datetime="2024-05-01T16:27:00+08:00">2024-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>咸鱼头一次做出比较多的比赛，学到了很多东西（虽然感觉应该早该会的），后面会逐步把没做出的re复现</p>
<h2 id="聪明的信使"><a href="#聪明的信使" class="headerlink" title="聪明的信使"></a>聪明的信使</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">int __cdecl encrypt(char *a1, int a2)</span><br><span class="line">&#123;</span><br><span class="line">  int result; // eax</span><br><span class="line">  char v3; // [esp+Bh] [ebp-5h]</span><br><span class="line">  int i; // [esp+Ch] [ebp-4h]</span><br><span class="line"></span><br><span class="line">  for ( i = 0; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    result = (unsigned __int8)a1[i];</span><br><span class="line">    if ( !(_BYTE)result )</span><br><span class="line">      break;</span><br><span class="line">    v3 = a1[i];</span><br><span class="line">    if ( v3 &lt;= 96 || v3 &gt; 122 )</span><br><span class="line">    &#123;</span><br><span class="line">      if ( v3 &gt; 64 &amp;&amp; v3 &lt;= 90 )</span><br><span class="line">        v3 = (v3 + a2 - 65) % 26 + 65;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">      v3 = (v3 + a2 - 97) % 26 + 97;</span><br><span class="line">    &#125;</span><br><span class="line">    a1[i] = v3;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>签到题，点开加密函数发现是凯撒密码，偏移量为9，使用逆向解密函数得解：</p>
<figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt_caesar</span>(<span class="params">encrypted_str, shift</span>):</span><br><span class="line">    decrypted_str = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> encrypted_str:</span><br><span class="line">        <span class="comment"># 确保字符是字母</span></span><br><span class="line">        <span class="keyword">if</span> char.isalpha():</span><br><span class="line">            <span class="comment"># 获取字符的ASCII码</span></span><br><span class="line">            ascii_offset = <span class="built_in">ord</span>(char)</span><br><span class="line">            <span class="comment"># 判断是大写还是小写字母</span></span><br><span class="line">            <span class="keyword">if</span> char.isupper():</span><br><span class="line">                <span class="comment"># 大写字母的ASCII范围是65-90</span></span><br><span class="line">                base = <span class="built_in">ord</span>(<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 小写字母的ASCII范围是97-122</span></span><br><span class="line">                base = <span class="built_in">ord</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line">                <span class="comment"># 执行解密操作</span></span><br><span class="line">            decrypted_char = <span class="built_in">chr</span>((ascii_offset - base - shift) % <span class="number">26</span> + base)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="comment"># 非字母字符不进行解密</span></span><br><span class="line">            decrypted_char = char</span><br><span class="line">            <span class="comment"># 将解密后的字符添加到结果字符串中</span></span><br><span class="line">        decrypted_str += decrypted_char</span><br><span class="line">    <span class="keyword">return</span> decrypted_str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">encrypted_str = <span class="string">&quot;oujp&#123;H0d_TwXf_Lahyc0_14_e3ah_Rvy0ac@wc!&#125;&quot;</span></span><br><span class="line">shift = -<span class="number">9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 解密字符串</span></span><br><span class="line">decrypted_str = decrypt_caesar(encrypted_str, -shift)</span><br><span class="line"><span class="built_in">print</span>(decrypted_str)</span><br><span class="line"><span class="comment"># flag&#123;Y0u_KnOw_Crypt0_14_v3ry_Imp0rt@nt!&#125;</span></span><br></pre></td></tr></table></figure>



<h2 id="喵喵喵的flag碎了一地"><a href="#喵喵喵的flag碎了一地" class="headerlink" title="喵喵喵的flag碎了一地"></a>喵喵喵的flag碎了一地</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">puts(&quot;Hint:&quot;);</span><br><span class="line">  puts(&quot;1. Open in IDA and Learn about `Strings` to find the first part of the flag&quot;);</span><br><span class="line">  puts(&quot;2. Learn about `Functions` to find the second part of the flag which is the name of a function&quot;);</span><br><span class="line">  puts(&quot;3. The hint for the last part is in the function you found in the second part&quot;);</span><br></pre></td></tr></table></figure>

<p>打开主函数发现hint。根据提示一步一步来。shift + F12发现目标字符串</p>
<p><code>flag&#123;My_fl@g_h4s_</code></p>
<p>在函数栏里搜索  <code>_</code> 发现第二段 <code>br0ken_4parT_</code></p>
<p>点进去后对函数头按下X发现引用路径 <code>int func718()</code>，转换成字符后发现不够，转换成汇编代码发现余下部分。结合得到flag: <code>flag&#123;My_fl@g_h4s_br0ken_4parT_f1x_1t!&#125;</code></p>
<h2 id="你真的是大学生吗"><a href="#你真的是大学生吗" class="headerlink" title="你真的是大学生吗"></a>你真的是大学生吗</h2><p>DIE查看发现是16位文件，无法运行。在ida里只能查看汇编代码和流程图。分析得知逻辑:输入的20个字符首先第零位和第19位进行异或，代替第十八位，19位和18位异或代替17位。。。以此类推将整个输入除了第19位全部替换。由于异或的逆运算是本身，所以得到解密脚本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 待比较的字节序列</span></span><br><span class="line">enc = [</span><br><span class="line">    <span class="number">0x76</span>, <span class="number">0x0E</span>, <span class="number">0x77</span>, <span class="number">0x14</span>, <span class="number">0x60</span>, <span class="number">0x06</span>, <span class="number">0x7D</span>, <span class="number">0x04</span>, <span class="number">0x6B</span>, <span class="number">0x1E</span>,</span><br><span class="line">    <span class="number">0x41</span>, <span class="number">0x2A</span>, <span class="number">0x44</span>, <span class="number">0x2B</span>, <span class="number">0x5C</span>, <span class="number">0x03</span>, <span class="number">0x3B</span>, <span class="number">0x0B</span>, <span class="number">0x33</span>, <span class="number">0x05</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">denc = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">19</span>):</span><br><span class="line">    denc.append(<span class="built_in">chr</span>(enc[i] ^ enc[i+<span class="number">1</span>]))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> denc:</span><br><span class="line">    <span class="built_in">print</span>(i,end=<span class="string">&#x27;&#x27;</span>)</span><br><span class="line"><span class="comment"># 最后一位为 &#x27;&#125;&#x27;</span></span><br><span class="line"><span class="comment"># flag: xyctf&#123;you_know_8086&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="DebugMe"><a href="#DebugMe" class="headerlink" title="DebugMe"></a>DebugMe</h2><p>jeb打开文件后分析java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view0)</span> &#123;</span><br><span class="line">              <span class="keyword">if</span>(Debug.isDebuggerConnected()) &#123;</span><br><span class="line">                  Toast.makeText(MainActivity.<span class="built_in">this</span>, What.x(<span class="string">&quot;WikFhRxyYjoSJ8mMbM3fRwty/74bc7Ip7ojqenHaSqc9wDv3JDG9XfV6xEiC7Eg1RWTUa4LaM%2BD0W%2BPKanSA5w==&quot;</span>), <span class="number">0</span>).show();</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              Toast.makeText(MainActivity.<span class="built_in">this</span>, <span class="string">&quot;flag呢&quot;</span>, <span class="number">0</span>).show();</span><br><span class="line">          &#125;</span><br></pre></td></tr></table></figure>

<p>发现关键部分，只要检测到调试就会自动解密就会弹出flag。用模拟器连接调试得到 flag: </p>
<h2 id="TrustMe"><a href="#TrustMe" class="headerlink" title="TrustMe"></a>TrustMe</h2><p>启动后需要输入用户名和密码。打开源码发现用户名是个RC4加密</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(MainActivity.bytesToHex(MainActivity.RC4(textView1.getText().toString().getBytes(), <span class="string">&quot;XYCTF&quot;</span>.getBytes())).equals(<span class="string">&quot;5a3c46e0228b444decc7651c8a7ca93ba4cb35a46f7eb589bef4&quot;</span>)) &#123;</span><br><span class="line">           Toast.makeText(<span class="built_in">this</span>, <span class="string">&quot;成功!&quot;</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>在线解密可得账户<code>The Real username is admin</code></p>
<p>接着查看剩下的类没有发现具体处理密码的痕迹。但是在 <code>ProxyApplication</code> 类中发现了文件读入读出，以及一个可疑的异或</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] decrypt(<span class="type">byte</span>[] arr_b) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">0</span>; v &lt; arr_b.length; ++v) &#123;</span><br><span class="line">            arr_b[v] = (<span class="type">byte</span>)(arr_b[v] ^ <span class="number">0xFF</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr_b;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>继续往下查看发现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">byte</span>[] readDexFileFromApk() <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">ByteArrayOutputStream</span> <span class="variable">byteArrayOutputStream0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">ZipInputStream</span> <span class="variable">zipInputStream0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipInputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="built_in">this</span>.getApplicationInfo().sourceDir)));</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">ZipEntry</span> <span class="variable">zipEntry0</span> <span class="operator">=</span> zipInputStream0.getNextEntry();</span><br><span class="line">            <span class="keyword">if</span>(zipEntry0 == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>

<p>百度后发现是加壳的方法，</p>
<p>继续往下发现最重要的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">splitPayloadFromDex</span><span class="params">(<span class="type">byte</span>[] arr_b)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">byte</span>[] arr_b1 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">4</span>];</span><br><span class="line">        System.arraycopy(arr_b, arr_b.length - <span class="number">4</span>, arr_b1, <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(arr_b1)).readInt();</span><br><span class="line">        <span class="type">byte</span>[] arr_b2 = <span class="keyword">new</span> <span class="title class_">byte</span>[v];</span><br><span class="line">        System.arraycopy(arr_b, arr_b.length - <span class="number">4</span> - v, arr_b2, <span class="number">0</span>, v);</span><br><span class="line">        <span class="type">byte</span>[] arr_b3 = <span class="built_in">this</span>.decrypt(arr_b2);</span><br><span class="line">        <span class="type">File</span> <span class="variable">file0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="built_in">this</span>.apkFileName);</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file0);</span><br><span class="line">        fileOutputStream0.write(arr_b3);</span><br><span class="line">        fileOutputStream0.close();</span><br><span class="line">        <span class="type">ZipInputStream</span> <span class="variable">zipInputStream0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ZipInputStream</span>(<span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file0)));</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">ZipEntry</span> <span class="variable">zipEntry0</span> <span class="operator">=</span> zipInputStream0.getNextEntry();</span><br><span class="line">            <span class="keyword">if</span>(zipEntry0 == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> zipEntry0.getName();</span><br><span class="line">            <span class="keyword">if</span>((s.startsWith(<span class="string">&quot;lib/&quot;</span>)) &amp;&amp; (s.endsWith(<span class="string">&quot;.so&quot;</span>))) &#123;</span><br><span class="line">                <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="built_in">this</span>.libPath + <span class="string">&quot;/&quot;</span> + s.substring(s.lastIndexOf(<span class="string">&quot;/&quot;</span>)));</span><br><span class="line">                file1.createNewFile();</span><br><span class="line">                <span class="type">FileOutputStream</span> <span class="variable">fileOutputStream1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file1);</span><br><span class="line">                <span class="type">byte</span>[] arr_b4 = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">0x400</span>];</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">v1</span> <span class="operator">=</span> zipInputStream0.read(arr_b4);</span><br><span class="line">                    <span class="keyword">if</span>(v1 == -<span class="number">1</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    fileOutputStream1.write(arr_b4, <span class="number">0</span>, v1);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                fileOutputStream1.flush();</span><br><span class="line">                fileOutputStream1.close();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            zipInputStream0.closeEntry();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        zipInputStream0.close();</span><br><span class="line">        zipInputStream0.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>百度函数名后发现类似题目： <code>[[原创\]安卓逆向之2016年华山杯CTF安卓writeUp-Android安全-看雪-安全社区|安全招聘|kanxue.com](https://bbs.kanxue.com/thread-218555.htm)</code></p>
<p><strong>通过以上分析，我们可以得到加壳了以后的apk的结构应该是：</strong><br>+——-+———–|——————+<br>+ 壳子 | 原始apk | 原始apk的长度 |<br>+ ——+———–+——————+</p>
<p>模仿java代码写出提取脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">new_byte</span>(<span class="params">path</span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        src_len = file.read()</span><br><span class="line"></span><br><span class="line">    decrypt_len = struct.unpack(<span class="string">&#x27;&gt;I&#x27;</span>, src_len[-<span class="number">4</span>:])[<span class="number">0</span>]</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;长度是：&#123;:x&#125;&quot;</span>.<span class="built_in">format</span>(decrypt_len))</span><br><span class="line"></span><br><span class="line">    new_dex_byte = src_len[-<span class="number">4</span> - decrypt_len:-<span class="number">4</span>]</span><br><span class="line"></span><br><span class="line">    decrypted_data = <span class="built_in">bytes</span>([b ^ <span class="number">0xFF</span> <span class="keyword">for</span> b <span class="keyword">in</span> new_dex_byte])</span><br><span class="line"></span><br><span class="line">    output_path = <span class="string">r&quot;G:\Chanllages\xyctf\notrust\new_write_dex.apk&quot;</span></span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(output_path, <span class="string">&#x27;wb&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">        file.write(decrypted_data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decrypted_data</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(sys.argv) &gt; <span class="number">1</span>:</span><br><span class="line">        path = sys.argv[<span class="number">1</span>]</span><br><span class="line">        new_byte(path)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;请提供Dex文件的路径！&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>打开提取后的apk文件终于发现hint所说的简单漏洞是什么了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MainActivity</span> <span class="keyword">extends</span> <span class="title class_">AppCompatActivity</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View view0)</span> &#123;</span><br><span class="line">        <span class="type">TextView</span> <span class="variable">textView0</span> <span class="operator">=</span> (TextView)<span class="built_in">this</span>.findViewById(id.username);</span><br><span class="line">        <span class="type">TextView</span> <span class="variable">textView1</span> <span class="operator">=</span> (TextView)<span class="built_in">this</span>.findViewById(id.password);</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> textView0.getText().toString();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> textView1.getText().toString();</span><br><span class="line">        <span class="type">SQLiteDatabase</span> <span class="variable">sQLiteDatabase0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DBHelper</span>(<span class="built_in">this</span>.getApplicationContext()).getReadableDatabase();</span><br><span class="line">        <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;SELECT * FROM User WHERE username = \&#x27;&quot;</span> + s + <span class="string">&quot;\&#x27; AND password = \&#x27;&quot;</span> + s1 + <span class="string">&quot;\&#x27;&quot;</span>;</span><br><span class="line">        Log.i(<span class="string">&quot;SQL语句&quot;</span>, s2);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Cursor</span> <span class="variable">cursor0</span> <span class="operator">=</span> sQLiteDatabase0.rawQuery(s2, <span class="literal">null</span>);</span><br><span class="line">            <span class="keyword">if</span>(cursor0 != <span class="literal">null</span> &amp;&amp; (cursor0.moveToFirst())) &#123;</span><br><span class="line">                Log.d(<span class="string">&quot;Login&quot;</span>, <span class="string">&quot;登录成功&quot;</span>);</span><br><span class="line">                <span class="type">Cursor</span> <span class="variable">cursor1</span> <span class="operator">=</span> sQLiteDatabase0.rawQuery(<span class="string">&quot;SELECT password FROM User WHERE username = \&#x27;flag\&#x27;&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">                <span class="keyword">if</span>(cursor1 != <span class="literal">null</span> &amp;&amp; (cursor1.moveToFirst())) &#123;</span><br><span class="line">                    <span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> cursor1.getString(cursor1.getColumnIndex(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">                    <span class="type">Builder</span> <span class="variable">alertDialog$Builder0</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Builder</span>(<span class="built_in">this</span>);</span><br><span class="line">                    alertDialog$Builder0.setTitle(<span class="string">&quot;登录成功!&quot;</span>);</span><br><span class="line">                    alertDialog$Builder0.setMessage(<span class="string">&quot;flag: &quot;</span> + s3);</span><br><span class="line">                    alertDialog$Builder0.setPositiveButton(<span class="string">&quot;确定&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">                    alertDialog$Builder0.show();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(cursor1 != <span class="literal">null</span>) &#123;</span><br><span class="line">                    cursor1.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Log.d(<span class="string">&quot;Login&quot;</span>, <span class="string">&quot;登录失败&quot;</span>);</span><br><span class="line">                <span class="type">Builder</span> <span class="variable">alertDialog$Builder1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Builder</span>(<span class="built_in">this</span>);</span><br><span class="line">                alertDialog$Builder1.setTitle(<span class="string">&quot;Failed&quot;</span>);</span><br><span class="line">                alertDialog$Builder1.setMessage(<span class="string">&quot;登录失败，如果不知道用户名的话想想之前是否漏了什么提示没有解密&quot;</span>);</span><br><span class="line">                alertDialog$Builder1.setPositiveButton(<span class="string">&quot;收到&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">                alertDialog$Builder1.show();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(cursor0 != <span class="literal">null</span>) &#123;</span><br><span class="line">                cursor0.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Exception exception0) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Log.d(<span class="string">&quot;Login&quot;</span>, <span class="string">&quot;SQL查询错误: &quot;</span> + exception0.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">catch</span>(Throwable throwable0) &#123;</span><br><span class="line">                sQLiteDatabase0.close();</span><br><span class="line">                <span class="keyword">throw</span> throwable0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span>(Throwable throwable0) &#123;</span><br><span class="line">            sQLiteDatabase0.close();</span><br><span class="line">            <span class="keyword">throw</span> throwable0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sQLiteDatabase0.close();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>简单的MySQL漏洞，在账户处输入<code>admin&#39; or &#39;1&#39; = &#39;1 </code>即可构建万能密码</p>
<p>获得flag: <code>XYCTF&#123;And0r1d_15_V3ryEasy&#125;</code></p>
<h2 id="砸核桃"><a href="#砸核桃" class="headerlink" title="砸核桃"></a>砸核桃</h2><p>放入die中发现是国产加密，百度到拖壳器后得到文件</p>
<p>题目很实诚，加密方法就在main里面</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">strlen</span>(Buffer) == <span class="number">42</span> )</span><br><span class="line"> &#123;</span><br><span class="line">   v4 = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> ( (Buffer[v4] ^ byte_402130[v4 % <span class="number">16</span>]) == dword_402150[v4] )</span><br><span class="line">   &#123;</span><br><span class="line">     <span class="keyword">if</span> ( ++v4 &gt;= <span class="number">42</span> )</span><br><span class="line">     &#123;</span><br><span class="line">       <span class="built_in">printf</span>(<span class="string">&quot;right!\n&quot;</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;error!\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">else</span></span><br><span class="line"> &#123;</span><br><span class="line">   <span class="built_in">printf</span>(<span class="string">&quot;error!\n&quot;</span>);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>显然flag长度是42，点击byte_402130和dword_402150即可得到解密所需要的数据（虽然后者内含大量无关的0x00）</p>
<p>写出解密脚本:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#删除所有0x00即可</span></span><br><span class="line">byte_402130 = <span class="string">&#x27;this_is_not_flag&#x27;</span></span><br><span class="line">dword_402150 = [ <span class="number">0x12</span>,<span class="number">0x4</span>,<span class="number">0x8</span>,<span class="number">0x14</span>,<span class="number">0x24</span>,<span class="number">0x5c</span>,<span class="number">0x4a</span>,<span class="number">0x3d</span>,<span class="number">0x56</span>,<span class="number">0xa</span>,<span class="number">0x10</span>,<span class="number">0x67</span>,<span class="number">0x00</span>,<span class="number">0x41</span>,<span class="number">0x00</span>,<span class="number">0x1</span>,<span class="number">0x46</span>,<span class="number">0x5a</span>,<span class="number">0x44</span>,<span class="number">0x42</span>,<span class="number">0x6e</span>,<span class="number">0xc</span>,<span class="number">0x44</span>,<span class="number">0x72</span>,<span class="number">0x0c</span>,<span class="number">0x0d</span>,<span class="number">0x40</span>,<span class="number">0x3E</span>,<span class="number">0x4B</span>, <span class="number">0x5F</span>, <span class="number">0x2</span>, <span class="number">0x1</span>, <span class="number">0x4C</span>, <span class="number">0x5E</span>, <span class="number">0x5B</span>, <span class="number">0x17</span>, <span class="number">0x6E</span>, <span class="number">0x0C</span> ,<span class="number">0x16</span>,<span class="number">0x68</span>,<span class="number">0x5b</span>,<span class="number">0x12</span>,<span class="number">0x02</span>,<span class="number">0x48</span>,<span class="number">0x0e</span>]</span><br><span class="line"></span><br><span class="line">x = <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">42</span>):</span><br><span class="line">    x += <span class="built_in">chr</span>(dword_402150[i]^<span class="built_in">ord</span>(byte_402130[i%<span class="number">16</span>]))</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(x)</span><br><span class="line"><span class="comment">#flag: flag&#123;59b8ed8f-af22-11e7-bb4a-3cf862d1ee75&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="Ez-enc"><a href="#Ez-enc" class="headerlink" title="Ez_enc"></a>Ez_enc</h2><p>die查看无壳，扔进ida中，发现没有main函数，但是又start函数，进去走几步后无果。开始查找字符串，内含大量无用信息，但是发现最下方有奇怪的字符串 <code>.data:000000014001E000	00000007	C	IMouto</code> 百度后发现是妹控相关（二次元真下头）。查看交叉引用发现加密函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">_int64 <span class="title">sub_140011960</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="type">signed</span> <span class="type">int</span> i; <span class="comment">// [rsp+44h] [rbp+24h]</span></span><br><span class="line">  <span class="type">int</span> j; <span class="comment">// [rsp+64h] [rbp+44h]</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">sub_14001137F</span>((__int64)&amp;unk_140023008);</span><br><span class="line">  <span class="built_in">sub_1400111A4</span>(&amp;unk_14001ACB0);</span><br><span class="line">  <span class="built_in">sub_1400111A4</span>(&amp;unk_14001AE60);</span><br><span class="line">  <span class="built_in">sub_1400111A4</span>(&amp;unk_14001AF20);</span><br><span class="line">  <span class="built_in">sub_1400111A4</span>(&amp;unk_14001B1A0);</span><br><span class="line">  <span class="built_in">sub_1400111A4</span>(&amp;unk_14001B290);</span><br><span class="line">  <span class="built_in">sub_1400111A4</span>(&amp;unk_14001B640);</span><br><span class="line">  <span class="built_in">sub_1400111A4</span>(&amp;unk_14001AE18);</span><br><span class="line">  <span class="built_in">sub_14001109B</span>(&amp;unk_14001BA14, Str);</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt; (<span class="type">int</span>)(<span class="built_in">j_strlen</span>(Str) - <span class="number">1</span>); ++i )</span><br><span class="line">    Str[i] = aImouto[i % <span class="number">6</span>] ^ (Str[i + <span class="number">1</span>] + (<span class="type">unsigned</span> __int8)Str[i] % <span class="number">20</span>);</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt; (<span class="type">int</span>)<span class="built_in">j_strlen</span>(Str); ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( Str[j] != byte_14001E008[j] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">sub_1400111A4</span>(<span class="string">&quot;Wrong&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">sub_1400111A4</span>(<span class="string">&quot;Right,but where is my Imouto?\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>i64;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>前面几个函数估计是输出终端中的虾头发言，重点在于第一个循环。最后的比对内容点击即可获得，但是困难的是前面的加密。将34个字符处理33个，但是由于是取余运算导致结果多样且之后的解密高度依赖先前的解密。再询问群内佬后了解了DFS（深度优先算法，西湖论剑时遇见过但是没有认真学，那题到现在都还没有复现。。）,网上学习速成后得到脚本：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">enc, key</span>):</span><br><span class="line">    N = <span class="built_in">len</span>(enc)</span><br><span class="line">    Str = [<span class="number">0</span>] * N  <span class="comment"># 初始化解密后的字符串数组</span></span><br><span class="line">    key = [<span class="built_in">ord</span>(c) <span class="keyword">for</span> c <span class="keyword">in</span> key]  <span class="comment"># 将key字符串转换为其ASCII值的列表</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 尝试解密从最后一个已知的Str[N-1]</span></span><br><span class="line">    Str[N-<span class="number">1</span>] = enc[N-<span class="number">1</span>]  <span class="comment"># 最后一个字符未被加密修改</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 从后向前递归解密每个字符</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decrypt_character</span>(<span class="params">i</span>):</span><br><span class="line">        <span class="keyword">if</span> i &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span>  <span class="comment"># 成功解密所有字符</span></span><br><span class="line">        <span class="keyword">for</span> possible_char <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">32</span>, <span class="number">127</span>):  <span class="comment"># 只考虑ASCII的可见字符</span></span><br><span class="line">            <span class="comment"># 检查这个字符是否能够适应加密方程</span></span><br><span class="line">            <span class="keyword">if</span> key[i % <span class="number">6</span>] ^ (Str[i + <span class="number">1</span>] + possible_char % <span class="number">20</span>) == enc[i]:</span><br><span class="line">                Str[i] = possible_char</span><br><span class="line">                <span class="keyword">if</span> decrypt_character(i - <span class="number">1</span>):  <span class="comment"># 递归密解前一个字符</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> decrypt_character(N-<span class="number">2</span>):  <span class="comment"># 从倒数第二个字符开始解密</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;&#x27;</span>.join(<span class="built_in">chr</span>(x) <span class="keyword">for</span> x <span class="keyword">in</span> Str)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Decryption failed&quot;</span></span><br><span class="line"></span><br><span class="line">enc = [<span class="number">0x27</span>, <span class="number">0x24</span>, <span class="number">0x17</span>, <span class="number">0x0B</span>, <span class="number">0x50</span>, <span class="number">0x03</span>, <span class="number">0xC8</span>, <span class="number">0x0C</span>, <span class="number">0x1F</span>, <span class="number">0x17</span>,</span><br><span class="line">       <span class="number">0x36</span>, <span class="number">0x55</span>, <span class="number">0xCB</span>, <span class="number">0x2D</span>, <span class="number">0xE9</span>, <span class="number">0x32</span>, <span class="number">0x0E</span>, <span class="number">0x11</span>, <span class="number">0x26</span>, <span class="number">0x02</span>,</span><br><span class="line">       <span class="number">0x0C</span>, <span class="number">0x07</span>, <span class="number">0xFC</span>, <span class="number">0x27</span>, <span class="number">0x3D</span>, <span class="number">0x2D</span>, <span class="number">0xED</span>, <span class="number">0x35</span>, <span class="number">0x59</span>, <span class="number">0xEB</span>,</span><br><span class="line">       <span class="number">0x3C</span>, <span class="number">0x3E</span>, <span class="number">0xE4</span>, <span class="number">0x7D</span>]</span><br><span class="line">key = <span class="string">&#x27;IMouto&#x27;</span></span><br><span class="line"></span><br><span class="line">decrypted_text = decrypt(enc, key)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Decrypted text:&quot;</span>, decrypted_text)</span><br><span class="line"><span class="comment">#output：*lag&#123;!_r3ea11y_w4nt_@_cu7e_s1$ter&#125;</span></span><br></pre></td></tr></table></figure>

<p>没有特别处理第一个字符，改成f后flag正确。</p>
<h2 id="熊博士"><a href="#熊博士" class="headerlink" title="熊博士"></a>熊博士</h2><p>以为是凯撒密码但是解密后显然不对，基于对这种没头没脑的密码题的认识，百度关键词“熊博士”和解密发现埃特巴什码 - Atbash Cipher。在线网站解密后得到flag: xyctf{liu_ye_mei_you_xiao_jj}(头要改成大写)</p>
<h2 id="zzl的护理小课堂"><a href="#zzl的护理小课堂" class="headerlink" title="zzl的护理小课堂"></a>zzl的护理小课堂</h2><p>老老实实完成所有题目后遭遇雌小鬼，怒而按下F12发现真相。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">       <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;quizForm&#x27;</span>).<span class="title function_">addEventListener</span>(<span class="string">&#x27;submit&#x27;</span>, <span class="keyword">function</span>(<span class="params">event</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">           event.<span class="title function_">preventDefault</span>(); </span></span><br><span class="line"><span class="language-javascript">   </span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">var</span> formData = <span class="keyword">new</span> <span class="title class_">FormData</span>(<span class="variable language_">this</span>);</span></span><br><span class="line"><span class="language-javascript">   </span></span><br><span class="line"><span class="language-javascript">           <span class="keyword">var</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>(); </span></span><br><span class="line"><span class="language-javascript">           xhr.<span class="title function_">open</span>(<span class="string">&#x27;POST&#x27;</span>, <span class="string">&#x27;getScore.php&#x27;</span>, <span class="literal">true</span>); </span></span><br><span class="line"><span class="language-javascript">           xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">               <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; xhr.<span class="property">status</span> === <span class="number">200</span>) &#123; </span></span><br><span class="line"><span class="language-javascript">                   <span class="keyword">var</span> score = xhr.<span class="property">responseText</span>;</span></span><br><span class="line"><span class="language-javascript">                   <span class="keyword">if</span>(score != <span class="number">111111110</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                       <span class="keyword">var</span> flagXhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>(); </span></span><br><span class="line"><span class="language-javascript">                       flagXhr.<span class="title function_">open</span>(<span class="string">&#x27;GET&#x27;</span>, <span class="string">&#x27;flag.php&#x27;</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="language-javascript">                       flagXhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                           <span class="keyword">if</span> (flagXhr.<span class="property">readyState</span> === <span class="number">4</span> &amp;&amp; flagXhr.<span class="property">status</span> === <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="language-javascript">                               <span class="keyword">var</span> flag = flagXhr.<span class="property">responseText</span>;</span></span><br><span class="line"><span class="language-javascript">                               <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;scoreDisplay&#x27;</span>).<span class="property">innerText</span> = <span class="string">&quot;Flag: &quot;</span> + flag;</span></span><br><span class="line"><span class="language-javascript">                           &#125;</span></span><br><span class="line"><span class="language-javascript">                       &#125;;</span></span><br><span class="line"><span class="language-javascript">                       flagXhr.<span class="title function_">send</span>(); <span class="comment">// 发送请求获取 flag</span></span></span><br><span class="line"><span class="language-javascript">                   &#125;</span></span><br><span class="line"><span class="language-javascript">               &#125;</span></span><br><span class="line"><span class="language-javascript">           &#125;;</span></span><br><span class="line"><span class="language-javascript">           xhr.<span class="title function_">send</span>(formData); <span class="comment">// 发送请求获取分数</span></span></span><br><span class="line"><span class="language-javascript">       &#125;);</span></span><br><span class="line"><span class="language-javascript">   </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>用修改条件后的网页替代后得到flag： XYCTF{Z2I_T3IL_YOU_2991b3d1fb37}</p>
<h2 id="签到"><a href="#签到" class="headerlink" title="签到"></a>签到</h2><p>公众号关注并输入特定字符后得到flag ： XYCTF{WELCOME_TO_XYCTF}</p>
<h2 id="game"><a href="#game" class="headerlink" title="game"></a>game</h2><p>在某个单机游戏贴吧里发帖得到回应，游戏是paper，please。按格式输入即可。</p>
<h2 id="真"><a href="#真" class="headerlink" title="真&lt;签到"></a>真&lt;签到</h2><p>发现无法解压后010打开，发现flag：XYCTF{59bd0e77d13c_1406b23219e_f91cf3a_153e8ea4_77508ba}</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://afogsheep.github.io/2024/04/23/STL%E7%AE%97%E6%B3%95%E6%B6%89%E7%8C%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="We losers do nothing so winners keeping winning <br> </br> 仍在施工中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杜鹃声">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/23/STL%E7%AE%97%E6%B3%95%E6%B6%89%E7%8C%8E/" class="post-title-link" itemprop="url">STL算法涉猎</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-23 23:28:45" itemprop="dateCreated datePublished" datetime="2024-04-23T23:28:45+08:00">2024-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-01 16:16:00" itemprop="dateModified" datetime="2024-05-01T16:16:00+08:00">2024-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>考虑以下问题：假设我们想要编写一个程序，该程序从文件中读取整数列表（可能表示作业中的成绩），然后打印出这些值的平均值。为简单起见，我们假设此数据存储在名为 data.txt 的文件中，每行一个整数。例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">100</span><br><span class="line">95</span><br><span class="line">92</span><br><span class="line">98</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">100</span><br><span class="line">87</span><br><span class="line">89</span><br><span class="line">87</span><br><span class="line">89</span><br><span class="line">83</span><br><span class="line">87</span><br><span class="line">97</span><br><span class="line">99</span><br><span class="line">89</span><br><span class="line">88</span><br></pre></td></tr></table></figure>

<p>以下是一个可能的例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">input</span><span class="params">(<span class="string">&quot;G:\\Cpp_Learn\\full_course_reader\\week5\\data.txt&quot;</span>)</span></span>;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; values;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> currVaule;</span><br><span class="line">    <span class="keyword">while</span>(input &gt;&gt; currVaule)&#123;</span><br><span class="line">        values.<span class="built_in">insert</span>(currVaule);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//习惯性的写法</span></span><br><span class="line">    <span class="type">float</span> total = <span class="number">0.000</span>; </span><br><span class="line">    <span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator itr = values.<span class="built_in">begin</span>(); itr != values.<span class="built_in">end</span>(); ++itr)&#123;</span><br><span class="line">        total += *itr;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;average is : &quot;</span> &lt;&lt; total/values.<span class="built_in">size</span>() &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果要用语言描绘这个程序，我们可以把他分为三步：</p>
<ol>
<li>读取文件内容</li>
<li>将值相加</li>
<li>除以元素个数</li>
</ol>
<p>我们必须以这种机械的方式向计算机发出命令的原因正是因为计算机是机械的——它是一台高效计算功能的机器。编程的挑战是找到一种方法，将一组高级命令转换为一系列控制机器的低级指令。这通常是一件苦差事，因为计算机导出的基本操作相当有限。但编程并不一定这么难。正如你所看到的，我们可以根据旧函数来定义新函数，并且可以从这些越来越强大的子程序中构建复杂的程序。从理论上讲，你可以编译一个巨大的库，其中包含所有非平凡的编程问题的解决方案。有了这个库，你就可以轻松地编写程序，只需将这些预先编写好的组件拼接在一起。</p>
<p>不幸的是，没有一个库可以解决每个编程问题。然而，这并没有阻止STL的设计者尽最大努力建造一个。这些是 STL 算法，一个用于处理数据的非常强大的例程库。STL 算法不能做所有事情，但它们能做的事情却做得非常出色。实际上，使用 STL 算法，可以重写在四行代码中平均数字的程序。</p>
<h2 id="第一个STL算法：Accumulate"><a href="#第一个STL算法：Accumulate" class="headerlink" title="第一个STL算法：Accumulate"></a>第一个STL算法：Accumulate</h2><p>关于先前求和的部分，可以用以下的方法替代：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;numeric&gt;</span></span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;average is : &quot;</span> &lt;&lt; <span class="built_in">accumulate</span>(values.<span class="built_in">begin</span>(),values.<span class="built_in">end</span>(),<span class="number">0.0</span>)/values.<span class="built_in">size</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p>在标头中定义的 accumulate 函数<numeric>采用三个参数 – 两个定义元素范围的迭代器，以及用于求和的初始值。然后，它计算迭代器范围内包含的所有元素的总和，加上基本值。 accumulate（以及一般的 STL 算法）的美妙之处在于，accumulate 可以接受任何类型的迭代器。也就是说，我们可以从多集、向量或 deque 中求和迭代器。这意味着，如果您发现自己需要计算容器中包含的元素的总和，则可以将该容器的 begin（） 和 end（） 迭代器传递到 accumulate 中以获得总和。此外，accumulate 可以接受任何有效的迭代器范围，而不仅仅是跨整个容器的迭代器范围。例如，如果我们想计算多集的元素之和，这些元素介于 42 和 137 之间（含 42 和 137），我们可以写成:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">accumulate</span>(values.<span class="built_in">lower_bound</span>(<span class="number">42</span>), values.<span class="built_in">upper_bound</span>(<span class="number">137</span>), <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>在幕后，accumulate 被实现为一个模板函数，它接受两个迭代器，并简单地使用循环将值相加。这是 accumulate 的一种可能实现:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> Type&gt; <span class="function"><span class="keyword">inline</span></span></span><br><span class="line"><span class="function">   Type <span class="title">accumulate</span><span class="params">(InputIterator start, InputIterator stop, Type initial)</span> </span>&#123;</span><br><span class="line"><span class="keyword">while</span>(start != stop) &#123;</span><br><span class="line">           initial += *start;</span><br><span class="line">           ++start;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> initial;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>代码的核心是一个标准的迭代器循环，它不断向前推进启动迭代器，直到它到达目的地。累加没有什么神奇之处，函数调用是一行代码这一事实并没有改变它仍然使用循环将所有值相加的事实。</p>
<p>如果 STL 算法只是在幕后使用循环的函数，为什么我们还要费心学习呢？有几个原因，第一个原因是简单。借助 STL 算法，您可以利用已经为您编写的代码，而不是从头开始重新编写代码。这可以节省大量时间，也导致了第二个原因，即正确性。如果你每次需要使用它们时都必须从头开始重写所有算法，那么在某个时候你很可能会犯错误。例如，您可能会编写一个排序例程，该例程在您打算&gt;时意外地使用了 &lt;，因此根本不起作用。STL 算法则不然——它们已经过全面测试，可以正常工作于任何给定的输入。使用算法的第三个原因是速度。一般来说，你可以假设，如果有一个 STL 算法来执行一项任务，它将比你手动编写的大多数代码更快。通过模板专用化和模板元编程等先进技术，STL 算法经过透明优化，以尽可能快地工作。最后，STL 算法提供了清晰度。使用算法，您可以立即判断出对累积的调用将某个范围内的数字相加。但使用求和值的 for 循环，您必须先阅读循环中的每一行，然后才能理解代码的作用。</p>
<h2 id="算法命名的约定"><a href="#算法命名的约定" class="headerlink" title="算法命名的约定"></a>算法命名的约定</h2><p>有超过 50 种 STL 算法（定义在 中<algorithm><numeric>或 中），至少可以说，记住它们将是一件苦差事。幸运的是，它们中的许多都有通用的命名约定，因此即使我们以前从未遇到过它们，也可以轻松识别。</p>
<h3 id="后缀-‘-if-‘"><a href="#后缀-‘-if-‘" class="headerlink" title="后缀 ‘ _if ‘"></a>后缀 ‘ _if ‘</h3><p>以 <code>_if</code> 结尾的算法基于条件执行操作。这些函数需要一个谓词——一个接受元素作为输入并返回布尔值的函数，该布尔值指示元素是否满足特定标准。示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">IsEven</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myVec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">137</span>, <span class="number">137</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;偶数元素数量: &quot;</span> </span><br><span class="line">              &lt;&lt; <span class="built_in">count_if</span>(myVec.<span class="built_in">begin</span>(), myVec.<span class="built_in">end</span>(), IsEven) &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="关键字-‘-copy-‘"><a href="#关键字-‘-copy-‘" class="headerlink" title="关键字 ‘ copy ‘"></a>关键字 ‘ copy ‘</h3><p>名称中包含 <code>copy</code> 的算法执行操作并将结果存储在由另一个迭代器指定的新位置。当想保留原始数据的同时处理转换后的数据时，这非常有用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; src = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; dest;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为新元素腾出空间</span></span><br><span class="line">    dest.<span class="built_in">resize</span>(src.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">    <span class="built_in">remove_copy_if</span>(src.<span class="built_in">begin</span>(), src.<span class="built_in">end</span>(), dest.<span class="built_in">begin</span>(), [](<span class="type">int</span> x) &#123; <span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span>; &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> val : dest) &#123;</span><br><span class="line">        std::cout &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="后缀-‘-n-‘"><a href="#后缀-‘-n-‘" class="headerlink" title="后缀 ‘_n ‘"></a>后缀 ‘_n ‘</h3><p>算法名称中的 <code>_n</code> 后缀表明操作将执行指定次数，而不是在一个范围内执行。当确切的操作次数比数据范围更重要时，这特别有用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::deque&lt;<span class="type">int</span>&gt; <span class="title">myDeque</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fill_n</span>(myDeque.<span class="built_in">begin</span>(), <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : myDeque) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里的<code>fill_n</code> 将 <code>myDeque</code> 的前十个元素设置为零。</p>
<h2 id="解析-STL-迭代器的分类"><a href="#解析-STL-迭代器的分类" class="headerlink" title="解析 STL 迭代器的分类"></a>解析 STL 迭代器的分类</h2><p>在 C++ 标准模板库（STL）中，迭代器是访问和操作容器中元素的关键工具。由于不同容器的内部结构差异，迭代器的功能也有所不同，因此 STL 迭代器被分为几种不同的类型，每种迭代器具有不同的能力和限制。了解这些迭代器的分类对于有效使用 STL 是非常重要的。</p>
<h3 id="迭代器的分类及功能"><a href="#迭代器的分类及功能" class="headerlink" title="迭代器的分类及功能"></a>迭代器的分类及功能</h3><p>迭代器按照功能强弱分为五种类型，从功能最弱到功能最强依次是：</p>
<ol>
<li><strong>输出迭代器（Output Iterators）</strong><ul>
<li>输出迭代器允许写入值（使用 <code>*myItr = value</code> 语法）。</li>
<li>可以向前移动（使用 <code>++</code> 操作符）。</li>
<li>不能读取值或使用 <code>+=</code> 或 <code>-</code> 操作符。</li>
</ul>
</li>
<li><strong>输入迭代器（Input Iterators）</strong><ul>
<li>输入迭代器允许读取值（使用 <code>value = *myItr</code> 语法）。</li>
<li>不能写入值或遍历同一范围两次。</li>
</ul>
</li>
<li><strong>前向迭代器（Forward Iterators）</strong><ul>
<li>结合了输入和输出迭代器的功能，支持读写操作。</li>
<li>只能向前移动（使用 <code>++</code> 操作符）。</li>
</ul>
</li>
<li><strong>双向迭代器（Bidirectional Iterators）</strong><ul>
<li>拥有前向迭代器的所有功能。</li>
<li>可以向后移动（使用 <code>--</code> 操作符）。</li>
<li>通常用于像 <code>map</code> 和 <code>set</code> 这样的容器。</li>
</ul>
</li>
<li><strong>随机访问迭代器（Random-Access Iterators）</strong><ul>
<li>提供最大的功能，支持任意前后移动。</li>
<li>支持迭代器加减、使用方括号语法和 <code>+</code>、<code>+=</code> 操作。</li>
<li>主要用于 <code>vector</code> 和 <code>deque</code>。</li>
</ul>
</li>
</ol>
<h3 id="为什么要区分迭代器类型？"><a href="#为什么要区分迭代器类型？" class="headerlink" title="为什么要区分迭代器类型？"></a>为什么要区分迭代器类型？</h3><p>由于容器的内部数据结构不同，迭代器的实现和性能也会有很大差异。例如，<code>vector</code> 和 <code>deque</code> 支持随机访问迭代器，因为它们的元素是连续存储的，可以通过简单的地址计算快速访问任何元素。相反，<code>set</code> 和 <code>map</code> 通常使用树结构存储元素，所以它们的迭代器只能一步一步地前进或后退，这种操作的复杂度是线性的。</p>
<p>在实际编程中，了解并使用正确类型的迭代器非常关键，因为它关系到代码的性能和效率。当一个库函数需要特定类型的迭代器时，提供一个功能相当或更强大的迭代器是可行的。例如，如果一个函数需要一个前向迭代器，那么提供一个前向迭代器、双向迭代器或随机访问迭代器都是可以的。</p>
<p>通过掌握这些迭代器的分类和功能，可以更加灵活和高效地使用 STL，从而编写出更优雅和高效的 C++ 代码。</p>
<p><img src="G:\Cpp_Learn\full_course_reader\notes\assets\image-20240423225530689.png" alt="image-20240423225530689"></p>
<h2 id="探索-STL-重排序算法"><a href="#探索-STL-重排序算法" class="headerlink" title="探索 STL 重排序算法"></a>探索 STL 重排序算法</h2><p>在 C++ 的标准模板库（STL）中，有一系列用于重排序容器中元素的算法。这些算法能够在不改变元素内容的前提下，改变元素的排列顺序。以下是三种主要的重排序算法：<code>sort</code>、<code>random_shuffle</code> 和 <code>rotate</code>，它们各自的用途和功能都非常实用。</p>
<h3 id="排序算法（sort）"><a href="#排序算法（sort）" class="headerlink" title="排序算法（sort）"></a>排序算法（<code>sort</code>）</h3><p><code>sort</code> 算法是用于将容器中的元素按照升序排序。此算法要求传入的迭代器为随机访问迭代器，因此它不能用于 <code>map</code> 或 <code>set</code> 类型的容器，不过这些容器本身就是有序的。</p>
<p><strong>基本用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(myVector.<span class="built_in">begin</span>(), myVector.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<p>此外，<code>sort</code> 还允许指定一个自定义的比较函数，以实现不同的排序准则。</p>
<p><strong>自定义比较函数示例：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">placeT</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="type">int</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ComparePlaces</span><span class="params">(placeT one, placeT two)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (one.x != two.x) <span class="keyword">return</span> one.x &lt; two.x;</span><br><span class="line">    <span class="keyword">return</span> one.y &lt; two.y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">std::vector&lt;placeT&gt; myPlaceVector = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>&#125;, &#123;<span class="number">3</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">std::<span class="built_in">sort</span>(myPlaceVector.<span class="built_in">begin</span>(), myPlaceVector.<span class="built_in">end</span>(), ComparePlaces);</span><br></pre></td></tr></table></figure>

<h3 id="随机打乱算法（random-shuffle）"><a href="#随机打乱算法（random-shuffle）" class="headerlink" title="随机打乱算法（random_shuffle）"></a>随机打乱算法（<code>random_shuffle</code>）</h3><p><code>random_shuffle</code> 算法用于随机打乱容器中的元素。类似于 <code>sort</code>，这个算法也需要随机访问迭代器。</p>
<p><strong>示例用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">std::<span class="built_in">random_shuffle</span>(myVector.<span class="built_in">begin</span>(), myVector.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<p>在使用 <code>random_shuffle</code> 之前，建议使用 <code>srand</code> 函数来设定随机数生成器的种子，以确保每次程序运行结果的随机性。</p>
<h3 id="旋转算法（rotate）"><a href="#旋转算法（rotate）" class="headerlink" title="旋转算法（rotate）"></a>旋转算法（<code>rotate</code>）</h3><p><code>rotate</code> 算法通过循环移动容器中的元素，使得指定位置的元素变为容器的开始。</p>
<p><strong>示例用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">std::<span class="built_in">rotate</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">begin</span>() + <span class="number">2</span>, v.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>
<p>在此示例中，向量 <code>v</code> 中的元素会被旋转，结果为 <code>&#123;2, 3, 4, 5, 0, 1&#125;</code>。</p>
<p>这些重排序算法在日常编程中非常有用，它们可以帮助开发者有效地处理和变换数据。了解和运用这些算法，可以极大地提高编程效率和代码的可读性。</p>
<h2 id="探索-STL-中的搜索算法"><a href="#探索-STL-中的搜索算法" class="headerlink" title="探索 STL 中的搜索算法"></a>探索 STL 中的搜索算法</h2><p>在数据处理过程中，常常需要在容器中查找特定的元素。例如，你可能想知道一个向量是否包含一个特定的元素。尽管 <code>map</code> 和 <code>set</code> 容器提供了内置的查找功能，<code>vector</code> 和 <code>deque</code> 等线性容器则缺少这样的功能。好在，STL 提供了多种算法来补充这一功能缺失。</p>
<h3 id="find-算法"><a href="#find-算法" class="headerlink" title="find 算法"></a><code>find</code> 算法</h3><p><code>find</code> 函数是最基本的搜索算法，它接受两个迭代器（定义搜索范围）和一个值，返回第一个匹配该值的元素的迭代器。如果范围内没有匹配的元素，<code>find</code> 返回第二个迭代器作为哨兵值。</p>
<p><strong>示例用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">137</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">find</span>(myVector.<span class="built_in">begin</span>(), myVector.<span class="built_in">end</span>(), <span class="number">137</span>) != myVector.<span class="built_in">end</span>()) &#123;</span><br><span class="line">    <span class="comment">// 向量包含元素 137</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>虽然你可以在 <code>map</code> 和 <code>set</code> 上使用 <code>find</code>，但通常不推荐这样做。因为 <code>map</code> 和 <code>set</code> 的成员函数 <code>find</code> 使用了容器内部数据结构的信息来加快搜索速度，而 STL 的 <code>find</code> 函数则必须线性地遍历元素，效率较低。</p>
<h3 id="binary-search-算法"><a href="#binary-search-算法" class="headerlink" title="binary_search 算法"></a><code>binary_search</code> 算法</h3><p>如果你有一个已排序的线性容器（如排序后的 <code>vector</code>），可以使用 <code>binary_search</code> 来执行搜索，这比线性搜索快得多。<code>binary_search</code> 仅返回一个布尔值，表示是否找到了指定的元素。</p>
<p><strong>示例用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">137</span>&#125;;  <span class="comment">// 假设已排序</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">binary_search</span>(myVector.<span class="built_in">begin</span>(), myVector.<span class="built_in">end</span>(), <span class="number">137</span>)) &#123;</span><br><span class="line">    <span class="comment">// 找到了元素 137</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果容器使用了特殊的比较函数进行排序，你也可以将这个比较函数传递给 <code>binary_search</code>。但要确保使用一致的比较函数，否则可能导致 <code>binary_search</code> 工作不正常。</p>
<h3 id="lower-bound-算法"><a href="#lower-bound-算法" class="headerlink" title="lower_bound 算法"></a><code>lower_bound</code> 算法</h3><p>如果你需要在排序的容器中找到一个元素并获取指向该元素的迭代器，可以使用 <code>lower_bound</code>。这个算法返回指向第一个不小于指定值的元素的迭代器。如果没有找到精确匹配的元素，<code>lower_bound</code> 可能返回指向一个更大元素的迭代器，因此在使用返回的迭代器前需要进行检查。</p>
<p><strong>示例用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">137</span>&#125;;  <span class="comment">// 假设已排序</span></span><br><span class="line"><span class="keyword">auto</span> it = <span class="built_in">lower_bound</span>(myVector.<span class="built_in">begin</span>(), myVector.<span class="built_in">end</span>(), <span class="number">4</span>);</span><br><span class="line"><span class="keyword">if</span> (it != myVector.<span class="built_in">end</span>() &amp;&amp; *it == <span class="number">4</span>) &#123;</span><br><span class="line">    <span class="comment">// 找到元素 4</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 元素 4 不在向量中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这些搜索算法是处理 STL 容器中数据的强大工具。合理使用这些算法不仅可以提高代码的效率，还能使代码更加清晰和易于维护。</p>
<h2 id="迭代器适配器"><a href="#迭代器适配器" class="headerlink" title="迭代器适配器"></a>迭代器适配器</h2><p>在使用 C++ 标准模板库（STL）的过程中，当我们想要通过算法生成数据范围时，确保目标位置有足够的空间来存放结果是非常重要的。例如，<code>copy</code> 算法需要目标容器预先分配足够的空间以防写入数据时超出范围导致未定义行为。为了解决这个问题，STL 提供了一类特殊的工具，称为迭代器适配器，这些适配器扩展了迭代器的功能，使其更加灵活和强大。</p>
<h3 id="ostream-iterator-——-输出流迭代器"><a href="#ostream-iterator-——-输出流迭代器" class="headerlink" title="ostream_iterator —— 输出流迭代器"></a><code>ostream_iterator</code> —— 输出流迭代器</h3><p><code>ostream_iterator</code> 是一种输出流迭代器，它不指向任何实际的容器元素，而是将数据输出到指定的流，如 <code>cout</code> 或文件流。</p>
<p><strong>示例用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">myItr</span><span class="params">(std::cout, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line">    *myItr = <span class="number">137</span>; <span class="comment">// 输出 137 到 cout</span></span><br><span class="line">    ++myItr;</span><br><span class="line">    *myItr = <span class="number">42</span>;  <span class="comment">// 输出 42 到 cout</span></span><br><span class="line">    ++myItr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码通过 <code>ostream_iterator</code> 将整数直接写入到标准输出流 <code>cout</code>，数字之间由空格分隔。</p>
<h3 id="使用-ostream-iterator-结合-STL-算法"><a href="#使用-ostream-iterator-结合-STL-算法" class="headerlink" title="使用 ostream_iterator 结合 STL 算法"></a>使用 <code>ostream_iterator</code> 结合 STL 算法</h3><p>由于 <code>ostream_iterator</code> 本身是一个迭代器，我们可以将其与 STL 算法结合使用，从而实现复杂的输出任务。例如，我们可以将一个容器中的所有元素复制到输出流中。</p>
<p><strong>示例用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::<span class="built_in">copy</span>(myVector.<span class="built_in">begin</span>(), myVector.<span class="built_in">end</span>(), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此代码将 <code>myVector</code> 中的所有元素复制到 <code>cout</code>，元素之间以空格分隔，一行代码实现了整个向量的输出。</p>
<h3 id="back-insert-iterator-——-后插迭代器"><a href="#back-insert-iterator-——-后插迭代器" class="headerlink" title="back_insert_iterator —— 后插迭代器"></a><code>back_insert_iterator</code> —— 后插迭代器</h3><p>另一个有用的迭代器适配器是 <code>back_insert_iterator</code>，这种迭代器在写入数据时会自动调用 <code>push_back</code> 方法将数据追加到容器的末尾。</p>
<p><strong>示例用法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; myVector;</span><br><span class="line">    std::back_insert_iterator&lt;std::vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">itr</span>(myVector);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">        *itr = i; <span class="comment">// 追加值到 myVector</span></span><br><span class="line">        ++itr;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">copy</span>(myVector.<span class="built_in">begin</span>(), myVector.<span class="built_in">end</span>(), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cout, <span class="string">&quot; &quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，<code>back_insert_iterator</code> 被用来动态地向 <code>myVector</code> 添加元素，之后通过 <code>copy</code> 和 <code>ostream_iterator</code> 输出所有元素。</p>
<h3 id="insert-iterator-的应用"><a href="#insert-iterator-的应用" class="headerlink" title="insert_iterator 的应用"></a><code>insert_iterator</code> 的应用</h3><p><code>insert_iterator</code> 是一种更通用的迭代器适配器，它可以在容器的任意位置插入元素。这种迭代器在处理需要元素插入的算法，如集合操作算法 <code>set_union</code>, <code>set_intersection</code>, <code>set_difference</code> 等时尤为有用。</p>
<p><strong>示例用法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::set&lt;int&gt; setOne = &#123;1, 2, 3&#125;;</span><br><span class="line">std::set&lt;int&gt; setTwo = &#123;2, 3, 4&#125;;</span><br><span class="line">std::set&lt;int&gt; result;</span><br><span class="line">std::set_union(setOne.begin(), setOne.end(), setTwo.begin(), setTwo.end(), std::inserter(result, result.begin()));</span><br></pre></td></tr></table></figure>

<p>这段代码计算了 <code>setOne</code> 和 <code>setTwo</code> 的并集，并使用 <code>insert_iterator</code> 将结果存入 <code>result</code>。</p>
<h3 id="istream-iterator-——-输入流迭代器"><a href="#istream-iterator-——-输入流迭代器" class="headerlink" title="istream_iterator —— 输入流迭代器"></a><code>istream_iterator</code> —— 输入流迭代器</h3><p><code>istream_iterator</code> 是另一种迭代器适配器，它允许从输入流（如文件或标准输入）读取数据。这使得 <code>istream_iterator</code> 成为处理输入数据流的理想工具。</p>
<p><strong>示例用法：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::istream_iterator&lt;int&gt; it(std::cin);</span><br><span class="line">std::istream_iterator&lt;int&gt; end;</span><br><span class="line">std::vector&lt;int&gt; values(it, end); // 从标准输入读取整数直到 EOF</span><br></pre></td></tr></table></figure>

<p>在这个例子中，从标准输入读取的整数被存储到 <code>values</code> 向量中，直到输入结束。</p>
<h2 id="常见的迭代器及其应用"><a href="#常见的迭代器及其应用" class="headerlink" title="常见的迭代器及其应用"></a>常见的迭代器及其应用</h2><p>在 C++ 标准模板库（STL）中，迭代器适配器扩展了基本迭代器的功能，使它们能够在特定的上下文中更加有效地工作。下面是一些常见迭代器适配器的详细介绍，这些适配器广泛应用于处理容器和流中的数据。</p>
<h2 id="常见的迭代器适配器及其应用"><a href="#常见的迭代器适配器及其应用" class="headerlink" title="常见的迭代器适配器及其应用"></a>常见的迭代器适配器及其应用</h2><p>在 C++ 标准模板库（STL）中，迭代器适配器扩展了基本迭代器的功能，使它们能够在特定的上下文中更加有效地工作。下面是一些常见迭代器适配器的详细介绍，这些适配器广泛应用于处理容器和流中的数据。</p>
<h3 id="输出迭代器"><a href="#输出迭代器" class="headerlink" title="输出迭代器"></a>输出迭代器</h3><h4 id="back-insert-iterator"><a href="#back-insert-iterator" class="headerlink" title="back_insert_iterator"></a><code>back_insert_iterator</code></h4><ul>
<li><p><strong>定义</strong>: <code>back_insert_iterator&lt;Container&gt;</code></p>
</li>
<li><p><strong>构造方法</strong>: <code>back_insert_iterator&lt;vector&lt;int&gt;&gt; itr(myVector);</code></p>
</li>
<li><p><strong>功能</strong>: 通过调用容器的 <code>push_back</code> 方法来存储元素。</p>
</li>
<li><p><strong>用法</strong>: 可以显式声明或使用 <code>back_inserter</code> 函数快速创建。</p>
</li>
<li><p>示例:</p>
<p>使用 <code>back_insert_iterator</code> 将元素添加到 <code>vector</code> 的末尾。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; data = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line">    std::<span class="built_in">copy</span>(data.<span class="built_in">begin</span>(), data.<span class="built_in">end</span>(), std::<span class="built_in">back_inserter</span>(result));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : result) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="front-insert-iterator"><a href="#front-insert-iterator" class="headerlink" title="front_insert_iterator"></a><code>front_insert_iterator</code></h4><ul>
<li><p><strong>定义</strong>: <code>front_insert_iterator&lt;Container&gt;</code></p>
</li>
<li><p><strong>构造方法</strong>: <code>front_insert_iterator&lt;deque&lt;int&gt;&gt; itr(myIntDeque);</code></p>
</li>
<li><p><strong>功能</strong>: 通过调用容器的 <code>push_front</code> 方法来存储元素。</p>
</li>
<li><p><strong>限制</strong>: 不能用于不支持 <code>push_front</code> 方法的容器，如 <code>vector</code>。</p>
</li>
<li><p><strong>用法</strong>: 可以使用 <code>front_inserter</code> 函数创建。</p>
</li>
<li><p>示例:</p>
<p>使用 <code>front_insert_iterator</code> 将元素添加到 <code>deque</code> 的前端。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::deque&lt;<span class="type">int</span>&gt; data;</span><br><span class="line">    std::front_insert_iterator&lt;std::deque&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">inserter</span>(data);</span><br><span class="line">    *inserter = <span class="number">1</span>;</span><br><span class="line">    *inserter = <span class="number">2</span>;</span><br><span class="line">    *inserter = <span class="number">3</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : data) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// Output: 3 2 1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="insert-iterator"><a href="#insert-iterator" class="headerlink" title="insert_iterator"></a><code>insert_iterator</code></h4><ul>
<li><strong>定义</strong>: <code>insert_iterator&lt;Container&gt;</code></li>
<li><strong>构造方法</strong>: <code>insert_iterator&lt;set&lt;int&gt;&gt; itr(mySet, mySet.begin());</code></li>
<li><strong>功能</strong>: 在指定位置调用容器的 <code>insert</code> 方法来插入元素。</li>
<li><strong>适用范围</strong>: 可用于任何容器，尤其适合于 <code>set</code>。</li>
<li><strong>用法</strong>: 可以通过 <code>inserter</code> 函数生成。</li>
<li>示例:</li>
</ul>
<p>​	使用 <code>insert_iterator</code> 在 <code>set</code> 中插入元素。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::set&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line">    std::insert_iterator&lt;std::set&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">inserter</span>(numbers, numbers.<span class="built_in">begin</span>());</span><br><span class="line">    *inserter = <span class="number">3</span>;</span><br><span class="line">    *inserter = <span class="number">1</span>;</span><br><span class="line">    *inserter = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> x : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; x &lt;&lt; <span class="string">&quot; &quot;</span>;  <span class="comment">// Output: 1 2 3 (automatically sorted)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="流迭代器"><a href="#流迭代器" class="headerlink" title="流迭代器"></a>流迭代器</h3><h4 id="ostream-iterator"><a href="#ostream-iterator" class="headerlink" title="ostream_iterator"></a><code>ostream_iterator</code></h4><ul>
<li><strong>定义</strong>: <code>ostream_iterator&lt;Type&gt;</code></li>
<li><strong>构造方法</strong>: <code>ostream_iterator&lt;int&gt; itr(cout, &quot; &quot;);</code></li>
<li><strong>功能</strong>: 将元素写入输出流中，可选地在每个元素后添加分隔符。</li>
<li><strong>用法</strong>: 初始化时必须指定输出流和可选的分隔符。</li>
<li>示例:</li>
</ul>
<p>​	使用 <code>ostream_iterator</code> 输出元素到标准输出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="function">std::ostream_iterator&lt;<span class="type">int</span>&gt; <span class="title">output</span><span class="params">(std::cout, <span class="string">&quot; &quot;</span>)</span></span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(numbers.<span class="built_in">begin</span>(), numbers.<span class="built_in">end</span>(), output);  <span class="comment">// Output: 1 2 3</span></span><br></pre></td></tr></table></figure>

<h4 id="istream-iterator"><a href="#istream-iterator" class="headerlink" title="istream_iterator"></a><code>istream_iterator</code></h4><ul>
<li><strong>定义</strong>: <code>istream_iterator&lt;Type&gt;</code></li>
<li><strong>构造方法</strong>: <code>istream_iterator&lt;int&gt; itr(cin);</code></li>
<li><strong>功能</strong>: 从指定的输入流中读取值。</li>
<li><strong>特性</strong>: 当到达流的末尾时，会取得一个特殊的“结束”值。</li>
<li><strong>注意事项</strong>: 易受输入流状态影响，使用时需注意。</li>
<li>示例:</li>
</ul>
<p>​	使用 <code>istream_iterator</code> 从标准输入读取整数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; numbers;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter numbers separated by spaces: &quot;</span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(std::<span class="built_in">istream_iterator</span>&lt;<span class="type">int</span>&gt;(std::cin), std::<span class="built_in">istream_iterator</span>&lt;<span class="type">int</span>&gt;(), std::<span class="built_in">back_inserter</span>(numbers));</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> num : numbers) &#123;</span><br><span class="line">        std::cout &lt;&lt; num &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="ostreambuf-iterator"><a href="#ostreambuf-iterator" class="headerlink" title="ostreambuf_iterator"></a><code>ostreambuf_iterator</code></h4><ul>
<li><strong>定义</strong>: <code>ostreambuf_iterator&lt;char&gt;</code></li>
<li><strong>构造方法</strong>: <code>ostreambuf_iterator&lt;char&gt; itr(cout);</code></li>
<li><strong>功能</strong>: 将原始字符数据写入输出流。</li>
<li><strong>限制</strong>: 仅能写入字符数据。</li>
<li>示例:</li>
</ul>
<p>​	使用 <code>ostreambuf_iterator</code> 输出字符到标准输出。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">std::ostreambuf_iterator&lt;<span class="type">char</span>&gt; <span class="title">output</span><span class="params">(std::cout)</span></span>;</span><br><span class="line">    *output = <span class="string">&#x27;H&#x27;</span>;</span><br><span class="line">    *output = <span class="string">&#x27;i&#x27;</span>;</span><br><span class="line">    *output = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="istreambuf-iterator"><a href="#istreambuf-iterator" class="headerlink" title="istreambuf_iterator"></a><code>istreambuf_iterator</code></h4><ul>
<li><p><strong>定义</strong>: <code>istreambuf_iterator&lt;char&gt;</code></p>
</li>
<li><p><strong>构造方法</strong>: <code>istreambuf_iterator&lt;char&gt; itr(cin);</code></p>
</li>
<li><p><strong>功能</strong>: 从输入流中读取未格式化的数据。</p>
</li>
<li><p><strong>特性</strong>: 始终读取字符数据，不跳过空白。</p>
</li>
<li><p><strong>用途</strong>: 常用于从文件中读取原始数据进行处理。</p>
</li>
<li><p>示例:</p>
<p>使用 <code>istreambuf_iterator</code> 从标准输入读取原始字符数据。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;Enter text, followed by EOF: &quot;</span>;</span><br><span class="line">    <span class="function">std::istreambuf_iterator&lt;<span class="type">char</span>&gt; <span class="title">start</span><span class="params">(std::cin)</span>, end</span>;</span><br><span class="line">    <span class="function">std::vector&lt;<span class="type">char</span>&gt; <span class="title">characters</span><span class="params">(start, end)</span></span>;</span><br><span class="line">    </span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;You entered: &quot;</span>;</span><br><span class="line">    std::<span class="built_in">copy</span>(characters.<span class="built_in">begin</span>(), characters.<span class="built_in">end</span>(), std::<span class="built_in">ostream_iterator</span>&lt;<span class="type">char</span>&gt;(std::cout, <span class="string">&quot;&quot;</span>));</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://afogsheep.github.io/2024/04/17/bashshell%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="We losers do nothing so winners keeping winning <br> </br> 仍在施工中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杜鹃声">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/17/bashshell%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4/" class="post-title-link" itemprop="url">bashshell基础命令</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-17 23:10:12" itemprop="dateCreated datePublished" datetime="2024-04-17T23:10:12+08:00">2024-04-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-01 16:16:18" itemprop="dateModified" datetime="2024-05-01T16:16:18+08:00">2024-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="启动终端"><a href="#启动终端" class="headerlink" title="启动终端"></a>启动终端</h2><p>启动终端后会看见 <strong>shell CLI</strong> 提示符，在此输入shell命令。默认的提示符符号是 $</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[/etc]</span><br><span class="line">└─$ </span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="与bash手册交互"><a href="#与bash手册交互" class="headerlink" title="与bash手册交互"></a>与bash手册交互</h2><p>大多数Linux发行版自带在线手册。使用man命令可以访问Linux系统的手册页。输入 <code>man 想要查看的命令</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">NAME</span><br><span class="line">       <span class="built_in">cat</span> - concatenate files and <span class="built_in">print</span> on the standard output</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="built_in">cat</span> [OPTION]... [FILE]...</span><br><span class="line"></span><br><span class="line">DESCRIPTION</span><br><span class="line">       Concatenate FILE(s) to standard output.</span><br><span class="line"></span><br><span class="line">       With no FILE, or when FILE is -, <span class="built_in">read</span> standard input.</span><br><span class="line"></span><br><span class="line">       -A, --show-all</span><br><span class="line">              equivalent to -vET</span><br><span class="line"></span><br><span class="line">       -b, --number-nonblank</span><br><span class="line">              number nonempty output lines, overrides -n</span><br><span class="line"></span><br><span class="line">       -e     equivalent to -vE</span><br><span class="line"></span><br><span class="line">       -E, --show-ends</span><br><span class="line">              display $ at end of each line</span><br><span class="line"></span><br><span class="line">       -n, --number</span><br><span class="line">              number all output lines</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>以上是 <code>cat</code>的部分用法。输入 <code>man cat</code>即可查看</p>
<p>其中 <strong>DESCRIPTION</strong> 部分提供了快速参考。从中可以迅速了解命令的作用以及用法。</p>
<p>mannal里通过空格翻页，enter逐行查看，以及上下箭头进行滑动。按q退出。</p>
<p>如果忘记命令了，可以通过 <code>man -k terminal</code>进行关键词查找。</p>
<h2 id="浏览文件系统"><a href="#浏览文件系统" class="headerlink" title="浏览文件系统"></a>浏览文件系统</h2><h3 id="Linux中的目录"><a href="#Linux中的目录" class="headerlink" title="Linux中的目录"></a>Linux中的目录</h3><p>Linux采用名为“虚拟目录”的单个目录结构中。虚拟目录会将计算机中所有储存设备的文件路径都纳入单个目录结构。Linux的虚拟目录结构只包含一个叫做 root的目录的基础目录。所有文件都在root目录下一一列出。Linux中安装的第一块硬盘为根驱动器，所有目录都是从那里开始构建的。以下是kali的根目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿kali)-[/]</span><br><span class="line">└─<span class="comment"># ls</span></span><br><span class="line">bin   home            lib32       mnt   run       sys  vmlinuz</span><br><span class="line">boot  initrd.img      lib64       opt   sbin      tmp  vmlinuz.old</span><br><span class="line">dev   initrd.img.old  lost+found  proc  srv       usr</span><br><span class="line">etc   lib             media       root  swapfile  var</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里使用了ls命令来查看文件夹中的内容。常见的Linux目录名均基于文件系统层级标准（filesytem hierarchy standard, FHS）。</p>
<p>在Linux中，可以通过cd命令来切换目录。语法为 <code>cd destination</code>。使用 <code>cd ..</code>可以快速回到父目录。</p>
<p>使用 <code>pwd</code>命令可以了解当前工作目录。</p>
<p><code>ls</code>命令最基本的形式会显示当前目录下的文件和目录。使用 <code>ls -F</code>(注意，Linux系统严格区分大小写，-f和-F是两个不同的命令)可以区分文件和目录</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">┌──(root㉿kali)-[/]</span><br><span class="line">└─<span class="comment"># ls -F</span></span><br><span class="line">bin@   home/            lib32@       mnt/   run/      sys/  vmlinuz@</span><br><span class="line">boot/  initrd.img@      lib64@       opt/   sbin@     tmp/  vmlinuz.old@</span><br><span class="line">dev/   initrd.img.old@  lost+found/  proc/  srv/      usr/</span><br><span class="line">etc/   lib@             media/       root/  swapfile  var/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>-a选项能显示隐藏文件（通常是文件名以 . 开始的文件）</p>
<p>-R选项称作递归选项，能列出当前目录包含的子目录的文件与目录。</p>
<p>-l命令会产生长列表格式的输出，提供目录中各个文件的详细信息。在-l后跟上文件名即可只查看该文件的信息。</p>
<h3 id="过滤输出列表"><a href="#过滤输出列表" class="headerlink" title="过滤输出列表"></a>过滤输出列表</h3><p>ls命令支持在命令行中定义过滤器，使用过滤器来决定该在命令行中显示哪些文件或者目录。</p>
<p>在ls最后添加文件名是最基本的过滤方式，我们可以通过使用标准通配符来进行模式匹配。</p>
<ul>
<li>问号 （ ? ）代表任意单个字符</li>
<li>星号 （ * ）代表零个或者多个任意字符</li>
</ul>
<p>以 <code>/home/kali/</code>目录为例：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ <span class="built_in">ls</span> -F                </span><br><span class="line">backup/   Documents/  fill    Pictures/  tast.py  teeeeeeeesy.txt  test.py</span><br><span class="line">Desktop/  Downloads/  Music/  Public/    te3t.py  Templates/       Videos/</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ <span class="built_in">ls</span> t[a-z]st*</span><br><span class="line">tast.py  test.py</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ <span class="built_in">ls</span> t*       </span><br><span class="line">tast.py  te3t.py  teeeeeeeesy.txt  test.py</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ <span class="built_in">ls</span> t?st.py</span><br><span class="line">tast.py  test.py</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">┌──(kali㉿kali)-[~]</span><br><span class="line">└─$ <span class="built_in">ls</span> t[^/e]st.py       </span><br><span class="line">tast.py</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>!]可能被zsh认为是一个事件从而出错，把把方括号部分替换为 <code>&#39;[&#39;!what_you_think&#39;]&#39;</code>或者把 <code>!</code> 替换为 …<code>^/</code></p>
<p>Zsh（Z Shell）是一个强大的命令行解释器，用于 UNIX 操作系统。它是 Bourne Shell 的扩展，具有许多改进，包括更好的用户交互、功能强大的脚本能力和自定义功能。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://afogsheep.github.io/2024/04/10/cpp-learn%20/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="We losers do nothing so winners keeping winning <br> </br> 仍在施工中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杜鹃声">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/04/10/cpp-learn%20/" class="post-title-link" itemprop="url">C++学习</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-04-10 21:20:12" itemprop="dateCreated datePublished" datetime="2024-04-10T21:20:12+08:00">2024-04-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-05-01 16:16:07" itemprop="dateModified" datetime="2024-05-01T16:16:07+08:00">2024-05-01</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id=""><a href="#" class="headerlink" title=""></a></h1><h2 id="一个半循环"><a href="#一个半循环" class="headerlink" title=" 一个半循环 "></a><span style="font-size:1.2em;"> <strong>一个半循环</strong> </span></h2><p>思考以下的循环方式和 <strong>while(! input.fail())</strong> 的区别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> rowNumber = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="type">int</span> intValue;</span><br><span class="line">            <span class="type">double</span> doubleValue;</span><br><span class="line">            input &gt;&gt; intValue &gt;&gt; doubleValue;</span><br><span class="line">            <span class="keyword">if</span>(input.<span class="built_in">fail</span>()) <span class="keyword">break</span>;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(COLUMN_WIDTH) &lt;&lt; (rowNumber + <span class="number">1</span>) &lt;&lt; <span class="string">&quot; | &quot;</span>;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(COLUMN_WIDTH) &lt;&lt; intValue &lt;&lt; <span class="string">&quot; | &quot;</span>;</span><br><span class="line">            cout &lt;&lt; <span class="built_in">setw</span>(COLUMN_WIDTH) &lt;&lt; doubleValue &lt;&lt; endl;</span><br><span class="line"> rowNumber++;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<p>这种循环优点在于错误发生时能及时停止循环，若是后者，则总是会多执行一次循环。使用一个半循环而不是简单的 while 循环是有益的。</p>
<p>事实上，以上的代码可以简化成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int intValue;</span><br><span class="line">   double doubleValue;</span><br><span class="line">   while(input &gt;&gt; intValue &gt;&gt; doubleValue) &#123;</span><br><span class="line">       /* ... process values here ... */</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>直接将操作符运算放进 while 循环的判定条件中，能有效的减少代码的冗余。</p>
<h2 id="c-程序是如何运行的？"><a href="#c-程序是如何运行的？" class="headerlink" title=" c++程序是如何运行的？ "></a><span style="font-size:1.2em;"> <strong>c++程序是如何运行的？</strong> </span></h2><p>c++程序的运行分为三个部分：</p>
<p>​	<span style="font-size:1.1em;"> 预处理（preprocessing）  编译(compile)  连接(link)</span></p>
<ul>
<li>预处理：在预处理步骤中，称为预处理器的特殊程序会扫描 C++ 源代码并对其应用各种转换。例如，解析 #include 指令以使各种库可用，特殊标记（如 __FILE_ _和 _ _LINE__将替换为源文件中的文件和行号，#define-d 常量和宏替换为其适当的值</li>
<li>编译：在编译步骤中，编译器将 C++源文件读入、优化并转换为目标文件。这些目标文件是特定于机器的，但通常包含执行 C++ 文件中指定的指令的机器代码，以及一些额外的信息。在这个阶段，编译器将报告犯的任何语法错误，例如省略分号、引用未定义的变量或将错误类型的参数传递到函数中</li>
<li>连接：最后，在链接阶段，一个名为链接器的程序将构建最终可执行文件所需的所有目标文件收集在一起，将它们与特定于操作系统的信息捆绑在一起，最后生成一个多文件程序、抽象和可以运行和分发的预处理器可执行文件。在此阶段，链接器可能会报告一些最终错误，这些错误会阻止它生成有效的 C++ 程序。</li>
</ul>
<h2 id="包含保护（include-guard）"><a href="#包含保护（include-guard）" class="headerlink" title=" 包含保护（include guard）"></a><strong><span style="font-size:1.2em;"> 包含保护（include guard）</span></strong></h2><p>运用以下代码来防止头文件被重复利用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#ifndef file_Included</span><br><span class="line">#define file_Included</span><br><span class="line"></span><br><span class="line">#endif</span><br></pre></td></tr></table></figure>

<p>头文件的后缀是 <strong>.h</strong></p>
<h2 id="define-是什么？"><a href="#define-是什么？" class="headerlink" title="#define 是什么？"></a><strong><span style="font-size:1.2em;">#define 是什么？</span></strong></h2><p>运用以下格式，在整个代码中完成替换</p>
<p> <span style="font-style:italic;">#define phrase replacement </span></p>
<p>注意，被替换的判断是从第一个空格开始，#define 指令的替换部分由换行符前面的短语后的所有文本组成。同时默认替换后的文本将会是字符串。这个过程是在编译过程中进行的。如果全局定义了一个函数，那么在调用时会将其先转化成 c++代码。</p>
<h2 id="inline-内联函数"><a href="#inline-内联函数" class="headerlink" title=" inline, 内联函数 "></a><span style="font-size:1.2em;"> <strong>inline, 内联函数</strong> </span></h2><p>在计算机科学术语中，宏是内联的，因为编译器将“函数”的内容放在调用站点，而不是插入到函数代码的间接跳转。内联函数可能比非内联函数效率高得多.对一个函数使用 inline 关键字会建议编译器自动内联该函数，提高运行效率。inline 关键字只是对编译器的建议，如果编译器认为内联函数太难或成本太高，则可以忽略该关键字。但是，在编写短函数时，有时有助于将函数标记为内联以提高性能。</p>
<p>如以下代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">Max</span><span class="params">(<span class="type">int</span> one, <span class="type">int</span> two)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> one &gt; two ? one : two;</span><br><span class="line">   &#125; </span><br></pre></td></tr></table></figure>



<h2 id="向量小结"><a href="#向量小结" class="headerlink" title=" 向量小结 "></a><span style="font-size:1.2em;"> <strong>向量小结</strong> </span></h2><p>向量，作为一个允许我们使用单个变量存储元素序列的多功能工具，有着难以取代的非凡地位。向量可以储存所有类型的数据(不可以混储)，没有元素数量限制，增减元素都十分方便。仅仅需要在头文件中引入 <span style="color:#0000FF;"> include&lt;vector&gt; </span>。比如完成一个简单的从大到小排序的程序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetInteger</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> myInt;</span><br><span class="line">    cin &gt;&gt; myInt;</span><br><span class="line">    <span class="keyword">return</span> myInt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">size_t</span> <span class="title">GetSmallestIndex</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; v,<span class="type">size_t</span> startIndex)</span></span>&#123;</span><br><span class="line">    <span class="type">size_t</span> bestIndex = startIndex; <span class="comment">//size_t类型表示C中任何对象所能达到的最大长度，它是无符号整数。这里使用是因为index肯定是大于零的数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = startIndex; i &lt; v.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (v[i] &lt; v[bestIndex])</span><br><span class="line">            bestIndex = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bestIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">SelectionSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp; v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++i) &#123;  </span><br><span class="line">        <span class="type">size_t</span> smallestIndex = <span class="built_in">GetSmallestIndex</span>(v, i); </span><br><span class="line">        <span class="built_in">swap</span> (v[i], v[smallestIndex]);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; values; <span class="comment">//创建一个空向量</span></span><br><span class="line">    <span class="type">int</span> kNumValues = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="number">0</span> ;i &lt; kNumValues; ++i)&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;enter another value &quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="type">int</span> val =<span class="built_in">GetInteger</span>();</span><br><span class="line">        values.<span class="built_in">push_back</span>(val);  <span class="comment">//给向量赋值</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">SelectionSort</span>(values);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i&lt;values.<span class="built_in">size</span>(); ++i)&#123;</span><br><span class="line">        cout &lt;&lt; values[i]&lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也能通过以下格式初始化向量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">double</span>&gt; <span class="title">myReals</span><span class="params">(<span class="number">20</span>, <span class="number">137.0</span>)</span></span>;</span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">myStrings</span><span class="params">(<span class="number">5</span>, <span class="string">&quot;(none)&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>规定向量的元素上限以及填充内容。之后如果要改变向量元素上限可以使用&#96;.resize() 以下是示例</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; myVector;			<span class="comment">// Defaults to empty vector</span></span><br><span class="line"><span class="built_in">PrintVector</span>(myVector);			<span class="comment">// Output: [nothing]</span></span><br><span class="line"></span><br><span class="line">myVector.<span class="built_in">resize</span>(<span class="number">10</span>);			<span class="comment">// Grow the vector, setting new elements to 0</span></span><br><span class="line"><span class="built_in">PrintVector</span>(myVector);			<span class="comment">// Output: 0 0 0 0 0 0 0 0 0 0</span></span><br><span class="line"></span><br><span class="line">myVector.<span class="built_in">resize</span>(<span class="number">5</span>);				<span class="comment">// Shrink the vector</span></span><br><span class="line"><span class="built_in">PrintVector</span>(myVector);			<span class="comment">// Output: 0 0 0 0 0</span></span><br><span class="line"></span><br><span class="line">myVector.<span class="built_in">resize</span>(<span class="number">7</span>, <span class="number">1</span>);			<span class="comment">// Grow the vector, setting new elements to 1</span></span><br><span class="line"><span class="built_in">PrintVector</span>(myVector);			<span class="comment">// Output: 0 0 0 0 0 1 1</span></span><br><span class="line"></span><br><span class="line">myVector.<span class="built_in">resize</span>(<span class="number">1</span>, <span class="number">7</span>);			<span class="comment">// The second parameter is effectively ignored.</span></span><br><span class="line"><span class="built_in">PrintVector</span>(myVector);			<span class="comment">// Output: 0</span></span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<p><span style="font-size:1.2em;"> <strong>部分常见的向量操作</strong> </span></p>
<table>
<thead>
<tr>
<th>Constructor: vector ()</th>
<th>vector myVector; Constructs an empty vector</th>
</tr>
</thead>
<tbody><tr>
<td>Constructor: vector (size_type size)</td>
<td>vector myVector(10);                            Constructs a vector of the specified size where all elements  use their default values (for integral types, this is zero).</td>
</tr>
<tr>
<td>Constructor: vector (size_type size,                       const T&amp; default)</td>
<td>vector myVector(5, “blank”);                   Constructs a vector of the specified size where each  element is equal to the specified default value.</td>
</tr>
<tr>
<td>size_type size() const;</td>
<td>for(int i &#x3D; 0; i &lt; myVector.size(); ++i) { … } Returns the number of elements in the vector</td>
</tr>
<tr>
<td>bool empty() const;</td>
<td>while(! myVector.empty()) { … } Returns whether the vector is empty.</td>
</tr>
<tr>
<td>void clear();</td>
<td>myVector.clear(); <br /> Erases all the elements in the vector and sets the size to  zero.</td>
</tr>
<tr>
<td>T&amp; operator [] (size_type position); <br /> const T&amp; operator [] (size_type position) const;    <br /> T&amp; at(size_type position); const T&amp; at(size_type position) const;</td>
<td>myVector [0] &#x3D; 100; int x &#x3D; myVector [0]; myVector.at(0) &#x3D; 100; int x &#x3D; myVector.at(0); Returns a reference to the element at the specified position.  The bracket notation [] does not do any bounds checking  and has undefined behavior past the end of the data.  The at  member function will throw an exception if you try to  access data beyond the end.  We will cover exception  handling in a later chapter</td>
</tr>
<tr>
<td>void resize(size_type newSize); void resize(size_type newSize, T fill);</td>
<td>myVector.resize(10); myVector.resize(10, “default”); Resizes the vector so that it’s guaranteed to be the specified  size.  In the second version, the vector elements are  initialized to the value specified by the second parameter.  Elements are added to and removed from the end of the  vector, so you can’t use resize to add elements to or remove  elements from the start of the vector</td>
</tr>
<tr>
<td>void push_back();</td>
<td>myVector.push_back(100); Appends an element to the vector</td>
</tr>
<tr>
<td>T&amp; back(); const T&amp; back() const;</td>
<td>myVector.back() &#x3D; 5; int lastElem &#x3D; myVector.back(); Returns a reference to the last element in the vector.</td>
</tr>
</tbody></table>
<p>续表：</p>
<table>
<thead>
<tr>
<th>T&amp; front(); const T&amp; front() const;</th>
<th>myVector.front() &#x3D; 0; int firstElem &#x3D; myVector.front(); Returns a reference to the first element in the vector.</th>
</tr>
</thead>
<tbody><tr>
<td>void pop_back();</td>
<td>myVector.pop_back(); <br /> Removes the last element from the vector.</td>
</tr>
<tr>
<td>iterator begin(); const_iterator begin() const;</td>
<td>vector:: iterator itr &#x3D; myVector.begin(); <br /> Returns an iterator that points to the first element in the  vector</td>
</tr>
<tr>
<td>iterator end(); const_iterator end() const;</td>
<td>while(itr !&#x3D; myVector.end()); <br /> Returns an iterator to the element after the last.  The  iterator returned by end does not point to an element in the  vector.</td>
</tr>
<tr>
<td>iterator insert(iterator position,                 const T&amp; value); void insert(iterator start,             size_type numCopies,             const T&amp; value);</td>
<td>myVector.insert(myVector.begin() + 4, “Hello”); myVector.insert(myVector.begin(), 2, “Yo!”); <br /> The first version inserts the specified value into the vector,  and the second inserts numCopies copies of the value into  the vector.  Both calls invalidate all outstanding iterators for  the vector.</td>
</tr>
<tr>
<td>iterator erase(iterator position); iterator erase(iterator start,               iterator end);</td>
<td>myVector.erase(myVector.begin()); <br /> myVector.erase(startItr, endItr); <br /> The first version erases the element at the position pointed  to by position.  The second version erases all elements in the  range [startItr, endItr).  Note that this does not erase  the element pointed to by endItr.  All iterators after the  remove point are invalidated.  If using this member  function on a deque (see below), all iterators are  invalidated.</td>
</tr>
</tbody></table>
<h2 id="Deque"><a href="#Deque" class="headerlink" title=" Deque "></a><span style="font-size:1.2em;"> <strong>Deque</strong> </span></h2><p>称作 double_end_queue。也就是双端队列和 vector 相较有许多类似的操作，比如 resize，push.back 等。但是与 vector 最大的不同是，在 STL 实现的储存空间是不连续的大片“page”，而 vector 的是连续的空间.</p>
<p><img src="E:\Blog\source_posts\assets\image-20240320165928508-1713452721015-1.png" alt="image-20240320165928508"></p>
<p>优点：(1) 随机访问方便，即支持 [ ] 操作符和 vector.at()<br>      (2) 在内部方便的进行插入和删除操作<br>      (3) 可在两端进行 push、pop</p>
<p>缺点：占用内存多</p>
<h1 id="四个新的容器类"><a href="#四个新的容器类" class="headerlink" title="四个新的容器类"></a>四个新的容器类</h1><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>设想一个程序，它能计算出连续扔骰子，直到扔出的点数与第一次相同时所需的次数，以下是采用向量的实现方式：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;random&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//摇骰子</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">DieRoll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="built_in">rand</span>() %<span class="number">6</span>) +<span class="number">1</span>; <span class="comment">//确保返回是一到六的整数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">RunProcess</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; generate;  <span class="comment">//储存重复前摇出的数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">int</span> NextVaule = <span class="built_in">DieRoll</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> k =<span class="number">0</span> ; k &lt; generate.<span class="built_in">size</span>(); ++k)&#123;</span><br><span class="line">            <span class="keyword">if</span> (generate[k] == NextVaule)&#123; <span class="comment">//满足说明已经重复了</span></span><br><span class="line">                <span class="keyword">return</span> generate.<span class="built_in">size</span>() + <span class="number">1</span>; <span class="comment">//加一是为了返还摇动的总次数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    generate.<span class="built_in">push_back</span>(NextVaule);    <span class="comment">//不是就把数字保存进去</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">size_t</span> kNumIterations = <span class="number">10000</span>;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">srand</span>(<span class="built_in">static_cast</span>&lt;<span class="type">unsigned</span>&gt;(<span class="built_in">time</span>(<span class="literal">NULL</span>)));</span><br><span class="line">    <span class="type">float</span> total2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span> ; i&lt; kNumIterations ; ++i)&#123;</span><br><span class="line">        <span class="type">size_t</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">size_t</span> k = <span class="number">0</span>; k&lt; kNumIterations ;++k)&#123;</span><br><span class="line">            total += <span class="built_in">RunProcess</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    total2 += <span class="built_in">float</span>(total) / kNumIterations;</span><br><span class="line">    </span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;ultimate unswer is &quot;</span> &lt;&lt; total2 / kNumIterations &lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当我们扔常见的六面骰子时，结果似乎很合理：</p>
<p><img src="E:\Blog\source_posts\assets\image-20240408110931050-1713452721015-2.png" alt="image-20240408110931050"></p>
<p>当重复次数增加这个数字的精度也会变大。但是如果我们扔的是个八面骰子呢？</p>
<p><img src="E:\Blog\source_posts\assets\image-20240408111044967-1713452721015-4.png" alt="image-20240408111044967"></p>
<p>到重复时所需要的数字并没增大许多。那要是我们正在玩博德之门3，需要连续过两个高难检定呢？</p>
<p><img src="E:\Blog\source_posts\assets\image-20240408111222882-1713452721015-3.png" alt="image-20240408111222882"></p>
<p>仅仅需要大概6次就可以重复？？虽然这是个概率论问题，但我们可以注意到我们所使用的容器——向量。答案在于 RunProcess 函数的实现。此函数的核心是一个 for 循环，用于检查向量中是否包含特定值。直观地说，向量保持元素的有序序列。对向量的主要操作通过在该序列中添加和删除元素、查找该序列中特定位置的元素等来维护该序列。对于此应用程序，我们希望存储一个无序的数字集合。我们不关心元素何时被添加到向量中或它们占据什么位置。相反，我们感兴趣的是向量中有哪些元素，特别是给定的元素是否在向量中。</p>
<h2 id="容器-set"><a href="#容器-set" class="headerlink" title="容器:set"></a>容器:set</h2><p>当元素集合的内容比元素所在的容器内的实际序列更重要时，便可以采用set容器。跟向量相比，set提供了一个任意的，无序的特殊容器，并且对以下的操作有很好的支持：</p>
<ul>
<li><p>将元素添加到集合中</p>
</li>
<li><p>从集合中删去元素</p>
</li>
<li><p>确认集合中是否包含特定元素</p>
<p>回到引子中那个问题，尝试用set来替换使用过向量的部分：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="type">size_t</span> <span class="title">RunProcess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       set&lt;<span class="type">int</span>&gt; generated;</span><br><span class="line">       <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">           <span class="type">int</span> nextValue = <span class="built_in">DieRoll</span>();</span><br><span class="line">           <span class="comment">/* Check if this value has been rolled before. */</span></span><br><span class="line">           <span class="keyword">if</span> (generated.<span class="built_in">count</span>(nextValue)) <span class="keyword">return</span> generated.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line">           <span class="comment">/* Otherwise, add this value to the set. */</span></span><br><span class="line">generated.<span class="built_in">insert</span>(nextValue);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p>运行后的结果还是大差不差。</p>
<h3 id="set的基本操作"><a href="#set的基本操作" class="headerlink" title="set的基本操作"></a>set的基本操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//容器之间的操作大多具有相似性</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    set&lt;<span class="type">int</span>&gt; myset;</span><br><span class="line">    <span class="comment">//插入元素</span></span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="number">124</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="number">125</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="number">14</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="number">1324</span>);</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">//检查元素是否在集合中</span></span><br><span class="line">    <span class="keyword">if</span>(myset.<span class="built_in">count</span>(<span class="number">1</span>))&#123;cout&lt;&lt; <span class="string">&quot;there is it&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="keyword">if</span>(!myset.<span class="built_in">count</span>(<span class="number">1000</span>))&#123;cout &lt;&lt; <span class="string">&quot;there is not it&quot;</span> &lt;&lt; endl;&#125;</span><br><span class="line">    <span class="comment">//删除集合中元素</span></span><br><span class="line">    myset.<span class="built_in">erase</span>(<span class="number">125</span>);</span><br><span class="line">    <span class="comment">//也可以使用clear来清除元素，size来查看容器大小，等等类似操作</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="迭代器初探"><a href="#迭代器初探" class="headerlink" title="迭代器初探"></a>迭代器初探</h3><h4 id="为什么要使用迭代器？"><a href="#为什么要使用迭代器？" class="headerlink" title="为什么要使用迭代器？"></a>为什么要使用迭代器？</h4><p>在最开始的C语言学习中，我们就已经习惯了用for循环来遍历数组的操作。这当然是一个很简洁方便的方法，但假如我们要遍历的容器不是数组呢？甚至这个容器不存在自带的顺序呢？（就如刚才提到的set），这时候再使用for循环就显得力不从心了。但是对于用迭代器来说刚好。如下所示：</p>
<h4 id="实际操作"><a href="#实际操作" class="headerlink" title="实际操作"></a>实际操作</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; myVector = &#123;<span class="number">9</span>,<span class="number">564</span>,<span class="number">94</span>,<span class="number">71</span>,<span class="number">62</span>,<span class="number">6933</span>,<span class="number">122</span>,<span class="number">47</span>,<span class="number">6</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator itr = myVector.<span class="built_in">begin</span>();</span><br><span class="line">    itr != myVector.<span class="built_in">end</span>();++itr)&#123;</span><br><span class="line">        cout &lt;&lt; *itr &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>到这里还有一个问题，就是当遇见无序容器时，迭代器遍历的顺序是如何的？当使用向量或 deque 时，有一个自然的迭代顺序（从序列的开始到结束），但是当使用 STL 集时，排序的概念有点模糊。但是，<strong>集合的迭代顺序是明确指定的。通过迭代器遍历集合元素时，将按排序顺序访问元素，从最小的元素开始，到最大的元素结束</strong>。这在一定程度上解释了为什么 STL 集合只能存储使用 less-than 运算符可比较的元素：如果无法比较元素，则集合中没有明确定义的“最小”或“最大”元素。若要查看其实际操作，请考虑以下代码片段：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 生成随机数 */</span></span><br><span class="line">    set&lt;<span class="type">int</span>&gt; randomNumbers;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">size_t</span> k = <span class="number">0</span>; k &lt; <span class="number">10</span>; ++k)</span><br><span class="line">        randomNumbers.<span class="built_in">insert</span>(<span class="built_in">rand</span>());</span><br><span class="line">    <span class="comment">/* 顺序打印集合内容 */</span></span><br><span class="line">    <span class="keyword">for</span> (set&lt;<span class="type">int</span>&gt;::iterator itr = randomNumbers.<span class="built_in">begin</span>(); </span><br><span class="line">         itr != randomNumbers.<span class="built_in">end</span>(); ++itr)</span><br><span class="line">        cout &lt;&lt; *itr &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>正如刚才所做到的，使用迭代器有三个主要操作：</p>
<ul>
<li><strong>取消迭代器的引用</strong></li>
<li><strong>将迭代器从一个位置推进到另外一个位置</strong></li>
<li><strong>比较两个迭代器是否相等</strong></li>
</ul>
<p>迭代器的功能当然不止读取内容，也能写入内容，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(vector&lt;<span class="type">int</span>&gt;::iterator ite = myVector.<span class="built_in">begin</span>();</span><br><span class="line">    ite != myVector.<span class="built_in">end</span>(); ++ite)</span><br><span class="line">    myVector.<span class="built_in">insert</span>(<span class="number">123</span>);</span><br></pre></td></tr></table></figure>

<p>由于迭代器提供了一种间接读取和写入容器元素的方法，因此可以通过操作容器类中的迭代器来编写对任何容器类中的数据进行操作的函数。这些函数称为 STL 算法。</p>
<p>现在让我们尝试一下用迭代器对字符串类型的容器进行操作。假设我们想要打印某个字符串向量的所有元素的长度，我们很可能会这样写：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (set&lt;string&gt;::iterator itr = mySet.<span class="built_in">begin</span>(); itr != mySet.<span class="built_in">end</span>(); ++itr)</span><br><span class="line">        cout &lt;&lt; *itr.<span class="built_in">length</span>() &lt;&lt; endl; <span class="comment">// Error: Incorrect syntax!</span></span><br></pre></td></tr></table></figure>

<p>原因是编译器把我们的代码理解成了<code>\*(itr.length())</code>而不是<code>(*itr).length()</code>。</p>
<p>为了解决此问题，所有 STL 迭代器都支持并调用了箭头运算符，该运算符允许您在当前正在迭代的元素上调用成员函数。例如，要打印出集合中所有字符串的长度<string>，正确的语法是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (set&lt;string&gt;::iterator itr = mySet.<span class="built_in">begin</span>(); itr != mySet.<span class="built_in">end</span>(); ++itr)</span><br><span class="line">       cout &lt;&lt; itr-&gt;<span class="built_in">length</span>() &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<h3 id="迭代的范围定义"><a href="#迭代的范围定义" class="headerlink" title="迭代的范围定义"></a>迭代的范围定义</h3><p>容易注意到我们之前的循环控制是靠 <code>mySet.begin()</code>与 <code>mySet.end()</code>。前者指定迭代范围开始的第一个元素，后者定义迭代范围末尾的元素。单个迭代器指向容器类中的单个位置，并表示间接读取或写入该值的方法。一对迭代器定义两个位置，从而定义一系列元素。具体而言，给定两个迭代器 start 和 stop，这些迭代器定义从 start 开始到停止前一个位置结束的元素范围。使用数学符号，由开始和停止跨度定义的元素范围 [start， stop)。</p>
<p>由于集合本身把元素按顺序排列的性质，我们可以尝试：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt;::iterator stop = mySet.<span class="built_in">upper_bound</span>(<span class="number">100</span>);</span><br><span class="line">   <span class="keyword">for</span>(set&lt;<span class="type">int</span>&gt;::iterator itr = mySet.<span class="built_in">lower_bound</span>(<span class="number">10</span>); itr != stop; ++itr)</span><br><span class="line">       cout &lt;&lt; *itr &lt;&lt; endl;</span><br></pre></td></tr></table></figure>

<p><strong>upper_bound</strong> 和 <strong>lower_bound</strong> 的美妙之处在于，指定为函数参数的元素是否实际存在于集合中并不重要(假如要求的元素不存在就会直接返还到开头或者末尾)。例如，假设我们在包含 3 到 137 之间的所有奇数的集合上运行上述 for 循环。在本例中，集合中既不包含 10 也不包含 100。但是，代码仍将正常工作。lower_bound 函数向第一个元素返回一个迭代器，其大小至少与其参数一样大，并且在奇数集中将向元素 11 返回一个迭代器。类似地，upper_bound 向第一个元素返回一个迭代器，严格大于其参数，因此将向元素 101 返回一个迭代器。</p>
<h3 id="集合的常用函数"><a href="#集合的常用函数" class="headerlink" title="集合的常用函数"></a>集合的常用函数</h3><table>
<thead>
<tr>
<th>Constructor: set<T>()</th>
<th>set<int> mySet; 构造一个空集合。</th>
</tr>
</thead>
<tbody><tr>
<td>Constructor: set<T>(const set<T>&amp; other)</td>
<td>set<int> myOtherSet &#x3D; mySet; 构造一个另一个集合的副本。</td>
</tr>
<tr>
<td>Constructor: set<T>(InputIterator start, InputIterator stop)</td>
<td>set<int> mySet(myVec.begin(), myVec.end()); 构造一个包含特定范围（[start, stop)）内元素的副本的集合。任何重复的元素都将被丢弃，并且元素将被排序。注意，这个函数接受来自任何来源的迭代器。</td>
</tr>
<tr>
<td>size_type size() const</td>
<td>int numEntries &#x3D; mySet.size(); 返回集合中包含的元素数量</td>
</tr>
<tr>
<td>bool empty() const</td>
<td>if(mySet.empty()) { … } 返回集合是否为空。</td>
</tr>
<tr>
<td>void clear()</td>
<td>mySet.clear(); 从集合中移除所有元素。</td>
</tr>
<tr>
<td>iterator begin() const_iterator begin() const</td>
<td>set<int>::iterator itr &#x3D; mySet.begin(); 返回一个迭代器指向集合的开始。在就地修改元素时要小心。</td>
</tr>
<tr>
<td>iterator end() const_iterator end() const</td>
<td>while(itr !&#x3D; mySet.end()) { … } 返还迭代器到最后一个元素后面</td>
</tr>
<tr>
<td>insert(const T&amp; value)</td>
<td>第一个版本将指定的值插入集合中。返回类型是一个包含指向元素的迭代器和一个bool值的对，bool值指示元素是否成功插入（真）或者是否已经存在（假）。</td>
</tr>
<tr>
<td>void insert(InputIterator begin, InputIterator end)</td>
<td>第二个版本将指定范围的元素插入集合中，忽略重复项。</td>
</tr>
<tr>
<td>const_iterator find(const T&amp; element) const</td>
<td>如果指定元素存在，则返回指向该元素的迭代器；否则，返回end。</td>
</tr>
<tr>
<td>size_type count(const T&amp; item) const</td>
<td>如果指定元素包含在集合中，则返回1；否则，返回0。</td>
</tr>
<tr>
<td>size_type erase(const T&amp; element) void erase(iterator itr); void erase(iterator start, iterator stop);</td>
<td>从集合中移除一个元素。在第一个版本中，如果找到指定元素，则将其移除，并且如果元素被移除则函数返回1，如果元素不在集合中则返回0。第二个版本移除itr指向的元素。最后一个版本擦除[start, stop)范围内的元素。</td>
</tr>
<tr>
<td>iterator lower_bound(const T&amp; value)</td>
<td>返回指向第一个大于或等于指定值的元素的迭代器。这个函数对于获取一系列元素的迭代器特别有用，尤其是与upper_bound一起使用时。</td>
</tr>
<tr>
<td>iterator upper_bound(const T&amp; value)</td>
<td>返回指向第一个大于指定值的元素的迭代器。因为这个元素必须严格大于指定值，你可以迭代一个范围，直到迭代器等于upper_bound，以获得所有小于或等于参数的元素。</td>
</tr>
</tbody></table>
<h2 id="容器-Map"><a href="#容器-Map" class="headerlink" title="容器:Map"></a>容器:Map</h2><h3 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h3><p>pair 是一个参数化类，它只保存两个任意类型的值。其中定义的 <code>pair &lt;utility&gt;</code>接受两个模板参数。定义的声明是：  <code>pair&lt;TypeOne, TypeTwo&gt;</code>。如下示范：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//基本操作</span><br><span class="line">pair&lt;int, string&gt; myPair;</span><br><span class="line">	myPair.first  =  137;</span><br><span class="line">   myPair.second = &quot;C++ is awesome!&quot;;</span><br><span class="line">   //动态设置</span><br><span class="line">    pair&lt;int, string&gt; myPair = make_pair(137, &quot;string!&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="Map的基本操作"><a href="#Map的基本操作" class="headerlink" title="Map的基本操作"></a>Map的基本操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>,string&gt; mymap;</span><br><span class="line">    mymap[<span class="number">0</span>] = <span class="string">&quot;zero&quot;</span>;</span><br><span class="line">    mymap[<span class="number">1</span>] = <span class="string">&quot;one&quot;</span>;</span><br><span class="line">    mymap[<span class="number">2</span>] = <span class="string">&quot;two&quot;</span>;</span><br><span class="line">    mymap[<span class="number">3</span>] = <span class="string">&quot;three&quot;</span>;</span><br><span class="line">    cout &lt;&lt; mymap[<span class="number">1</span>] &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; mymap[<span class="number">99</span>] &lt;&lt; endl;<span class="comment">//假如调用一个没有的键值对，那么map会自动创建对应的键，并把其对应的值初始化int类型的是0,string是&quot;&quot;</span></span><br><span class="line">    <span class="comment">//对MAP使用迭代器</span></span><br><span class="line">    map&lt;<span class="type">int</span>,string&gt;::iterator itr = mymap.<span class="built_in">find</span>(<span class="number">13</span>); <span class="comment">//find()可以寻找map类型里的键</span></span><br><span class="line">    <span class="keyword">if</span>(itr == mymap.<span class="built_in">end</span>())&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;未找到对应键&quot;</span> &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;存在key是&quot;</span> &lt;&lt; itr-&gt;first &lt;&lt; <span class="string">&quot;，值是&quot;</span> &lt;&lt; itr-&gt;second &lt;&lt; <span class="string">&quot;的数据&quot;</span> &lt;&lt; endl; <span class="comment">//迭代器访问地图的方式</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//迭代map</span></span><br><span class="line">    <span class="keyword">for</span>(map&lt;<span class="type">int</span>,string&gt;::iterator itr = mymap.<span class="built_in">begin</span>();itr != mymap.<span class="built_in">end</span>() ; itr++)&#123;</span><br><span class="line">        cout &lt;&lt; itr-&gt;first &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; itr-&gt;second &lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    mymap.<span class="built_in">erase</span>(<span class="number">99</span>);<span class="comment">//键不能更改但是可以删除</span></span><br><span class="line">    <span class="comment">//mymap.clear();//删除所有键值对</span></span><br><span class="line">    <span class="comment">//mymap.size(); //获取键值对数目</span></span><br><span class="line"></span><br><span class="line">    mymap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">4</span>,<span class="string">&quot;four&quot;</span>));<span class="comment">//利用insert函数进行插入</span></span><br><span class="line">    mymap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="number">5</span>,<span class="string">&quot;five&quot;</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，map的底层逻辑和set一样是平衡二叉树实现的，所以用迭代器输出时是按从小到大的排列顺序。即使是string类的输出也会按照字母表的顺序。</p>
<h3 id="在Map中使用-insert-需要注意"><a href="#在Map中使用-insert-需要注意" class="headerlink" title="在Map中使用 insert()需要注意"></a>在Map中使用 <code>insert()</code>需要注意</h3><p>如上所示，map的<code>insert()</code> 与集合的插入函数一样，只需要指定要插入的内容使用即可，因为映射与集合一样，不会按特定顺序存储值。但是，由于映射将元素存储为键&#x2F;值对，因此插入函数的参数应为包含键和值的对对象。</p>
<p>下面请考虑以下两个向map中添加键值对的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Populate a map using [ ] */</span></span><br><span class="line">    map&lt;string, string&gt; one;</span><br><span class="line">    one[<span class="string">&quot;C++&quot;</span>] = <span class="string">&quot;sad&quot;</span>;</span><br><span class="line">    one[<span class="string">&quot;C++&quot;</span>] = <span class="string">&quot;happy&quot;</span>;</span><br><span class="line"><span class="comment">/* Populate a map using insert */</span></span><br><span class="line">    map&lt;string, string&gt; two;</span><br><span class="line">    two.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;C++&quot;</span>, <span class="string">&quot;sad&quot;</span>));</span><br><span class="line">    two.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;C++&quot;</span>, <span class="string">&quot;happy&quot;</span>));</span><br></pre></td></tr></table></figure>

<p>运行后结果：</p>
<p><img src="E:\Blog\source_posts\assets\image-20240417164442494-1713452721015-5.png" alt="image-20240417164442494"></p>
<p>为什么会出现这种情况呢？原因是：map和set相似，key一旦被创建就不能再进行修改，而使用方括号对map进行的更新都是永久性的。当检测到后续增加的key与已有的重复时，会对原有的值进行覆盖。但是insert函数就没有这种权限，遇见已有的键时不能进行修改。也不会更新与现有键关联的值。为了缓解这种情况，我们可以</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Try to insert normally. */</span></span><br><span class="line">pair&lt;map&lt;string, <span class="type">int</span>&gt;::iterator, <span class="type">bool</span>&gt; result = </span><br><span class="line">       myMap.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;STL&quot;</span>, <span class="number">137</span>));</span><br><span class="line"><span class="comment">/* If insertion failed, manually set the value. */</span></span><br><span class="line"><span class="keyword">if</span>(!result.second)</span><br><span class="line">       result.first-&gt;second = <span class="number">137</span>;</span><br></pre></td></tr></table></figure>

<p>解释一下上面的代码，在 C++ 中，<code>std::map::insert</code> 方法在插入元素时返回一个 <code>pair</code> 对象，这个 <code>pair</code> 对象包含两个部分：</p>
<ol>
<li><strong>第一个部分</strong>：一个迭代器，指向插入的元素或者已经存在于 <code>std::map</code> 中具有相同键的元素。如果插入成功，则这个迭代器指向新插入的元素；如果插入失败（因为键已存在），则这个迭代器指向已经存在的元素。</li>
<li><strong>第二个部分</strong>：一个布尔值，表示插入操作的结果。如果插入成功，则为 <code>true</code>；如果插入失败（因为键已存在），则为 <code>false</code>。</li>
</ol>
<p>这样的设计允许开发者在执行插入操作后，通过一个函数调用同时获得插入位置的迭代器和插入操作的结果。这在处理插入可能失败的情况时非常方便，因为我们可以根据插入的结果来决定下一步的操作，而不需要额外的查找操作。如果插入失败，即键已存在，通过 <code>result.first</code> 可以获取到已存在的元素的迭代器，然后可以在其上进行操作，如更新其值。</p>
<h3 id="Map的常用函数"><a href="#Map的常用函数" class="headerlink" title="Map的常用函数"></a>Map的常用函数</h3><table>
<thead>
<tr>
<th>函数&#x2F;方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>map&lt;K, V&gt;()</code></td>
<td>构造一个空的 map。</td>
</tr>
<tr>
<td><code>map&lt;K, V&gt;(const map&lt;K, V&gt;&amp; other)</code></td>
<td>构造一个其他 map 的副本。</td>
</tr>
<tr>
<td><code>map&lt;K, V&gt;(InputIterator start, InputIterator stop)</code></td>
<td>构造一个包含指定范围元素副本的 map，任何重复的元素都会被丢弃，并且元素会被排序。注意，此函数接受来自任何来源的迭代器，但它们必须是对键值对的迭代器。</td>
</tr>
<tr>
<td><code>size_type size() const</code></td>
<td>返回 map 中包含的元素数量。</td>
</tr>
<tr>
<td><code>bool empty() const</code></td>
<td>返回 map 是否为空。</td>
</tr>
<tr>
<td><code>void clear()</code></td>
<td>从 map 中移除所有元素。</td>
</tr>
<tr>
<td><code>iterator begin()</code></td>
<td><code>const_iterator begin() const</code> 返回指向 map 开始的迭代器。</td>
</tr>
<tr>
<td><code>iterator end()</code></td>
<td><code>const_iterator end() const</code> 返回指向 map 结束后一个元素的迭代器。</td>
</tr>
<tr>
<td><code>pair&lt;iterator, bool&gt; insert(const pair&lt;const K, V&gt;&amp; value)</code></td>
<td>插入指定的键值对到 map 中。返回一个 pair，包含一个指向元素的迭代器和一个表示插入是否成功的布尔值。</td>
</tr>
<tr>
<td><code>void insert(InputIterator begin, InputIterator end)</code></td>
<td>插入指定范围的元素到 map 中，忽略重复元素。</td>
</tr>
<tr>
<td><code>V&amp; operator[] (const K&amp; key)</code></td>
<td>返回与指定键关联的值，如果键不存在，则创建一个新的键值对，并将值初始化为零（如果它是原始类型）或默认值（对于非原始类型）。</td>
</tr>
</tbody></table>
<p>续表：</p>
<table>
<thead>
<tr>
<th>函数&#x2F;方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td><code>iterator find(const K&amp; element)</code></td>
<td><code>const_iterator find(const K&amp; element) const</code> 如果存在指定键的键值对，则返回指向其的迭代器，否则返回 <code>end</code> 迭代器。</td>
</tr>
<tr>
<td><code>size_type count(const K&amp; item)</code></td>
<td>返回在 map 中具有指定键的键值对的数量。如果存在，返回 1，否则返回 0。</td>
</tr>
<tr>
<td><code>size_type erase(const K&amp; element)</code></td>
<td>移除具有指定键的键值对。第一版本中，如果找到具有指定键的键值对，则将其移除，并返回 1；否则返回 0。</td>
</tr>
<tr>
<td><code>void erase(iterator itr)</code></td>
<td>移除由迭代器 <code>itr</code> 指向的键值对。</td>
</tr>
<tr>
<td><code>void erase(iterator start, iterator stop)</code></td>
<td>移除指定范围内的键值对，范围为 <code>[start, stop)</code>。</td>
</tr>
<tr>
<td><code>iterator lower_bound(const K&amp; value)</code></td>
<td>返回一个指向第一个键值对的迭代器，其键大于或等于指定值。此函数可用于获取一系列元素的迭代器，特别是与 <code>upper_bound</code> 结合使用。</td>
</tr>
<tr>
<td><code>iterator upper_bound(const K&amp; value)</code></td>
<td>返回一个指向第一个键值对的迭代器，其键严格大于指定值。因为这个元素必须严格大于指定值，所以可以在迭代器等于 <code>upper_bound</code> 之前迭代一个范围，以获取所有小于或等于参数的元素。</td>
</tr>
</tbody></table>
<h2 id="Practice-Problems"><a href="#Practice-Problems" class="headerlink" title="Practice Problems"></a>Practice Problems</h2><ol>
<li><p>您如何检查一个元素是否包含在STL set中？</p>
<ul>
<li>使用STL set的成员函数<code>count</code>来检查元素是否存在。如果元素存在，则<code>count</code>函数返回1；如果不存在，则返回0。</li>
</ul>
</li>
<li><p>对于STL set，存储的类型必须支持严格的弱序比较（<code>strict weak ordering</code>）。这意味着类型必须具有定义了小于运算符（<code>operator&lt;</code>）的排序规则。相比之下，vector或deque没有这个限制。</p>
</li>
<li><p>您如何将一个元素插入到一个集合中？如何从集合中移除一个元素？</p>
<ul>
<li>若要将元素插入到set中，可以使用成员函数<code>insert</code>。若要从集合中移除元素，可以使用成员函数<code>erase</code>。</li>
</ul>
</li>
<li><p>一个单一元素在set中可以存在多少个副本？在multiset中呢？</p>
<ul>
<li>在set中，由于元素必须唯一，因此只能有一个副本。而在multiset中，可以包含多个相同的元素。</li>
</ul>
</li>
<li><p>您如何迭代遍历set的内容？</p>
<ul>
<li>可以使用迭代器进行遍历，例如使用<code>begin()</code>和<code>end()</code>函数，或者使用范围循环（range-based loop）。</li>
</ul>
</li>
<li><p>您如何检查一个键是否包含在STL map中？</p>
<ul>
<li>使用STL map的成员函数<code>find</code>来检查键是否存在。如果键存在，<code>find</code>函数返回指向该键-值对的迭代器；如果不存在，则返回指向map末尾的迭代器。</li>
</ul>
</li>
<li><p>列举两种您可以向STL map中插入键&#x2F;值对的方法。</p>
<ul>
<li>可以使用<code>insert</code>函数插入键&#x2F;值对，或者使用下标运算符<code>[]</code>直接赋值。</li>
</ul>
</li>
<li><p>如果您使用方括号在STL map中查找与不存在的键关联的值会发生什么？如果使用<code>find</code>函数呢？</p>
<ul>
<li>如果使用方括号运算符<code>[]</code>查找不存在的键，则会在map中插入一个新的键-值对，值为默认值。而如果使用<code>find</code>函数，则返回指向map末尾的迭代器。</li>
</ul>
</li>
<li><p>回想一下，在迭代STL multiset的内容时，元素将按照排序顺序进行访问。利用这一特性，重写上一章的程序，该程序从用户处读取一系列数字，然后按排序顺序打印它们。为什么需要使用multiset而不是常规的set？</p>
<ul>
<li>使用multiset而不是set的原因是multiset允许存储多个相同的元素，因此可以按顺序保存重复的数字。</li>
</ul>
</li>
<li><p>两个集合的并集是包含在两个集合中至少一个集合中的元素的集合。编写一个函数Union，它接受两个set<int>，并返回它们的并集。</p>
</li>
<li><p>两个集合的交集是包含在两个集合中的元素的集合。编写一个函数Intersection，它接受两个set<int>，并返回它们的交集。</p>
</li>
<li><p>在本章中的早些时候，我们编写了一个程序，它连续掷骰子直到相同的数字连续出现两次，然后打印出投掷的次数。重写此程序，以便相同的数字必须连续出现三次才能终止该过程。当掷20面骰子时，您预计此过程将进行多少次？（提示：您可能希望从使用set切换到使用multiset。还要记住set的count函数和multiset的count函数之间的区别。）</p>
</li>
<li><p>正如本章中提到的，您可以使用lower_bound和upper_bound的组合来迭代闭区间[min，max]中的元素。使用这两个函数的什么组合可以用来迭代区间[min，max）？[min，max]和（min，max）呢？</p>
</li>
<li><p>编写一个函数NumberDuplicateEntries，它接受一个map&lt;string，string&gt;，并返回map中重复值的数量（即，map中具有相同值的键&#x2F;值对的数量）。</p>
</li>
<li><p>编写一个函数InvertMap，它接受一个map&lt;string, string&gt;作为输入，并返回一个multimap&lt;string, string&gt;，其中源map中的每对（键，值）在生成的multimap中都由（值，键）表示。为什么在这里使用multimap是必要的？您如何使用上一个问题中的NumberDuplicateEntries函数来确定是否可以将map反转为另一个map？</p>
</li>
</ol>
<p>使用multimap的原因是在原始映射中，键是唯一的，但值不一定是唯一的。当将键映射到值时，可能会出现多个键映射到相同的值的情况。因此，使用multimap允许我们将多个键映射到相同的值。我们可以使用NumberDuplicateEntries函数来检查源映射中是否存在重复的值。如果NumberDuplicateEntries返回0，则表示源映射中的值是唯一的，可以进行反转。</p>
<ol start="16">
<li>假设我们有两个名为one和two的map&lt;string, string&gt;。我们可以定义one和two的组合（表示为two ○ one）如下：对于任意字符串r，如果one[r]是s，且two[s]是t，则(two ○ one)[r] &#x3D; t。也就是说，在组合映射中查找元素x等效于在one中查找与x关联的值，然后在two中查找其关联的值。如果one不包含r作为键，或者one[r]不是two中的键，则(two ○ one)[r]是未定义的。</li>
</ol>
<p>​		编写一个名为ComposeMaps的函数，它接受两个map&lt;string, string&gt;，并返回一个包含它们组合的		map&lt;string, string&gt;。</p>
<ol start="17">
<li>（挑战问题！）编写一个函数PrintMatchingPrefixes，它接受一个set<string>和一个包含前缀的字符串，并打印出所有以该前缀开头的集合条目。您的函数应仅迭代最终打印出的条目。您可以假设前缀是非空的，仅由字母数字字符组成，并且应区分大小写。 （提示：在set<string>中，字符串按字典顺序排序，因此所有以“abc”开头的字符串将位于所有以“abd”开头的字符串之前。）</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://afogsheep.github.io/2024/03/04/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="We losers do nothing so winners keeping winning <br> </br> 仍在施工中">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="杜鹃声">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2024/03/04/hello-world/" class="post-title-link" itemprop="url">Hello_My_Blog</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-03-04 20:30:15" itemprop="dateCreated datePublished" datetime="2024-03-04T20:30:15+08:00">2024-03-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2024-03-30 19:50:54" itemprop="dateModified" datetime="2024-03-30T19:50:54+08:00">2024-03-30</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.😊</p>
<p>兜兜转转一个月终于把自己的博客搭建的可以见人了，虽然里面还没什么有用的信息，就暂且当作自己的一方天地，保存些计算机科学学习的过程。过些阵子回头看，能感叹时光不枉虚度。</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name"></p>
  <div class="site-description" itemprop="description">We losers do nothing so winners keeping winning <br> </br> 仍在施工中</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">6</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2024</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>


  <script defer src="/lib/three/three.min.js"></script>
    <script defer src="/lib/three/canvas_lines.min.js"></script>


  















  

  

</body>
</html>
